[{"title":"最短路算法","url":"/posts/789/","content":"\n> 最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。\n\n![最短路](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png)\n\n# 单源最短路\n即对确定的源点（起点）， 求它到其它所有可达的点的最短路径。\n对于单源最短路算法， 又可以分为处理正权边图和带负权边图的两种。\n\n<!--more-->\n\n## 正权图——Dijkstra算法\n\n个人认为对Dijkstra算法的一个很形象的描述是： 将边看作一条条水渠， 边的权为水渠的长度(m)。在源点处倒入水， 假设水的速度恒定为1m/s， 那么**当水首次流到顶点X时， 所经过的时间就是源点到X的最短路径长度。**\n\n以下图举例：\n\n![未命名文件](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n假设从A倒入水， 水四散向每个可能的方向流出。那么水流首先会到达B顶点， 这也是水流第一次经过B顶点， 所以A-B的最短路径长度即为1。 类似的， 我们可以得出水流依次经过的顶点顺序为`A -> B -> C -> D -> D`， 其中D取第一次经过时的时间， 也就是9。\n\nDijkstra算法的思想基本如此， 但抽象为计算机语言却有些不同， 接下来讲讲Dijkstra算法的实现过程。\n\n- 将顶点编号为1~n\n- 维护一个数组dist， dist[i]表示目前顶点i和源点的最短路径长度， 开始时dist初始化为正无穷， 而源点的dist设为0, 表示当前只知道源点到源点的路径长度为0.\n\n整个Dijkstra算法就是基于bfs以及贪心对dist数组更新的一个过程。\n\n在算法中重复执行此过程： 取出目前未遍历过且dist最小的一个顶点， 更新其所有指向的顶点的dist\n\n例如以此图举例\n\n![未命名文件](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n第一次： dist[A] = 0， 其它都为正无穷， 因此遍历A结点， 并更新A指向的所有结点的dist\n\n更新完毕后dist[B] = 1, dist[C] = 5, dist[D] = 10.\n\n第二次： 取出B顶点遍历， dist[D] = min (dist[D], dist[B] + weight(B -> D)) （这一步也叫做松弛操作)， 所以dist[D]被更新为9\n\n以此类推。\n\n以不严谨的角度， 可以稍微解释下Dijkstra算法的正确性： 每次都只选择dist最小的顶点， 是因为dist更大的顶点可能被dist小的顶点再加一段路径而更新掉， 而最小的dist在没有负权边的情况下必然是最短路径。\n\n在代码实现上， 由选择dist最小顶点的手段的不同可以分为朴素Dijkstra和堆优化Dijkstra\n\n### 朴素Dijkstra\n\n朴素版本的Dijkstra在选择顶点时， 采用的方式是直接遍历dist数组， 而选出未被遍历过且dist最小的顶点。\n\n每次选择至少都会确定一个顶点的最短路径， 所以至多要选择n次； 而每次选择的过程中都要遍历一次dist数组， 因此时间复杂度为$O(n^2)$\n\n```cpp\nint n, m, g[N][N];\nint vis[N], dist[N];\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= n; i ++) {\n        int t = -1;\n        for (int j = 1; j <= n;  j++) {\n            if (!vis[j] && (t == -1 || dist[j] < dist[t])) {\n                t = j;\n            }\n        }\n        vis[t] = 1;\n        for (int j = 1; j <= n; j ++) {\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        }\n    }\n}\n```\n\n### 堆优化Dijkstra\n\n前面提到过Dijkstra本质上可以看成一个bfs的过程， 但bfs下次要遍历的顶点并不像普通的bfs那样随意， 而是要选择dist最小的顶点。 我们可以用优先队列(小根堆)来实现这一过程， 每次选择时， 直接取出堆顶元素， 然后更新dist并把被更新过的顶点及其dist加入优先队列。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint vis[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    priority_queue<pii, vector<pii>, greater<>> heap;\n    heap.push({0, src});\n    while (heap.size()) {//以堆被清空为结束标志\n        auto [v, x] = heap.top(); heap.pop();\n        if (vis[x]) {//已被遍历过， 直接跳过\n            continue;\n        }\n        vis[x] = true;\n        for (int i = h[x], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (v + w[i] < dist[j]) {//被更新\n                dist[j] = v + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n}\n```\n\n优先队列让取出dist最小的顶点能以O(1)的代价实现， 但每次取出后的调整为O($logn$)， 遍历所有边为O($mlogn$)， 因此时间复杂度为$O((n + m) logn)$\n\n### 两种实现方式的适用场景\n\n虽然堆优化Dijkstra的时间复杂度看上去比朴素算法更优秀， 但堆优化的时间会受到边数的影响， 当边数与顶点数的平方为一个量级时， 堆优化的时间和空间开销都不乐观。\n\n所以一般的， 当图为稠密图时（m 与 n^2^同一个量级), 使用邻接矩阵存储， 朴素Dijkstra；当图为稀疏图时(m远小于n^2^)， 使用邻接表存储， 堆优化Dijkstra.\n\n## 负权图最短路\n\n前面提到， dijkstra是不能处理带负权边的图的， 因为这会导致dijkstra算法最根本的贪心思想不再正确——当dist[i]最小时， dist[i]不一定是源点到i的最短路径， 因为dist[i]可能大于dist[j] + 某个负数。\n\n### Bellman-Ford算法\n\nBellman-Ford算法(以下简称BF算法)基于动态规划的思想， 与Dijkstra类似的是， BF算法同样维护最短路径长度数组dist。 不同的是， Dijkstra使用贪心思想， 选取目前dist最小的顶点， 并遍历其所有出边来更新dist数组；而BF算法则是直接在每次循环过程中遍历整个边集， 来达到更新dist数组的目的。\n\n即对于每一条边[src, dest, weight]， 都取出来并执行松弛操作：` dist[dest] = min(dist[dest], weight + dist[src])`\n\n假设顶点A到顶点B的最短路径中有k条边， 则k小于等于n-1； 显然可以发现的是， 每次遍历边集都至少更新A到B路径中的一条边为最短路径， 所以至多需要遍历n-1次。\n\n设边的数量为m， 则BF算法的时间复杂度为$O(nm)$。\n\n因为BF算法只需要遍历边集， 所以存储图的时候可以只建立一个边集数组。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\nint dist[N], n, m;\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i < n; i ++) {\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], dist[a] + w);\n        }\n    }\n}\n```\n\n### SPFA(队列优化Bellman-Ford)\n\nBF算法的时间复杂度为$O(nm)$， 在一般的图中m都是远大于n, 如此看来BF虽然能处理负权边， 但效率却远低于dijkstra。\n\nBF的效率低在了哪里？显然是每次都遍历整个边集数组， 但其实其中真正的更新了dist的边却不多。\n\nSPFA正是对BF算法这个痛点进行了优化。 \"SPFA\"， 即**Shortest Path Faster Algorithm**， 从名字上也能看出大家对其效率上的认可。\n\nSPFA基于这样一个事实： 对于边[src, dest, weight]， 只有当dist[src]发生改变后， 该边才可能用于更新dist[dest]， 这就是说**只有dist发生改变的顶点的出边才有被遍历的价值。**这一点与Dijkstra算法不谋而合， 所以SPFA与Dijkstra算法在形式上是类似的。\n\n对于SPFA是实现细节， 特别要提的一点是st数组， 在这里st[i]用于标记顶点i是否在队列中， 以免顶点重复入队， 这显然是没用意义的。\n\nSPFA的复杂度并不稳定， 对于一般数据， 它要比朴素BF快得多， 甚至能以同样的时间处理正权图；但对于针对型数据， 复杂度最坏能退化到和BF一样的$O(nm)$。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid spfa (int src) {\n    queue<int> q;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0, q.push(1);\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i];\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n}\n```\n\n### BF和SPFA的其它应用\n#### BF求解有边数限制的最短路径\n\n在BF算法那里我们提到， 假设1~n的最短路径中有k条边， 那么每次遍历边集都至少可以更新它的一条边。为什么是“至少”呢？这是因为在遍历边集的途中边的更新可能发生串联， 如`A->B->C`， 如果先遍历了`A->B`再遍历`B->C`， 则一次遍历就更新了两条边， 反之只能更新`A->B`这一条边。\n\n我们可以使用一些手段， 使得每次遍历边集都只能更新一条边， 那么若只循环k次， 则边数大于k的最短路径将不能被发现。\n\n这个手段就是， 在每次遍历边集前， 将dist数组拷贝一份为backup， 使用上一次的dist数组来更新当前的dist数组， 这就可以避免串联。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\n\nint dist[N], n, m, k, backup[N];\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= k; i ++) {\n        memcpy(backup, dist, sizeof dist);\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], backup[a] + w);\n        }\n    }\n}\n```\n\n#### SPFA判断负环\n普通的SPFA是不能处理带负环的图的， 否则会陷入死循环； 但是我们可以通过记录额外信息来判断图中是否出现负环。\n\n记录cnt[i]为当前i顶点到源点最短路径中的边数， 若cnt[i] >= n， 则显然存在负环。\n\n要注意的点是， 由于图可能并不连通， 因此初始时要把所有顶点入队； 在这里并不是为了求最短路， 所以dist可以不初始化， 只需要保证初始全部相同即可。\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], cnt[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nbool spfa () {\n    queue<int> q;\n    for (int i = 1; i <= n; i ++) {\n        q.push(i), st[i] = true;\n    }\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i], cnt[j] = 1 + cnt[u];\n                if (cnt[j] == n) {\n                    return true;\n                }\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n```\n\n# 多源最短路\n\n多源最短路， 也叫做全局最短路， 即求出图中任意两个点的最短路径。\n\n## Floyd-Warshell算法\n\n> **Floyd-Warshall算法**（英语：Floyd-Warshall algorithm），中文亦称**弗洛伊德算法**或**佛洛依德算法**[[1\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-1)，是解决任意两点间的[最短路径](https://zh.wikipedia.org/wiki/最短路径)的一种[算法](https://zh.wikipedia.org/wiki/算法)[[2\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-2)，可以正确处理[有向图](https://zh.wikipedia.org/wiki/有向图)或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包[[3\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-3)。\n\nF-W算法基于动态规划， 它依赖于这样一个事实： 若i到j的最短路径为dist\\[i][j]， 则对于任意顶点k， dist\\[i][k] + dist\\[k][j] >= dist\\[i][j]。 反之dist\\[i][j]就不为最短路径， 应更新为dist\\[i][k] + dist\\[k][j]。\n\n动态规划的思想如下：\n\n* 使用三维数组f\\[k]\\[i][j]表示**路径中(除源点和汇点)只出现过前k个顶点时**， i顶点到j顶点的最短路径\n\n* 当考虑f\\[k]\\[i][j]时， 可分为两种情况： i->j最短路径不经过k顶点， 即f\\[k-1]\\[i][j]; 经过k顶点， 即f\\[k - 1]\\[i][k] + f\\[k - 1]\\[k][j]。所以状态转移方程为：\n  $$\n  f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k] + f[k - 1][k][j])\n  $$\n\n可以发现， f[k]只与f[k-1]相关， 所以只需要用二维数组存储每次迭代完的状态, 然后在上一次迭代的基础上进行状态转移。\n\n对应到图的存储， 只需要用邻接矩阵存储图， 然后在矩阵中进行递推即可。\n\n```cpp\nint g[N][N], n;\n\nvoid floyd () {\n    for (int k = 1; k <= n; k++)\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j ++)\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n}\n```\n\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"排序算法","url":"/posts/61237/","content":"\n没什么写， 突发奇想总结一下以前写过的排序算法， 权当复习。\n\n> 以下皆以升序举例， a为默认数组名， n默认为数组长度\n## 冒泡排序\n大多数人学的第一个排序算法就算冒泡排序， 思想是每次比较相邻的两个数， 如果与升序不符合就进行交换； 从前到后一轮交换下来， 不难发现最大值会被交换到最后位， 因此下次只需要对前n-1个元素进行遍历即可。\n\n每轮交换至少确定一个数的位置， 所以最多需要进行n - 1轮, 时间复杂度为$O(n ^ 2)$\n\n<!--more-->\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j < n - i - 1; j ++) {\n            if (a[j] > a[j + 1]) {\n                swap(a[j], a[j + 1]);\n            }\n        }\n    }\n}\n```\n\n## 选择排序\n\n思想是每次都从剩余序列中选出一个最小值放到前面， 经过n-1次选择后数组即有序。\n\n可以发现选择排序的过程其实和冒泡排序差不多， 但选择排序第`i`次选择只需要交换一次， 比较`n - i + 1`次， 而冒泡排序在比较次数相同的情况下， 还会有更多次交换。 因此选择排序的常数要比冒泡排序小。\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n - 1; i ++) {\n        int m = i;\n        for (int j = i + 1; j < n; j ++) {\n            if (a[j] < a[m]) {\n                m = j;\n            }\n        }\n        swap(a[i], a[m]);\n    }\n}\n```\n\n## 插入排序\n\n插入排序是$O(n^2)$排序中表现最好的排序， 思想正如其名， 先将前`i`个元素排序， 在把第`i + 1`个元素插入前面已经有序的序列中。\n\n插入排序的优势在于， 比较次数并不是死板的， 而是取决于元素应插入的位置。 特别的， 如果对有序序列进行插入排序， 那么每次插入只需要比较一次， 时间复杂度为$O(n)$。而对基本有序的序列， 插入排序效率也会更高。\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 1; i < n; i ++) {\n        int x = a[i], j = i - 1;\n        for (; j >= 0; j --) {\n            if (a[j] > x) {\n                a[j + 1] = a[j];\n            } else {\n                break;\n            }\n        }\n        a[j + 1] = x;\n    }\n}\n```\n\n\n\n## 希尔排序\n\n希尔排序基于对插入排序的优化， 是第一个出现的时间复杂度低于$O(n^2)$的排序。\n\n前面提到， 当序列有序程度增大时， 插入排序的效率也会随之升高。希尔排序会先对数组的子数组进行插入排序， 直到数组有序程度较高， 再对整个数组进行插入排序。\n\n在子数组的选择策略上， 我们选择从第一个元素开始的、下标间隔相同的所有元素， 如`[3, 8, 3, 2, 4]`， 若间隔为2， 子数组应该是`[3, 3, 4]`。\n\n在实现上， 我们选择多组不同的间隔， 这里也叫做增量， 按增量从大到小的顺序依次对相应的子数组进行插入排序。 这里引入一个新的名词：***增量序列***， 增量序列是一个递增、初始项为1的正整数序列， 即为我们选择的间隔序列， 如`[1, 2, 4, 8]`， 如果我们要对长度为7的子数组使用该增量序列进行希尔排序， 则我们应该依次对增量为4, 2, 1的子数组进行插入排序， 显然增量为1的子数组即为原数组， 所以按增量序列依次进行插入排序最后肯定是能达到排序的效果的。\n\n显然希尔排序的效率会受到增量序列的影响， 希尔排序的时间复杂度证明非常复杂， 受限于水平不在此说明。\n\n比较常见的增量序列有发明者希尔推荐的**希尔序列**：`[1, ..., len / 4, len / 2]`, 以及效率更高的**Sedgewick序列**\n\n```cpp\nint Sedgewick[]={28,\n    1,5,19,41,109,209,505,929,\n    2161,3905,8929,16001,36289,64769,146305,260609,\n    587521,1045505,2354689,4188161,9427969,16764929,37730305,67084289,\n    150958081,268386305,603906049,1073643521};\n```\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = n >> 1; i;  i >>= 1) {//使用Shell序列\n        for (int j = i; j < n; j += i) {\n            int x = a[j], k = j - i;\n            for (; k >= 0; k -= i) {\n                if (a[k] > x) {\n                    a[k + i] = a[k];\n                } else {\n                    break;\n                }\n            }\n            a[k + i] = x;\n        }\n    } \n}\n```\n\n## 归并排序\n\n归并排序是非常经典的分治算法， 思想是非常简单的：\n\n* 将数组分为左右两半\n* 对左半边数组和右半边数组进行归并排序\n* 将两段有序数组合并成一个有序数组\n\n显然很适合用递归来实现， 而用递归最重要的就算确定递归的边界， 这里的边界就是数组的长度小于1， 此时数组已然是有序的。\n\n在合并数组时， 若要达到线性的合并时间， 就要用到一个辅助数组， 将两边数组按大小依次填入辅助数组， 最后将辅助数组的数据写回原数组;显然辅助数组的长度最大要为n, 因此空间复杂度为$O(n)$。\n\n在时间复杂度上， 考虑递归的层数。 因为每次递归会将数组分成两半， 所以层数最大为$O(log n)$， 由于合并的时间复杂度为线性， 所以时间复杂度应为$O(nlog n)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r, int t[]) {\n    if (l >= r) {\n        return;\n    }\n    int m = (l + r) >> 1;\n    Sort(a, l, m, t), Sort(a, m + 1, r, t);\n    //合并\n    int i = l, j = m + 1, k = l;\n    while (i <= m && j <= r ) {\n        if (a[i] < a[j]) {\n            t[k ++] = a[i ++];\n        } else {\n            t[k ++] = a[j ++];\n        }\n    }\n    while (i <= m) {\n        t[k ++] = a[i ++];\n    }\n    while (j <= r) {\n        t[k ++] = a[j ++];\n    }\n    for (i = l; i <= r; i ++) {\n        a[i] = t[i];\n    }\n}\n```\n\n## 快速排序\n\n快速排序也是一个分治算法， 思想如下：\n\n* 从当前数组选出任意一个数作为枢纽p\n* 把数组中所有比p小的数放到p左边， 大的数放到右边(相等随意)， 这个过程叫做划分。\n* 对p左边的元素和右边的元素进行快速排序。\n\n第一次看到时肯定是很迷茫的， 经过上面的递归过程数组怎么就有序了呢？\n\n可以用类似数学归纳法的方法证明：\n\n* 首先来看递归边界： 当数组的长度小于等于1时， 数组本身是有序的。\n\n* 设数组经过划分后， 分出左右两个子数组为L/R， **假设L, R经过快速排序， 可以变成有序**\n* 此时有`L < p < R`， 显然当前数组也为有序\n\n以上就是快速排序的思想， 但要想让快速排序‘快速’， 我们就要考虑划分操作的实现。\n\n最容易想到的是， 使用两个辅助数组， 来记录两边的信息；这当然是可以的， 但空间复杂度将于归并排序相同为$O(n)$\n\n但先人发明了一个非常巧妙的双指针算法， 能以$O(n)$时间复杂度、$O(1)$空间复杂度完成划分操作。\n\n基本思想是： 使用两个指针i, j， 从数组两边想中间遍历， i会停止在大于p的元素上， j会停止在小于p的元素上；当i， j都停止时， 将i、j指向元素进行一次交换。 遍历结束于i，j相遇。\n\n关于时间复杂度， 我们同样关注递归的深度。 但快排于归并排序不同的是， 每次划分后两边的元素数量不一定相等， 因此快排的时间复杂度会取决于数据， 具有随机性。\n\n对于快排的最好情况：每次划分都能划分为两个元素数量差不多的两边， 此时时间复杂度为$O(nlog n)$； 对于快排的最坏情况， 每次划分都把全部元素划分到一边， 而另一边为空， 此时递归深度为n, 时间复杂度为$O(n^2)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int p = a[(l + r) >> 1], i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while(a[i] < p);\n        do j--; while(a[j] > p);\n        if (i < j) swap(a[i], a[j]);\n    }\n    Sort(a, l, j), Sort(a, j + 1, r);\n}\n```\n\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"线段树","url":"/posts/48555/","content":"\n## 线段树简介\n线段树常用来解决多次区间修改以及区间性质查询的问题， 且区间的性质一般可以由子区间推出， 如最大值、区间和。\n\n## 线段树的结构\n线段树顾名思义显然是一棵树， 且一般实现为二叉树。\n线段树满足：\n\n- 树上每一个结点都代表着一段区间\n\n- 每个结点的两个子结点分别代表该区间的左右子区间。\n\n<!--more-->\n\n如区间[1, 5]用线段树表示为\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n显然， 线段树具有搜索树的性质。\n\n## 基本建树\n\n### 线段树的存储\n\n线段树常用存储完全二叉树的方式、数组形式存储， 即根结点下标为1， 对于结点i， 它的左儿子下标为`2 * i`， 右儿子下标为`2 * i + 1`。\n\n下面以图的形式展示各结点下标关系\n\n```mermaid\ngraph TD;\n\tA((\"1<br>[1, 5]\")) --> B((\"2<br>[1, 3]\"))\n\tA --> C((\"3<br>[4, 5]\"))\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n至于数组的大小， 一般开到区间长度的四倍， 因为结点个数最多不会操过区间长度的四倍， 可自行证明。\n\n### 代码实现\n\n假设区间性质为区间和\n\n```c++\nconst int N = xxx;\nint a[N];//原数组\nint f[N << 2];//存储线段树结点的某性质\n\nvoid bulid (int k, int l, int r) {\n    if (l == r) {\n        f[k] = a[i];\n        return;\n    }\n\t int m = l + r >> 1;\n\t build(2 * k, l, m), bulid(2 * k + 1, m + 1, r);\n    f[k] = f[2 * k] + f[2 * k + 1];//由子区间推出当前区间\n}\n```\n\n## 线段树的单点修改及查询\n\n**例题 - [洛谷P3374](https://www.luogu.com.cn/problem/P3374)**\n\n>#### 题目描述\n>\n>如题，已知一个数列，你需要进行下面两种操作：\n>\n>- 将某一个数加上 x*\n>- 求出某区间每一个数的和\n>\n>#### 输入格式\n>\n>第一行包含两个正整数 n*,*m*，分别表示该数列数字的个数和操作的总个数。\n>\n>第二行包含 *n* 个用空格分隔的整数，其中第 *i* 个数字表示数列第 i*i* 项的初始值。\n>\n>接下来 *m* 行每行包含 33 个整数，表示一个操作，具体如下：\n>\n>- `1 x k` 含义：将第 x*x* 个数加上 *k*\n>- `2 x y` 含义：输出区间 [x,y][*x*,*y*] 内每个数的和\n>\n>#### 输出格式\n>\n>输出包含若干行整数，即为所有操作 2 的结果。\n>\n>#### 输入输出样例\n>\n>**输入 #1**\n>\n>```\n>5 5\n>1 5 4 2 3\n>1 1 3\n>2 2 5\n>1 3 -1\n>1 4 2\n>2 1 4\n>```\n>\n>**输出 #1**\n>\n>```\n>14\n>16\n>```\n>\n>#### 说明/提示\n>\n>【数据范围】\n>\n>$1 \\leq n, m \\leq 10^5$\n\n### 单点修改\n\n在区间和线段树已经构建完成的情况下， 此时若要将某元素的值增大，则会有多个区间的和发生变化。\n\n因此可以对线段树进行一次搜索， 将所有包含被修改元素的区间的区间和增大。\n\n```c++\n//k, l, r表示当前区间的下标及边界， x、y为被修改的元素下标和增大的值\nvoid modify (int k, int l, int r, int s, int v) {\n    f[k] += v;\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    if (s <= m) {//x在左半边\n        modify(2 * k, l, m, s, v);\n    } else {//x在右半边\n        modify(2 * k + 1, m + 1, s, v);\n    }\n}\n```\n\n显然单点修改线段树的时间复杂度与树高有关， 为$O（log n)$\n\n ### 区间查询\n\n由于区间和是可以由子区间推出的， 所以要求出[b, e]区间的区间和， 就要把[b, e]区间分解为若干个线段树上存在的区间。\n\n如\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n若要查询[3, 5], 则应该分解为[3, 3] + [4, 5]\n\n```c++\nint query (int k, int l, int r, int b, int e) {\n    if (l == b && r == e) {\n        return f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {//[b, e]完全在左区间\n        return query(2 * k, l, m, b, e);\n    } else if (b > m) {//完全在右区间\n        return query(2 * k + 1, m + 1, b, e);\n    } else {//[b, e]在左右区间均有分布\n        return query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, b, e);\n    }\n}\n```\n\n查询时， 最坏情况下最遍历到最底层, 且支数是有限的， 时间复杂度为$O(log n)$\n\n### 完整代码\n\n```cpp\n//\n// Created by trudbot.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5;\nint a[N], f[N << 2];\nint n, m;\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m);\n\tbuild(2  *k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int s, int v) {\n\tf[k] += v;\n\tif(l == r) {\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tif(s <= m) {\n\t\tmodify(2 * k, l, m, s, v);\n\t} else {\n\t\tmodify(2 * k + 1, m + 1, r, s, v);\n\t}\n}\n\nint query(int k, int l, int r, int b, int e) {\n\tif(l == b && r == e) {\n\t\treturn f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(e <= m) {\n\t\treturn query(2 * k, l, m, b, e);\n\t} else if(b > m) {\n\t\treturn query(2 * k + 1, m + 1, r, b, e);\n\t} else {\n\t\treturn query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\t\n\twhile(m --) {\n\t\tint x, a, b; cin >> x >> a >> b;\n\t\tif(x == 1) {\n\t\t\tmodify(1, 1, n, a, b);\n\t\t} else {\n\t\t\tcout << query(1, 1, n, a, b) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 线段树的区间修改及查询\n\n> #### 【模板】线段树 1\n>\n> #### 题目描述\n>\n> 如题，已知一个数列，你需要进行下面两种操作：\n>\n> 1. 将某区间每一个数加上 $k$。\n> 2. 求出某区间每一个数的和。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n>\n> 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n>\n> 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n>\n> 1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。\n> 2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。\n>\n> #### 输出格式\n>\n> 输出包含若干行整数，即为所有操作 2 的结果。\n>\n> #### 样例 #1\n>\n> ##### 样例输入 #1\n>\n> ```\n> 5 5\n> 1 5 4 2 3\n> 2 2 4\n> 1 2 3 2\n> 2 3 4\n> 1 1 5 1\n> 2 1 4\n> ```\n>\n> ##### 样例输出 #1\n>\n> ```\n> 11\n> 8\n> 20\n> ```\n>\n> #### 提示\n>\n> 对于 $30\\%$ 的数据：$n \\le 8$，$m \\le 10$。  \n> 对于 $70\\%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。  \n> 对于 $100\\%$ 的数据：$1 \\le n, m \\le {10}^5$。\n>\n> 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n>\n> **【样例解释】**\n>\n> ![](https://cdn.luogu.com.cn/upload/pic/2251.png)\n\n### 区间修改与永久懒惰标记\n\n这次要求将区间所有元素都加上某个数， 直接遍历加上再重新建树肯定不行， 这样时间复杂度会来到$O(n)$；更加不能对区间每一个元素都进行单点修改， 否则时间复杂度为$O(n log n)$。\n\n这时我们需要用一个懒惰标记的手段， 对于修改的区间[b, e]， 我们把它分解为线段树上若干的区间， 对这些区间增加一个“标记”， 即标记增加了x。而对分解区间的父区间， 则是直接修改f值。\n\n如下图， 假设为在[3, 5]区间加上x， 且用v[N<<2]来记录某结点区间加的值。\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>f[1] += (5-3+1) * x\") --> B(\"2<br>[1, 3]<br>f[2] += (3-3+1)*x\")\n\tA --> C(\"3<br>[4, 5]<br>v[3] += x\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>v[5] += x\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n```c++\nvoid modify (int k, int l, int r, int b, int e, int x) {\n    if (b == l && e == r) {\n        v[k] += x;\n        return;\n    }\n    f[k] += (e - b + 1) * x;\n    int m = l + r >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, x);\n    } else if (b > m) {\n        modify(2 * k + 1, m+1, r, b, e, x);\n    } else {\n        modify(2 * k, l, m, b, m, x);\n        modify(2 * k + 1, m + 1, r, m + 1, e, x);\n    }\n}\n```\n\n\n\n### 区间查询\n\nv[i] += x表示在对i号结点区间[l, r]上的每个元素都加上了x， 所有包含[l, r]的大区间也都已经都记录了变化； 但如果我们要查询的是[l, r]的子区间呢？\n\n这时对懒惰标记的处理就至关重要了， 在向下遍历线段树的途中用一个变量来记录沿途的标记， 最后在加到被查询区间上。\n\n如\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>v[1] = x\") --> B((\"2<br>[1, 3]<br>\"))\n\tA --> C(\"3<br>[4, 5]<br>v[3] = y\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n此时v[1]和v[3]上均有标记， 若我们要查询[4, 4]的区间和， 在搜索改区间的过程上会记录路径上的所有标记的和， 所以结果应该为`f[6] + (x + y) * (4 - 4 + 1)`\n\n```c++\n\nll query(int k, int l, int r, int b, int e, int p) {\n    p += v[k];\n    if(l == b && r == e) {\n        return p * (r - l + 1) + f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {\n        return query(2 * k, l, m, b, e, p);\n    } else if (b > m) {\n        return query(2 * k + 1, m + 1, r, b, e, p);\n    } else {\n        return query(2 * k, l, m, b, m, p) + query(2 * k + 1, m + 1, r, m + 1, e, p);\n    }\n}\n```\n\n \n\n### 完整代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N<<2], v[N<<2];\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m), build(2 * k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int x, int y, int z) {\n\tif(l == x && r == y) {\n\t\tv[k] += z;\n\t\treturn;\n\t}\n\tf[k] += (y - x + 1) * z;\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\tmodify(k * 2, l, m, x, y, z);\n\t} else if(x > m) {\n\t\tmodify(k * 2 + 1, m + 1, r, x, y, z);\n\t} else {\n\t\tmodify(2 * k, l, m, x, m, z);\n\t\tmodify(2 * k + 1, m + 1, r, m + 1, y, z);\n\t}\n}\n\nll query(int k, int l, int r, int x, int y, ll p) {\n\tp += v[k];\n\tif(l == x && r == y) {\n\t\treturn p * (r - l + 1) + f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\treturn query(2 * k, l, m, x, y, p);\n\t} else if(x > m) {\n\t\treturn query(2 * k + 1, m + 1, r, x, y, p);\n\t} else {\n\t\treturn query(2 * k, l, m, x, m, p) \n\t\t\t+ query(2 * k + 1, m + 1, r, m + 1, y, p);\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\twhile (m --) {\n\t\tint t; cin >> t;\n\t\tif(t == 1) {\n\t\t\tint x, y; ll z; cin >> x >> y >> z;\n\t\t\tmodify(1, 1, n, x, y, z);\n\t\t} else {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcout << query(1, 1, n, x, y, 0) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 标记下传与自下而上更新\n\n在上述标记永久化方法中， 对标记的处理方法是：\n\n* modify时的被标记区间的父区间不标记， 而是直接修改。\n* query时， 会累加遍历路径中的标记， 最后作用于查询区间。\n\n但使用标记永久化的很重要的一个条件是标记可以累加， 很多时候可以并不能满足。\n\n而标记下传是适用性更广的一种标记处理方法， 有两个核心方法：\n\n* pushdown， 把当前结点的标记下传\n* pushup， 由子结点更新当前结点。\n\n标记下传的基本规则是：\n\n* 为某结点添加标记时， 会修改结点的值。\n* 在遍历到线段树的某个结点时， 若还要往下遍历， 则把标记下传， 并在遍历完子树后更新当前结点。\n\n标记下传是一种延迟修改的思想， 在修改[l, r]时如果直接把它的每一个子区间都修改， 显然在时间复杂度上是灾难。 但标记下传只在需要查询/修改子区间时把上一次的修改作用于子区间， 修改的过程融合在了查询/其它修改 的过程中。\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N << 2], v[N << 2];\n\nvoid pushup(int k) {\n    f[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid pushdown(int k, int l, int r) {\n    if (v[k]) {\n        int left = 2 * k, right = left + 1, m = (l + r) >> 1;\n        f[left] += v[k] * (m - l + 1), f[right] += v[k] * (r - m);\n        v[left] += v[k], v[right] += v[k], v[k] = 0;\n    }\n}\n\nvoid build(int k, int l, int r) {\n    if(l == r) {\n        f[k] = a[l];\n        return;\n    }\n    int m = (l + r) >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n    pushup(k);\n}\n\nvoid modify (int k, int l, int r, int b, int e, int s) {\n    if(l == b && e == r) {\n        f[k] += (r - l + 1) * s;\n        v[k] += s;\n        return;\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, s);\n    } else if (b > m) {\n        modify(2 * k + 1, m + 1, r, b, e, s);\n    } else {\n        modify(2 * k, l, m, b, m, s), modify(2 * k + 1, m + 1, r, m + 1, e, s);\n    }\n    pushup(k);\n}\n\nll query(int k, int l, int r, int b, int e) {\n    if (l == b && e == r) {\n        return f[k];\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    ll res;\n    if (e <= m) {\n        res = query(2 * k, l, m, b, e);\n    } else if (b > m ) {\n        res = query(2 * k + 1, m + 1, r, b, e);\n    } else {\n        res = query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n    }\n    pushup(k);\n    return res;\n}\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int b, e, x; cin >> b >> e >> x;\n            modify(1, 1, n, b, e, x);\n        } else {\n            int b, e; cin >> b >> e;\n            cout << query(1, 1, n, b, e) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 线段树实战\n\n### 旅馆\n\n[261. 旅馆 - AcWing题库](https://www.acwing.com/problem/content/description/263/)\n\n> 一家旅馆共有 N 个房间，这 N 个房间是连成一排的，标号为 1∼N。\n>\n> 现在有很多旅客以组为单位前来入住，每组旅客的数量可以用 Di来表示。\n>\n> 旅店的业务分为两种，入住和退房：\n>\n> 1. 旅客入住时，第 i 组旅客需要根据他们的人数 D~i~，给他们安排 D~i~ 个连续的房间，并且房间号要尽可能的小。如果房间不够，则无法安排。\n> 2. 旅客退房时，第 i 组旅客的账单将包含两个参数 X~i~ 和 D~i~，你需要将房间号 X~i~到 X~i~+D~i~−1之间的房间全部清空。\n>\n> 现在你需要帮助该旅馆处理 M 单业务。\n>\n> 旅馆最初是空的。\n>\n> #### 输入数据\n>\n> 第一行输入两个用空格隔开的整数 N 和 M。\n>\n> 接下来 M 行将描述 M 单业务：\n>\n> “1 D~i~”表示这单业务为入住业务。\n>\n> “2 X~i~ D~i~”表示这单业务为退房业务。\n>\n> #### 输出数据\n>\n> 每个入住业务输出一个整数，表示要安排的房间序列中的第一个房间的号码。\n>\n> 如果没办法安排，则输出 0。\n>\n> 每个输出占一行。\n>\n> #### 数据范围\n>\n> 1≤D~i~≤N≤50000\n> 1≤M<50000\n>\n> #### 输入样例：\n>\n> ```\n> 10 6\n> 1 3\n> 1 3\n> 1 3\n> 1 3\n> 2 5 5\n> 1 6\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 1\n> 4\n> 7\n> 0\n> 5\n> ```\n\n#### 题意解析\n对于长度为N的01串（下标从1开始）， 需实现以下两种操作：\n* 查询串中最靠左的长度为d的全0串， 并返回左端点（若不存在返回0）； 随后把这个全0串变成全1串。\n* 把区间[x, x + d - 1]变成全0\n\n#### 思路\n设计线段树的结点保存区间的三种信息：\n- 区间中的最长0串长度\n- 区间中以左端点开始的最长0串长度\n- 区间中以右端点结束的最长0串长度\n\n这样设计的巧妙之处在于：\n- 由两个子区间的信息可以推出当前区间的信息\n- 通过三个信息可以递归查找出最左的长度为d的0串\n\n#### 代码\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50010;\n\nstruct node{\n    int l, r;\n    int m, lm, rm;\n    int s;\n} f[N << 2];\n\ninline void allSet (int k, int v) {\n    f[k].m = f[k].lm = f[k].rm = v;\n}\n\ninline void build (int k, int l, int r) {\n    f[k].l = l, f[k].r = r, f[k].s = 0;\n    allSet(k, r - l + 1);\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n}\n\ninline void pushdown (int k) {\n    int left = 2 * k, right = left + 1;\n    if (f[k].s == 1) {\n        allSet(left, 0), allSet(right, 0);\n    } else if (f[k].s == -1) {\n        allSet(left, f[left].r - f[left].l + 1), \n        allSet(right, f[right].r - f[right].l + 1);\n    } else {\n        return;\n    }\n    f[left].s = f[right].s = f[k].s, f[k].s = 0;\n}\n\nvoid pushup (int k) {\n    int left = 2 * k, right  = left + 1;\n    f[k].m = max(f[left].m, max(f[right].m, f[left].rm + f[right].lm));\n    f[k].lm = f[left].lm;\n    if (f[left].lm == f[left].r - f[left].l + 1) {\n       f[k].lm += f[right].lm; \n    }\n    f[k].rm = f[right].rm;\n    if (f[right].rm == f[right].r - f[right].l + 1) {\n        f[k].rm += f[left].rm;\n    }\n}\n\nint query (int k, int len) {\n    if (f[k].m < len) {\n        return 0;\n    }\n    pushdown(k);\n    if (f[k].lm >= len) {\n        return f[k].l;\n    } else if (f[2 * k].m >= len) {\n        return query(2 * k, len);\n    } else if (f[2 * k].rm + f[2 * k + 1].lm >= len) {\n        return f[2 * k].r - f[2 * k].rm + 1;\n    } else {\n        return query(2 * k + 1, len);\n    }\n}\n\nvoid modify (int k, int l, int r, int s) {\n    if (f[k].l == l && f[k].r == r) {\n        if (s == 1) {\n            allSet(k, 0);\n        } else {\n            allSet(k, f[k].r - f[k].l + 1);\n        }\n        f[k].s = s;\n        return;\n    }\n    pushdown(k);\n    int m = f[k].l + f[k].r >> 1;\n    if (r <= m) {\n        modify(2 * k, l, r, s);\n    } else if (l > m) {\n        modify(2 * k + 1, l, r, s);\n    } else {\n        modify(2 * k, l, m, s), modify(2 * k + 1, m + 1, r, s);\n    }\n    pushup(k);\n}\n\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int d; cin >> d;\n            int b = query(1, d);\n            cout << b << endl; \n            if (b != 0) {\n                modify(1, b, b + d - 1, 1);\n            }\n        } else {\n            int x, d; cin >> x >> d;\n            modify(1, x, x + d -1, -1);\n        }\n    }\n    return 0;\n}\n```\n\n### 最长递增子序列\n\n> 给你一个整数数组 nums 和一个整数 k 。\n>\n> 找到 nums 中满足以下要求的最长子序列：\n>\n> 子序列 严格递增\n> 子序列中相邻元素的差值 不超过 k 。\n> 请你返回满足上述要求的 最长子序列 的长度。\n>\n> 子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。\n>\n> 示例 1：\n>\n> 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3\n> 输出：5\n> 解释：\n> 满足要求的最长子序列是 [1,3,4,5,8] 。\n> 子序列长度为 5 ，所以我们返回 5 。\n> 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。\n> 示例 2：\n>\n> 输入：nums = [7,4,5,1,8,12,4,7], k = 5\n> 输出：4\n> 解释：\n> 满足要求的最长子序列是 [4,5,8,12] 。\n> 子序列长度为 4 ，所以我们返回 4 。\n> 示例 3：\n>\n> 输入：nums = [1,5], k = 1\n> 输出：1\n> 解释：\n> 满足要求的最长子序列是 [1] 。\n> 子序列长度为 1 ，所以我们返回 1 。\n>\n>\n> 提示：\n>\n> 1 <= nums.length <= 10^5^\n> 1 <= nums[i], k <= 10^5^\n>\n> 来源：力扣（LeetCode）\n> 链接：https://leetcode.cn/problems/longest-increasing-subsequence-ii\n> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n#### 思路分析\n可以注意到数组的元素值是有范围的， 位于[1, 1e5]。\n\n定义a[j]为在数组nums中[0, i]以j结尾的满足题意的最长递增序列长度； 则当考虑nums[i + 1]是， 只需要把nums[i + 1]加到某个序列的末尾， 此序列的最后一个元素x应该满足：x < nums[i + 1] , x >= nums[i + 1] - k.\n\n可以得到x的范围为[nums[i + 1] - k, nums[i + 1] - 1]， 在此区间查找最长的子序列长度， 在更新a[nums[i + 1]]即可。\n\n查询某区间的最大值， 显然可以使用线段树。\n\n#### 代码参考\n时间复杂度：$O(n\\log_2x)$\n```c++\nconst int N = 1e5 + 10;\nint f[N << 2];\n\nvoid modify (int u, int l, int r, int x, int v) {\n    if (l == r) {\n        f[u] = max(f[u], v);\n        return;\n    }\n    int m = (l + r) >> 1;\n    if (x <= m) {\n        modify(2 * u, l, m, x, v);\n    } else {\n        modify(2 * u + 1, m + 1, r, x, v);\n    }\n    f[u] = max(f[2 * u], f[2 * u + 1]);\n}\n\nint query (int u, int l, int r , int b, int e) {\n    if (l == b && r == e) {\n        return f[u];\n    }\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        return query(2 * u, l, m, b, e);\n    } else if (b > m) {\n        return query(2 * u + 1, m + 1, r, b, e);\n    } else {\n        return max(query(2 * u, l, m, b, m),\n            query(2 * u + 1, m + 1, r, m + 1, e));\n    }\n}\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums, int k) {\n        memset(f, 0, sizeof f);\n        int mx = 0;\n        for (auto i : nums) {\n            mx = max(i, mx);\n        }\n        for (auto i : nums) {\n            int t;\n            if (i == 1) {//特判1, 因为比1小的数不在线段树区间范围内\n                t = 0;\n            } else {\n                t = query(1, 1, mx, max(1, i - k), i - 1);\n            }\n            modify(1, 1, mx, i, t + 1);\n        }\n        return f[1];\n    }\n};\n```\n\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"二分查找","url":"/posts/42877/","content":"前言： 二分查找虽然并不是什么很难的东西， 但因为我始终背不下来， 每次要用的时候都得现场小心翼翼地推导细节， 十分苦恼。因此希望通过写一篇笔记总结， 把它刻入我的记忆。\n\n## 基本概念\n不再赘述， 引用维基百科：\n> 在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm）[2]，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n<!--more-->\n\n## 二分查找的框架\n\n二分查找的步骤大概是：\n* 定义二分查找的左右边界\n* 循环体， 循环条件一般为左边界不大于右边界\n* 取中值（**准确说是左右边界的平均值， 即中间元素**）\n* 用中值与查找的目标元素比较， 从而移动左右边界\n\n## 二分查找的三种应用形式\n通过对取中值以及对左右边界移动的细节处理， 可以得到不同功能的二分查找。\n\n### 最朴素的二分查找\n最朴素的二分查找的用法是： 查找某值是否在数组中出现过， 是则返回下标， 否则返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] == target) {\n            return mid;\n        } else if(nums[mid] > target) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n### 查找左边界 / 第一个大于等于target的元素\n在朴素二分中， 若数组中有多个值为target的元素， 返回的下标对于使用者而言是合理情况中的随机一个；若数组中中没有值为target的元素， 返回值将是无意义的-1.\n\n接下来两种二分便是为了解决这一类问题。\n\n在左边界二分中， 要查找的元素`e`满足：e左边的元素都小于target, e右边的元素及e都不小于（大于等于）target.\n\n```cpp\nint binarySearch_lower(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n```\n### 查找右边界 / 第一个小于等于target的元素\n类似的， 在左边界二分中， 要查找的元素`e`满足：e右边的元素都大于target, e右边的元素及e都不大于（小于等于）target.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n```\n### 细节1——取中值时的左偏和右偏\n当`[l, r]`中有奇数个元素时如`[1, 2, 3]`， 中值显然为中间那个元素。\n但当`[l, r]`中有偶数个元素时如`[1, 2, 3, 4]`， 中值到底是2还是3呢？\n\n这就取决于mid的取法了\n```cpp\nmid = (l + r) >> 1;\nmid = (l + r + 1) >> 1; \n```\nc++的中整数除法是与右移一位的效果完全相同的， 即整除， 当[l, r]中有偶数个元素时, 显然`l + r`为奇数， 所以`(l + r) >> 1`结果会偏向l这一边\n而相反的`(l + r + 1) >> 1`会偏向r这一边。\n\n取中的偏向是相当重要的问题， 若使用错误， 二分可能将陷入死循环。\n\n在结论上， 可以简单的记忆为左边界左偏， 右边界右偏\n\n### 细节2——左右边界的更新方式\n边界二分与朴素二分很大的一个区别是： 朴素二分靠mid查找目标值， 若nums[mid] == target就立即返回； 而边界二分是靠不断缩小查找的区间， 最终区间长度为1时(`l == r`)， 区间中唯一的元素即为目标值。\n以左边界二分举例\n```cpp\nwhile(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n```\n要找的是左边界， 当nums[mid] > target时， 是不能将`r`置为`mid - 1`的， 因为也许`mid`就是左边界； 类似的， 当nums[mid] == target时， 你不能确定mid左边是否是左边界， 但mid + 1往后的元素你可以确定一定不是左边界， 因此将r赋为`mid`， 缩小范围， 继续查找。\n而只有当nums[mid] < target时， 才移动l， 此时mid显然不是左边界， 所以将l赋为`mid + 1`\n\n### 补充1——取中值时的溢出\n在区间较大情况下， 使用(l + r)直接取中值时可能会溢出整型范围。\n所以可以用如下方式等价取代\n```cpp\nmid = l + ((r - l) >> 1);\nmid = l + ((r - l + 1) >> 1);\n```\n\n### 补充2——查找失败\n若要找第一个不小于target的元素， 但数组中所有元素都小于target?\n此时`l`会不断向右移动， 直到移到到`r`的位置。\n所以查找结束后， 可以在对结果进行一次判断， 如果不满足就返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return nums[l] <= target ? l : -1;\n}\n```\n## 二分查找的应用\n\n二分查找最常见的应用就是在数组中查找某个值的左边界或右边界， 但还有一种的用法是浮点数二分， 必如求一个浮点数的n次方根。\n\n> 给定一个浮点数 nn，求它的三次方根。\n>\n> #### 输入格式\n>\n> 共一行，包含一个浮点数 nn。\n>\n> #### 输出格式\n>\n> 共一行，包含一个浮点数，表示问题的解。\n>\n> 注意，结果保留 66 位小数。\n>\n> #### 数据范围\n>\n> −10000≤n≤10000−10000≤n≤10000\n>\n> #### 输入样例：\n>\n> ```\n> 1000.00\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 10.000000\n> ```\n\n**思路**\n用二分的思想不断更新左右边界， 使左右边界逐渐逼近答案， 当左右边界足够接近答案时（达到精度要求）， 即认为左/右边界就是答案。\n**参考代码**\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    double n; cin >> n;\n    double l = -100, r = 100;\n    while((r - l) > 1e-8) {\n        double mid = (l + r) / 2;\n        if(mid * mid * mid > n) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n    printf(\"%.6lf\\n\", l);\n    return 0;\n}\n```\n\n## 参考\n\n[二分 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/binary/)\n\n[二分查找算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/二分搜尋演算法)\n\n[二分查找、二分边界查找算法的模板代码总结 - SegmentFault 思否](https://segmentfault.com/a/1190000016825704)\n\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"字符串哈希","url":"/posts/52567/","content":"\n# 理论基础\n\n字符串哈希， 即把一个字符串映射为一个整数， 这个整数称之为`hash code`。在理想状态下， 只有两个字符串完全相等， hash code才会相等。 因此可以用两个字符串的`hash code`来判断字符串是否相等。\n\n将字符串转化为整数的函数也叫做哈希函数。\n\n# 字符串前缀哈希\n\n字符串前缀哈希是前缀思想在哈希中的应用， 一般用来解决**多次查询子串哈希**的问题。\n\n> 单次计算一个字符串的哈希值复杂度是 `O(n)`，其中n为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。\n\n<!--more-->\n\n因此可以使用特别的哈希函数， 使用字符串前缀的哈希值而推出任一连续子串的哈希值。\n\n## 哈希函数及公式\n\n设字符串S， S中元素下标从1开始， S下标为i的元素为S[i].\n\n哈希函数：\n$$\nhashCode = \\sum_{i = 1}^nS[i] * p^{n - i}\n$$\n如字符串`\"abc\"`， 表达式为\n$$\na * p ^ 2  + b * p + c\n$$\n利用此公式， 我们可以求出S的所有前缀的哈希值\n\n但显然不可能对所有前缀都应用上述公式。事实上pref[i] 可以由pref[i-1]递推得到\n\n仍然以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n可以发现\n\n```F#\npref[i] = pref[i-1] * p + S[i]\n```\n\n## 区间哈希\n\n我们得到了一个字符串所有长度前缀的哈希值， 那么如何利用它来得到某个区间[l, r]的哈希值呢？\n\n以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n假设我们要求[2, 3]区间， 即`\"bc\"`的哈希， 按上述哈希函数应该是`b*p + c`\n\n类比前缀和`sum[l, r] = pref[r] - pref[l-1]`, 可以发现\n$$\nb * p + c = pref[3] - pref[1] * p ^ 2\n$$\n事实上， 存在以下通式\n$$\nhashCode[l, r] = pref[r] - pref[l - 1] * p^{r - l + 1}\n$$\n证明并不难， 若有兴趣自行研究， 就不在此赘述了。\n\n其中`r - l + 1`很明显的， 可以记忆为区间的长度。\n\n因此通过预处理字符串所有前缀的哈希， 我们可以以O(1)的时间代价求出任一子串的哈希值。\n\n## 代码实现(C++)\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N]; // hh[i] 表示长度为i的前缀子串的哈希\null p[N];// p[i]表示P的i次幂, 避免使用幂函数多次求幂\n\n// 初始化前缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n```\n\n**小科普： unsigned long long**\n\n\n\null(unsigned long long)表示64位无符号正整数， 之所以使用ull是因为ull溢出后， 不会像有符号整数如int那样变成负数， 而是会从0重新开始， 即等同于对$2 ^ {64}$自动取余。\n\n在上述哈希函数中， P选取为131(此质数在先人的实验中表现最好， 不容易发生冲突)， 而hashCode更是以幂级增长的， 因此很容易就溢出， 需要对其进行取模。\n\n# 算法应用\n\n## 判断子串是否相等\n\n要判断两个子串是否相等， 只需比较哈希值是否相等即可。预处理前缀哈希， 即可以O(1)的时间代价得到子串的哈希。\n\n### 例题\n\n**AcWing 841**\n\n> 给定一个长度为 *n* 的字符串，再给定 *m* 个询问，每个询问包含四个整数 `l1, r1, l2, r2`，请你判断 \\[l1,r1] 和 \\[l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n>\n> 字符串中只包含大小写英文字母和数字。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n 和 m，表示字符串长度和询问次数。\n>\n> 第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。\n>\n> 接下来 m 行，每行包含四个整数 `l1, r1, l2, r2`，表示一次询问所涉及的两个区间。\n>\n> 注意，字符串的位置从 1 开始编号。\n>\n> #### 输出格式\n>\n> 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。\n>\n> 每个结果占一行。\n>\n> #### 数据范围\n>\n> 1≤n,m≤$10^5$\n>\n> #### 输入样例：\n>\n> ```\n> 8 3\n> aabbaabb\n> 1 3 5 7\n> 1 3 6 8\n> 1 2 1 2\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> Yes\n> No\n> Yes\n> ```\n\n套上上面的板子即可\n\n**时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\n\nconst int N = 1e5 + 10;\nconst ull P = 131;\null hh[N], p[N];\nstring s;\nint n;\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> s;\n    s.insert(0, \"0\");\n    InitHash();\n    while(m --) {\n        int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;\n        cout << (get(l1, r1) == get(l2, r2) ? \"Yes\" : \"No\") << endl;\n    }\n}\n```\n\n\n\n## 判断子串是否是回文\n\n回文即源串与反转后的字符串是相同的。\n\n用字符串哈希的角度来解决就是判断一个字符串及其逆转后的字符串哈希值是否相等。\n\n因此我们可以预处理主串的正向哈希以及逆向哈希， 再判断某子串的正向哈希和逆向哈希是否相等来判断是否是回文。\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N], r_hh[N];//前缀、后缀哈希\null p[N];\n\n// 初始化前缀/后缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n```\n\n### 例题 **google kickstart Round E P3**\n\n> 给定一个长度为 N 的回文字符串 P，它仅由小写英文字母构成。\n>\n> 请你找到最短的**非空回文**字符串 Q，使得 P 与 Q 拼接而成的字符串 Q 也是一个回文串。\n>\n> #### 输入格式\n>\n> \n>\n> 第一行包含整数 T，表示共有 T 组测试数据。\n>\n> 每组数据第一行包含一个整数 N。\n>\n> 第二行包含一个长度为 N 的回文字符串 PP。\n>\n> #### 输出格式\n>\n> \n>\n> 每组数据输出一个结果，每个结果占一行。\n>\n> 结果表示为 `Case #x: y`，其中 xx 为组别编号（从 11 开始），y 为满足条件的最短**非空回文**字符串 Q。\n>\n> #### 数据范围\n>\n> \n>\n> 1≤T≤100\n> 1≤N≤10^5^，\n> 保证 P 是一个由小写字母构成的回文字符串。\n>\n> \n>\n> #### 输入样例：\n>\n> ```F#\n> 3\n> 4\n> abba\n> 4\n> cccc\n> 6\n> cdccdc\n> ```\n>\n> #### 输出样例：\n>\n> ```F#\n> Case #1: abba\n> Case #2: c\n> Case #3: cdc\n> ```\n>\n> #### 样例解释\n>\n> \n>\n> 在 Case 1 中，满足条件的最短回文串 Q 为 `abba`，此时串联字符串 Q 为 `abbaabba`，这是一个回文串。\n>\n> 在 Case 2 中，满足条件的最短回文串 Q 为 `c`，此时串联字符串 PQ为 `ccccc`，这是一个回文串。\n>\n> 在 Case 3 中，满足条件的最短回文串 Q 为 `cdc`，此时串联字符串 PQ 为 `cdccdccdc`，这是一个回文串。\n\n**题意分析**\n\n给定回文字符串P, 求一回文字符串Q， 使在P末尾拼接Q后， PQ仍为回文字符串。\n\n不难分析得到， 由于PQ是回文字符串， 则P中长度等于Q的前缀应该与Q成倒序关系， 设这个前缀为P1, P中除去P1的后半部分为P2。又因为Q为回文字符串， 所以P1会等于Q， P1为回文字符串。而P2显然也要是回文字符串， 这样才能满足PQ为回文字符串。\n\n**因此， 将问题剥析出来就是：求最小的整数mid（1~n）, 使得P[1, mid]和P[mid+1, n]均为回文字符串。**\n\n**参考代码， 时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long \nstring s;\nint n; \nconst ull P = 131;\nconst int N = 1e5 + 10;\null hh[N], r_hh[N];\null p[N];\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n//获取正哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\n//获取反哈希\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\n//判断回文\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n\nint main() {\n    int T; cin >> T;\n    for(int t=1; t<=T; t++) {\n        cout << \"Case #\" << t << \": \"; \n        cin >> n >> s;\n        s.insert(0, \"0\");//调整下标\n        InitHash();\n        for(int i=1; i<=n; i++) {//枚举mid\n            if(is_palindrome(1, i) && is_palindrome(i+1, n)) {\n                cout << s.substr(1, i) << endl;\n                break;\n            }\n        }\n    }\n}\n```\n\n# 模板类\n\n将相关代码封装为类， 需要时cv即可。\n\n使用时注意：\n\n* 直接传入原字符串\n* 获取子串哈希时， 下标从0开始。\n\n```c++\nclass HashString {\nprivate:\n    typedef unsigned long long ull;\n    const int P = 131;\n    vector<ull> p;\n    vector<ull> prefix;\n    int n;\npublic:\n    HashString(string s) {\n        n = s.size();\n        s.insert(0, \"0\");\n        p.resize(n + 1), p[0] = 1;\n        prefix.resize(n + 1, 0);\n        for(int i=1; i<=n; i++) {\n            p[i] = p[i-1] * P;\n            prefix[i] = prefix[i - 1] * P + s[i];\n        }\n    }\n\n    ull get(int l, int r) {\n        l++, r++;\n        return prefix[r] - prefix[l - 1] * p[r - l + 1];\n    }\n};\n```\n\n\n\n# 参考\n\n[字符串哈希 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/hash/)\n\n[【算法学习笔记】7：字符串前缀哈希法_LauZyHou的博客-CSDN博客](https://blog.csdn.net/SHU15121856/article/details/109553503)\n\n[AcWing 841. 字符串哈希 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/2691/)","tags":["博客"],"categories":["一文搞定系列"]},{"title":"一文搞定c++自定义排序","url":"/posts/45215/","content":"\n# 前言\n\nc++拥有强大的STL， 在对复杂的数据结构排序时只需要自定义去比较函数， 然后放到容器内调用api即可。\n\n本该是很简单的东西， 但我之前一直无法记住升序以及降序两种方向该分别怎么写，总是会搞混，  每次都得现场Google。终于下定决心要在今天把它彻底搞定。\n\n# 自定义排序的三种比较器形式\n\n\n\n## 比较函数\n\nSTL中的`sort`函数已经为我们提供了排序算法的框架，我们唯一要做的决定就是对于两个元素`a`和`b`， 谁在前、谁在后？\n\n<!--more-->\n\n\n\n> sort函数的一个原型\n\n```c++\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last);//无比较器， 升序排序， 会调用<进行元素比较, 小的会放前面\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);//传入比较器， 前后顺序由比较强返回值决定\n```\n\n在`sort`函数中这即为第三个参数：比较器\n\n**比较函数的基本形式**:\n\n```\nbool comp(const type& a, const type& b);\n```\n\n一般而言形参的形式为`const`、引用类型（当然不写也可以， 只是这样更安全、效率更高）。\n\n而返回值于a、b的前后关系是**返回true时， a在前面; 返回false时, b在前面.**\n\n如\n\n```c++\nbool comp(const int &a, const int &b) {\n    return a < b;\n}\n```\n\n返回值为`true`时， a在前面， 且`a<b`， 所以会是升序排序。\n\n所以更透彻的讲， 比较函数的内容其实是**a要想排在b前面所要满足的条件**\n\n**简单小例子**\n\n若用pair<string, int> 存储着若干个学生的`name`和`score`信息， 要对这些学生进行排序， \n\n要求：\n\n* 按分数从高到低\n* 分数相等时按名字字典序排列\n\n很容易的可以得到比较函数为\n\n```c++\nbool cmp(const pair<string, int> &a, const pair<string, int> &b) {\n\tif(a.second != b.second) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n```\n\n**lambda表达式**\n\n比较函数在大多场景下可能仅需使用一次， 因此我们可以用lambda表示式来简写\n\n如\n\n```c++\nsort(data.begin(), data.end(), [](const type& a, const type& b) -> bool {\n        //judge something\n    });\n```\n\n\n\n## 重载<运算符\n\n有时候我们会用结构体或类来定义较为复杂的数据结构， 要对它进行自定义排序除了使用比较函数外， 还可以用重载运算符的方式。\n\n以上面的学生例子举例\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu& b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n```\n\n上述代码重载了stu类的`<`运算符，和比较函数不同的时只有一个参数， 但其实只不过是a参数变成了当前的结构体 。\n\n由于`sort`函数默认为升序, 会把用`<`比较的两个函数中小的放前面， 所以函数体编写思想和比较函数完全一致：写入要把a放到前面满足的条件。\n\n\n\n## 函数对象比较器——重载()\n\n其实就是定义一个结构体或类作为比较器， 重载`()`, 这样类名+`()`就成为了比较函数。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n};\n\nstruct cmp {\n    bool operator() (const stu& a, const stu& b) {\n        if(a.score != b.score) {\n            return a.score > b.score;\n        }\n        return a.name < b.name;\n    }\n};\n\nint main() {\n    vector<stu> a{{\"abc\", 100}, {\"acb\", 100}};\n    sort(a.begin(), a.end(), cmp());\n    for(const auto& i : a) {\n        cout << i.name << \" \" << i.score << endl;\n    }\n}\n```\n\n# 容器应用\n\nSTL用两种比较对象来指代排序的两种方向， 分别是`less`和`greater`分别使用`<`和`>`， 对应升序和降序。在众容器中都默认使用less， 所以结构体要使用默认排序需要重载小于运算符。\n\n也可以显示指出方向， 如以下代码对数组进行了降序排序。\n\n```c++\nint main() {\n    vector<int> a{3, 8, 3, 2, 4};\n    sort(a.begin(), a.end(), greater<>());//重载了< / >运算符， 即可使用less<> / greater<>\n}\n```\n\n要注意的是在set， priority_queue这样的容器不能用比较函数的方式， 只能够使用重载的方式实现。\n\n---\n\n以及比较反人类的是当`priority_queue`使用`less`时其实是大根堆， 使用`greater<>`才是小根堆。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu & b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n\nint main() {\n    priority_queue<stu, vector<stu>> heap;\n    heap.push({\"a\", 100});\n    heap.push({\"b\", 100});\n    heap.push({\"c\", 110});\n    while(!heap.empty()) {\n        cout << heap.top().name << \" \" << heap.top().score << endl;\n        heap.pop();\n    }\n}\n\n//输出结果\n/*\nb 100\na 100\nc 110\n\n*/\n```\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"有点学问在的缩进风格","url":"/posts/57442/","content":"\n### 什么是缩进风格\n\n缩进风格是代码风格的一部分， 是自发形成的一种约定， 用控制代码块缩进的方式传达程序的结构。\n\n缩进风格可以分为两个方面：`缩进大小`和`大括号位置`。\n\n### 缩进大小\n\n缩进在大部分语言中并不是强制要求， 但合理的缩进有利于人类理解程序的结构， 即提高了代码的清晰性。\n\n> 1983年在PASCAL代码上进行的一项实验发现，缩进大小显着影响了可理解性。2 到 4 个字符之间的缩进大小被证明是最佳的。\n\n在大部分的程序语言中， 默认使用四个空格或一个tab键（制表符可以与空格互相转换， 一个'\\t'等于4个空格）\n\n<!--more-->\n\n在部分的脚本语言或HTML中， 可能会使用2个空格， 以避免过长的缩进。\n\n下文中介绍的风格默认使用4字符缩进。\n\n### 大括号位置\n\n大括号用于声明程序的控制语句的作用域， 跟在`(····)`后面。\n\n下面将介绍几种主流的大括号风格。\n\n#### Allman风格\n\n由一位大牛的名字命名， 又叫做`BSD`风格。\n\n该风格的特点是大括号放到控制语句的下一行， 且与控制语句的缩进相同。\n\n```c\nint main()\n{\n\twhile(cond)\n\t{\n\t\tif(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse if(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//do something\n\t\t}\n\t}\n}\n```\n\n可以发现代码块中的代码与控制语句形成明显的区分， 左右大括号位于同一列， 一般而言对人来说更容易匹配到对应的带括号。\n\nallman风格由于其清晰的代码结构， 常被用于教育。但它的缺点是，当代码块较短时（特别是只有一句），  过多的空行会导致程序很长， 容易让人产生阅读压力以及抓不住焦点。\n\n#### K&R风格\n\n不知道你是否听说过被誉为 `“C语言圣经“`的《C程序设计语言》(*`The C programming language`*)， 这本书由两位大牛Kernighan & Ritchie （K&R）编写， 其中Ritchie正是C语言的创造者。\n\nK&R风格便是在这本书中使用的缩进风格， 同时K&R风格及其变体也是目前使用最广泛的风格。\n\nK&R风格的特点：\n\n* 函数的大括号位于单独一行\n* 控制语句的左大括号不换行， else或else if不换行\n* 只有一条语句的代码块不使用大括号, 而是换行后缩进\n\n```c\nint main()\n{\n\twhile (cond) {\n\t\tif (cond) \n\t\t\tputs(\"K&R \");\n\t\telse (cond)\n\t\t\tputs(\"is best style!\")\n\t\t\n\t\tif (cond) {// )与{中间有空格， 这属于其他部分的代码风格\n\t\t\t//do something\n\t\t} else if (cond) {\n\t\t\t//do something\n\t\t} else {\n\t\t\t//do something\n\t\t}\n\t}\n\t\n}\n```\n\n差不多也能体会到， K&R风格总结起来就是：尽可能的压缩代码。 有人分析这是因为这些代码是要打印到书籍上的， 为了降低成本而尽可能的减少代码行数， 因此也有人称之为印刷风格。\n\nK&R的缺点十分明显：左大括号不好找， 尤其在代码块较长时， 很容易找错左大括号。 就可读性而言确实是比不上Allman的， 但在现代IDE智能的高亮和匹配功能下， 也还行？\n\n#### K&R变体 - 1TBS\n\n”一个真正的大括号风格“（One True Brace Style）， 是K&R的变体之一， 主要区别是：1TBS强制使用大括号， 也就是说即使只有一行也需要用大括号而不能省略。\n\n1TBS存在的真实性存有疑问， 有些人认为它是如上所述的K&R变体， 有些人指出它不过是K&R的”行话“。\n\n#### Whitesmiths风格\n\n特点是大括号需要换行， 且需要缩进\n\n```c\nif (cond)\n\t{\n\tputs(\"This is the whitesmiths style\");\n\t}\nelse if (cond)\n\t{\n\tputs(\"like it?\");\n\t}\n```\n\n#### 圣战\n\nAllman风格(左括号换行， 位于左边)和K&R风格(左括号不换行， 位于右边)是两种最广泛使用的大括号风格， 无数程序员争论到底哪种才是最好的。\n\n在舆论上Allman总是占优， K&R被称为\"过时\"/\"伤害眼睛”。但K&R在早期大牛的影响下（如java API源码, linux源码， golang语法风格等等)的影响下， 在除C外的领域仍然是最主流的风格。\n\n### 总结\n\n永远不存在所谓正确的缩进风格， 最重要的事情是在整个程序中都保持一致的代码风格。\n\n---\n\n### 参考\n\n[缩进样式 - 维基百科)](https://en.wikipedia.org/wiki/Indentation_style#cite_note-catb.org-7)\n\n[缩进样式 (catb.org)](http://catb.org/jargon/html/I/indent-style.html)\n\n[indentation style - Slant](https://www.slant.co/topics/2478/~best-indentation-style-in-c)\n","tags":["博客"],"categories":["杂谈"]},{"title":"认识一下吧","url":"/posts/36271/","content":"\n**Hi, 你好,  欢迎来到trudbot的私人网站。这里暂时内容很少， 但它会慢慢丰富**\n\n### 这是什么网站？\n\n这是我的个人博客网站， 使用开源框架`Hexo`， 托管于`github`上;  推荐桌面浏览器打开。\n\n### 这里会有什么内容？\n\n* 技术学习之路中记录笔记或经验分享\n* 有意思的算法题题目及题解分享\n\n","tags":["博客","导读"]}]