[{"url":"/posts/0/","content":"你周六的那些话我看了很多遍， 你说的确实是对的， 之前我一直关注更多的好像只是自己能不能从你身上得到想要的反馈， 以及这种反馈是不是减弱或者消失了。 这样看来我之前更多的还是把关注点放在自己身上， 而且非常敏感， 一旦得不到， 就像一个小孩子一样闹情绪， 大哭大闹。\n\n所以我之前做的很差劲， 但是我不是不关心你， 你跟我发的每一条消息， 和我说的每一句话我都很留意， 但我没有那种意识， 就是我应该去主动地去关心、去了解你， 去关心你有哪些烦恼、问题， 然后和你一起解决。但真的， 我不是不愿意去做， 真的很乐意，如果你主动找我述说， 我很乐意去满足你的需求， 我也会很开心你需要我， 会找我说你的事情。只是我从来都没有主动对别人这样做过， 我不知道怎么开始。就像我之前向你表白， 如果不是事先和你交流了， 差不多能预知到会有什么样的结果， 我可能都不敢去做， 因为我不能确定结果， 怕结果不好。 对你来说这样可能就很没有意思， 但对我来说就比较有安全感， 我才能放手去做。 所以很多事情我没有做过， 我的心态导致我迈出第一步就很难。\n\n所以我觉得就是我一直以来习惯的行为模式， 导致我没有去注意你的需求， 满足不了你的需求， 导致了我们有这么多的矛盾。我之前说你对爱情的需求感太低了， 但我想了几天后， 觉得需求感太低的反而是我， 我对亲密关系真的不敢有太多奢望， 能平时和你聊天、沟通， 常常和你见面出去玩， 我觉得很满足了， 导致我以为然的认为你也满足了， 没有去注意你的需求， 没有去考虑你的感受。\n\n但真的， 并不是因为什么我不够喜欢你， 不在乎你。 我知道我现实里看起来很冷漠， 什么都不关心， 但这只是我的"},{"title":"第十四届蓝桥杯C/C++B组省赛","url":"/posts/6078/","content":"\n# 2023蓝桥C/C++B组省赛\n\n## 试题A: 日期统计\n\n### 题目描述\n\n【问题描述】\n小蓝现在有一个长度为100 的数组，数组中的每个元素的值都在0 到9 的范围之内。数组中的元素从左至右如下所示：\n\n\n```\n5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3\n```\n\n现在他想要从这个数组中寻找一些满足以下条件的子序列：\n\n<!--more-->\n\n1. 子序列的长度为8；\n\n2. 这个子序列可以按照下标顺序组成一个yyyymmdd 格式的日期，并且\n   要求这个日期是2023 年中的某一天的日期，例如20230902，20231223。yyyy 表示年份，mm 表示月份，dd 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。\n\n请你帮小蓝计算下按上述条件一共能找到多少个不同的2023 年的日期。\n对于相同的日期你只需要统计一次即可。\n\n### 枚举\n\n用八重循环直接枚举每一位数字， 题目中的日期序列有很多限制， 如前四位必须是2023， 又比如月份只能以0或1开头等等。利用这些限制能大大降低运行时间， 实测只要限制了前四位， 基本是瞬间跑出结果。\n\n注意需要用哈希表去重。\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nint days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nset<int> res;\n\nvoid check(int m, int d) {\n    if (m < 1 || m > 12 || d < 1 || d > days[m]) return;\n    res.insert(m * 100 + d);\n}\n\nint main () {\n    int ns[100];\n    for (int & n : ns) cin >> n;\n    for (int a = 0; a < 100; a ++) {\n        if (ns[a] != 2) continue;\n        for (int b = a + 1; b < 100; b ++) {\n            if (ns[b] != 0) continue;\n            for (int c = b + 1; c < 100; c ++) {\n                if (ns[c] != 2) continue;\n                for (int d = c + 1; d < 100; d ++) {\n                    if (ns[d] != 3) continue;\n\n                    for (int i = d + 1; i < 100; i ++)\n                        for (int j = i + 1; j < 100; j ++)\n                            for (int k = j + 1; k < 100; k ++)\n                                for (int l = k + 1; l < 100; l ++)\n                                    check(ns[i] * 10 + ns[j], ns[k] * 10 + ns[l]);\n                }\n            }\n        }\n    }\n    cout << res.size() << endl;\n    return 0;\n}\n//in: 5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2\n//7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1\n//0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3\n//out: 235\n```\n\n## 试题B: 01 串的熵\n\n### 题目描述\n\n对于一个长度为n 的01 串$S = x_1x_2x_3...x_n$，香农信息熵的定义为$H(S ) =\n−\\sum^n_1p(x_i) \\log_2(p(x_i))$，其中$p(0),p(1)$ 表示在这个01 串中0 和1 出现的占比。\n\n比如，对于S = `100` 来说，信息熵$H(S ) = −\\frac13 \\log_2( \\frac13 ) − \\frac23 \\log_2( \\frac23 ) − \\frac23 \\log_2( \\frac23 )=1.3083$。对于一个长度为`23333333` 的01 串，如果其信息熵为`11625907.5798`，且0 出现次数比1 少，那么这个01 串中0 出现了多少次？\n\n### 枚举|模拟\n\n设01字符串`S`长度为`n`,  0的个数为`x`。\n\n则$p(0) = \\frac xn, p(1) = \\frac{n-x}{n}$.\n\n$H(S ) =−\\sum^n_1p(x_i) \\log_2(p(x_i)) = -(xp(0)\\log_2(p(0)) + (n-x)p(1)\\log_2(p(1)))$\n\n在已知n, x时， 计算H是$O(1)$的， 所以只需要枚举x即可。\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll H = 116259075798;\nconst ll N = 23333333;\n\nbool check(ll x) {\n    double p0 = x * 1.0 / N, p1 = 1 - p0;\n    ll h = 10000ll * (x * p0 * log2(p0) + (N - x) * p1 * log2(p1));\n    return h + H == 0;\n}\n\nint main () {\n    for (int x = 1; x <= N / 2; x ++) {\n        if (check(x)) cout << x << endl;\n    }\n    return 0;\n}\n//out: 11027421\n```\n\n## 试题C: 冶炼金属\n\n### 题意描述\n\n小蓝有一个神奇的炉子用于将普通金属O 冶炼成为一种特殊金属X。这个炉子有一个称作转换率的属性V，V 是一个正整数，这意味着消耗V 个普通金属O 恰好可以冶炼出一个特殊金属X，当普通金属O 的数目不足V 时，无法继续冶炼。\n\n现在给出了N 条冶炼记录，每条记录中包含两个整数A 和B，这表示本次投入了A 个普通金属O，最终冶炼出了B 个特殊金属X。每条记录都是独立的，这意味着上一次没消耗完的普通金属O 不会累加到下一次的冶炼当中。\n根据这N 条冶炼记录，请你推测出转换率V 的最小值和最大值分别可能是多少，题目保证评测数据不存在无解的情况。\n\n### 取交集\n\n对于每一条记录， 都可以求出转换率V的一个取值范围。 V必须满足所有记录求出的取值范围， 所以只需要对N个区间求交集即可, 也就是右边界取所有右边界的最小值， 左边界取所有左边界的最大值。。\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    int n; cin >> n;\n    int mn = -1, mx = 1e9;\n    while (n --) {\n        int a, b; cin >> a >> b;\n        int l = a / (b + 1) + 1, r = a / b;\n        mn = max(mn, l), mx = min(mx, r);\n    }\n    cout << mn << \" \" << mx << endl;\n    return 0;\n}\n```\n\n## 试题D: 飞机降落\n\n### 题意描述\n\nN 架飞机准备降落到某个只有一条跑道的机场。其中第`i` 架飞机在$T_i$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋$D_i$ 个单位时间，即它最早可以于$T_i$ 时刻开始降落，最晚可以于$T_i + D_i$ 时刻开始降落。降落过程需要$L_i$\n个单位时间。\n\n一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。\n\n请你判断N 架飞机是否可以全部安全降落。\n\n### DFS+剪枝， 懒得写\n\n## 试题E: 接龙数列\n\n### 题意描述\n\n对于一个长度为K 的整数数列：$A_1,A_2..A_K$，我们称之为接龙数列当且仅当$A_i$ 的首位数字恰好等于$A_{i−1}$ 的末位数字(2 ≤ i ≤ K)。\n\n例如$12,23,35,56,61,11$ 是接龙数列；$12,23,34,56$ 不是接龙数列，因为56的首位数字不等于34 的末位数字。所有长度为1 的整数数列都是接龙数列。\n\n现在给定一个长度为N 的数列$A_1,A_2... A_N$，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？\n\n### DP\n\n要求使得数列变成接龙数列的最少删除个数， 相当于求该数列的最长接龙子数列的长度， 用总长度减去最长接龙长度即为最少删除个数。\n\n定义$dp[i][j]$为前`i`个数中， 以数字`j`结尾的最长接龙数列的长度。\n\n设第`i`个数的首位数字是a， 末位数字是b。 则$dp[i]$中相对于$dp[i-1]$可能发生变化的只有$dp[i][b]$, 因为第i个数可能加到一个以a结尾的接龙数列中， 使得这个接龙数列长度加1并且结尾数字变成`b`.\n\n所以状态转移方程为`dp[i][b] = max(dp[i - 1][b], dp[i - 1][a] + 1)`\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nint dp[10];\n\nint main () {\n    int n, mx = 0; cin >> n;\n    for (int i = 0; i < n; i ++) {\n        string s; cin >> s;\n        int a = s[0] - '0', b = s.back() - '0';\n        dp[b] = max(dp[b], dp[a] + 1), mx = max(mx, dp[b]);\n    }\n    cout << n - mx << endl;\n    return 0;\n}\n```\n\n## 试题F: 岛屿个数\n\n### 题意描述\n\n小蓝得到了一副大小为M × N 的格子地图，可以将其视作一个只包含字符‘0’（代表海水）和‘1’（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的‘1’ 相连接而形成。\n\n在岛屿A 所占据的格子中，如果可以从中选出k 个不同的格子，使得他们的坐标能够组成一个这样的排列：($x_0, y_0$),($x_1,y_1$)... ($x_{k−1}, y_{k−1}$)，其中($x_{(i+1)}\\%k,y_{(i+1)}\\%k$) 是由($x_i, y_i$) 通过上/下/左/右移动一次得来的(0 ≤ i ≤ k − 1)，此时这k 个格子就构成了一个“环”。如果另一个岛屿B 所占据的格子全部位于这个“环” 内部，此时我们将岛屿B 视作是岛屿A 的子岛屿。若B 是A 的子岛屿，C 又是B 的子岛屿，那C 也是A 的子岛屿。\n\n请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。\n\n### dfs | 连通块\n\n本题有两种类型的顶点, 一种是'海水', 如果A海顶点在B海顶点的周围8个格子内, 那两个海顶点就算连通的.\n\n另一个是'陆地', 只有A在B的上下左右四个方格内, 两个陆地才是连通的.\n\n地图外的方格我们全部视为海， 与地图外的海连通的海都视为外海， 可以发现， 接触到了外海的岛屿， 就一定不是其它岛屿的子岛。\n\n所以在地图周围一圈， 我们增加一圈0作为外海， dfs遍历外海每一个方格， 若与外海方格相邻的岛屿未被遍历过，那么这就是一个新的岛屿， 再用一个dfs去遍历这个岛。\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nint g[N][N], n, m, res = 0;\nbool st[N][N];\nint dx[] = {0, 0, 1, -1},\n    dy[] = {1, -1, 0, 0};\n\nvoid dfs_1(int r, int c) {\n    st[r][c] = true;\n  \t//四向连通\n    for (int i = 0; i < 4; i ++) {\n        int x = dx[i] + r, y = dy[i] + c;\n        if (st[x][y] || g[x][y] == 0) continue;\n        dfs_1(x, y);\n    }\n}\n\nvoid dfs_0(int r, int c) {\n    st[r][c] = true;\n    //八向连通\n    for (int i = -1; i <= 1; i ++)\n        for (int j = -1; j <= 1; j ++) {\n            int x = r + i, y = c + j;\n            if (x < 0 || x > n + 1 || y < 0 || y > m + 1 || st[x][y]) continue;\n            if (g[x][y] == 0) dfs_0(x, y);\n            else dfs_1(x, y), res ++;\n        }\n}\n\nint main () {\n    int T; cin >> T;\n    while (T --) {\n        memset(g, 0, sizeof g);\n        memset(st, false, sizeof st);\n        cin >> n >> m; res = 0;\n        for (int i = 1; i <= n; i ++)\n            for (int j = 1; j <= m; j ++) {\n                char c; cin >> c;\n                g[i][j] = c - '0';\n            }\n        dfs_0(0, 0);//从一个外海方格开始dfs\n        cout << res << endl;\n    }\n    return 0;\n}\n```\n\n\n\n## 试题G: 子串简写\n\n### 题意描述\n\n程序猿圈子里正在流行一种很新的简写方法：对于一个字符串，只保留首尾字符，将首尾字符之间的所有字符用这部分的长度代替。例如**internationalization**简写成**i18n**，**Kubernetes** （注意连字符不是字符串的一部分）简\n写成**K8s**, **Lanqiao** 简写成**L5o** 等。在本题中，我们规定长度大于等于K 的字符串都可以采用这种简写方法（长度小于K 的字符串不配使用这种简写）。\n\n给定一个字符串`S` 和两个字符$c_1$ 和$c_2$，请你计算S 有多少个以$c_1$ 开头$c_2$ 结尾的子串可以采用这种简写？\n\n### 前缀和\n\n设`p[i]`为前i个字符中$c_1$字符的个数, 则对于下标为`j`的$c_2$字符, 以其结尾且可以简写的子串数量即为`p[j - k + 1]`\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 5e5 + 10;\nll p[N], res;\n\nint main () {\n    int k; cin >> k;\n    string s; char a, b; cin >> s >> a >> b;\n    for (int i = 1; i <= s.size(); i ++) p[i] = p[i - 1] + (s[i - 1] == a);\n    for (int i = k; i <= s.size(); i ++)\n        if (s[i - 1] == b) res += p[i - k + 1];\n    cout << res << endl;\n    return 0;\n}\n```\n\n## 试题H: 整数删除\n\n### 题意描述\n\n给定一个长度为N 的整数数列：$A_1,A_2...A_N$。\n\n你要重复以下操作K 次：每次选择数列中最小的整数（如果最小值不止一个，选择最靠前的），将其删除。并把与它相邻的整数加上被删除的数值。\n\n输出K 次操作后的序列。\n\n### 双向链表 | 最小堆\n\n由于要进行大量的删除操作, 不难想到可以使用链表.\n\n而本题需要动态的求最小值, 显然可以使用堆.\n\n每次从堆中取出最小值的下标, 然后在链表中删除它.\n\n但本题特殊点在于`将其删除。并把与它相邻的整数加上被删除的数值`, 所以会导致还在堆中的元素的权的变化.\n\n我们可以注意到, 每次删除操作只会让一些元素变大, 而不会让元素变小. 也就是, 可能会让原本的最小值变成不是最小值.\n\n因此我们取出堆中的最小值时, 需要将此元素的排序权和实际的值进行对比, 如果实际的值变大了, 则当前元素并不一定是最小值, 需要重新放回堆中.\n\n### 参考代码\n\n每次删除操作最多会让两个元素的值变化, 因此从堆中取出的次数是k的线性, 时间复杂度为$O(n + k) \\log n$\n\n```cpp\n//\n// Created by trudbot on 2023/4/9.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 5e5 + 10;\nll v[N], l[N], r[N];\n\nvoid del(int x) {\n    r[l[x]] = r[x], l[r[x]] = l[x];\n    v[l[x]] += v[x], v[r[x]] += v[x];\n}\n\nint main () {\n    int n, k; cin >> n >> k;\n    r[0] = 1, l[n + 1] = n;\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> h;\n    for (int i = 1; i <= n; i ++)\n        cin >> v[i], l[i] = i - 1, r[i] = i + 1, h.push({v[i], i});\n    while (k --) {\n        auto p = h.top(); h.pop();\n        if (p.first != v[p.second]) h.push({v[p.second], p.second}), k ++;\n        else del(p.second);\n    }\n    int head = r[0];\n    while (head != n + 1) {\n        cout << v[head]<< \" \";\n        head = r[head];\n    }\n    return 0;\n}\n```\n\n## 试题I: 景区导游\n\n### 题意描述\n\n某景区一共有N 个景点，编号1 到N。景点之间共有N − 1 条双向的摆渡车线路相连，形成一棵树状结构。在景点之间往返只能通过这些摆渡车进行，需要花费一定的时间。\n\n小明是这个景区的资深导游，他每天都要按固定顺序带客人游览其中K 个景点：A1; A2; : : : ; AK。今天由于时间原因，小明决定跳过其中一个景点，只带游客按顺序游览其中K − 1 个景点。具体来说，如果小明选择跳过Ai，那么他会按顺序带游客游览$A_1，A_2... A_{i−1},A_{i+1},A_K$ (1 ≤ i ≤ K)。请你对任意一个Ai，计算如果跳过这个景点，小明需要花费多少时间在景点之间的摆渡车上？\n\n### 带权LCA\n\n要确定的一点是， 由于题中的图是一棵树， 所以对于任意两个顶点， 它们的最短路径就是它们的简单路径。\n\n求树中两个结点的最短路径， 可以想到LCA。\n\n设$dist[u]$为u顶点到根结点的距离， 那么u和v的距离即为$dist[u] + dist[v] - 2 * dist[lca(u, v)]$.\n\n因此本题就是一道LCA的模板题， 使用倍增或者tarjan都是可以的, 具体的算法知识请自行去学习。\n\n距离可能会爆int， 因此建议是所有整型都用long long， 避免麻烦。\n\n### 参考代码\n\n```cpp\n//\n// Created by trudbot on 2023/4/10.\n//\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nusing ll = long long;\nvector<pair<int, int>> g[N];\nll dep[N], f[N][30], dist[N];\n\nvoid dfs(int u, int fa, ll d) {\n    dep[u] = dep[fa] + 1, dist[u] = d, f[u][0] = fa;\n    for (int i = 1; (1 << i) <= dep[u]; i ++) f[u][i] = f[f[u][i - 1]][i - 1];\n    for (auto &p : g[u]) {\n        if (p.first == fa) continue;\n        dfs(p.first, u, d + p.second);\n    }\n}\n\nint lca(int a, int b) {\n    if (dep[a] < dep[b]) swap(a, b);\n    for (int i = 20; i >= 0; i --) {\n        if (dep[f[a][i]] >= dep[b]) a = f[a][i];\n        if (a == b) return a;\n    }\n    for (int i = 20; i >= 0; i --) {\n        if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];\n    }\n    return f[a][0];\n}\n\nll get(int a, int b) {\n    return dist[a] + dist[b] - 2 * dist[lca(a, b)];\n}\n\nint main () {\n    int n, k; cin >> n >> k;\n    for (int i = 1; i < n; i ++) {\n        int u, v, t; cin >> u >> v >> t;\n        g[u].push_back({v, t}), g[v].push_back({u, t});\n    }\n    vector<int> a(k);\n    for (auto &x : a) cin >> x;\n    dfs(1, 0, 0);\n    ll sum = 0;\n    for (int i = 1; i < k; i ++) sum += get(a[i - 1], a[i]);\n    for (int i = 0; i < k; i ++) {\n        ll ans = sum;\n        if (i != 0) ans -= get(a[i], a[i - 1]);\n        if (i != k - 1) ans -= get(a[i], a[i + 1]);\n        if (i != 0 && i != k - 1) ans += get(a[i - 1], a[i + 1]);\n        cout << ans << \" \";\n    }\n    return 0;\n}\n```\n\n## 试题J: 砍树\n\n### 题意描述\n\n给定一棵由n 个结点组成的树以及m 个不重复的无序数对$(a_1,b_1), (a_2,b_2),...,(a_m,b_m)$，其中$a_i$ 互不相同，$b_i$ 互不相同，$a_i \\neq b_j$(1 ≤ i, j ≤ m)。\n小明想知道是否能够选择一条树上的边砍断，使得对于每个$(a_i,b_i)$ 满足$a_i$和$b_i$ 不连通，如果可以则输出应该断掉的边的编号（编号按输入顺序从1 开始），否则输出-1。\n\n### 树上差分\n\n同上题我们知道， 树中两个结点的简单路径是唯一的。\n\n因此如果我们能找到一条边， 每组数对的两个结点的简单路径都要经过这条边， 那么就可以满足题意。\n\n这时我们可以很简单的想到思路， 对于数对$(a, b)$， 我们遍历a到b路径上的每一条边， 让其权值加一。\n\n最后若存在权值为m的边， 那么就满足题意。\n\n但这样做时间复杂度显然最坏是$O(nm)$， 不达标。\n\n这时候我们可以用到树上差分优化这一过程， 同理这里不会赘述它是什么， 请自行去学习[相关知识](https://www.cnblogs.com/TEoS/p/11376676.html)。\n\n### 参考代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, M = 18;\nvector<pair<int, int>> g[N];\nint dep[N], f[N][20], cnt[N], w[N];\n\nvoid init(int u, int fa) {\n  dep[u] = dep[fa] + 1, f[u][0] = fa;\n  for (int i = 1; (1 << i) <= dep[u]; i ++) f[u][i] = f[f[u][i - 1]][i - 1];\n  for (auto &e : g[u]) {\n    if (e.first != fa) init(e.first, u), w[e.first] = e.second;\n  }\n}\n\nint lca(int a, int b) {\n  if (dep[a] < dep[b]) swap(a, b);\n  for (int i = M; i >= 0; i --) {\n    if (dep[f[a][i]] >= dep[b]) a = f[a][i];\n    if (a == b) return a;\n  }\n  for (int i = M; i >= 0; i --) {\n    if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];\n  }\n  return f[a][0];\n}\n\nvoid add(int a, int b) {\n  int LCA = lca(a, b);\n  cnt[a] ++, cnt[b] ++, cnt[LCA] -= 2;\n}\n\nvoid dfs(int u, int fa) {\n  for (auto &e : g[u]) {\n    if (e.first != fa) \n      dfs(e.first, u), cnt[u] += cnt[e.first];\n  }\n}\n\nint main () {\n  int n, m; cin >> n >> m;\n  for (int i = 1; i < n; i ++) {\n    int a, b; cin >> a >> b;\n    g[a].push_back({b, i}), g[b].push_back({a, i});\n  }\n  init(1, 0);\n  for (int i = 0; i < m; i ++) {\n    int a, b; cin >> a >> b;\n    add(a, b);\n  }\n  dfs(1, 0);\n  int res = -1;\n  for (int i = 1; i <= n; i ++) \n    if (cnt[i] == m && (w[i] > res)) res = w[i];\n  cout << res << endl;\n  return 0;\n}\n```\n\n","tags":["蓝桥杯"],"categories":["题解"]},{"title":"倍增LCA","url":"/posts/12115/","content":"\n在[图论](https://zh.wikipedia.org/wiki/图论)和[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**最近公共祖先**（英语：lowest common ancestor）是指在一个[树](https://zh.wikipedia.org/wiki/树_(图论))或者[有向无环图](https://zh.wikipedia.org/wiki/有向无环图)中同时拥有*v*和*w*作为后代的最深的节点。\n\n<!--more-->\n\n## 朴素求LCA\n\n### 思想及参考代码\n\n```mermaid\ngraph TD;\n1((1)) --- 2((2))\n1 --- 3((3))\n3 --- 4((4))\n3 --- 5((5))\n4 --- 6((6))\n```\n\n假如在这样一棵树上， 我们需要找到`6`和`2`的LCA， 如何找到一个普适的流程呢。\n\n1. 初始化得到每一个结点的父结点编号， 以及深度\n2. 将要求的两个结点较深的一个不断上移， 直到两个结点深度相同\n3. 将两个结点同时一步一步地上移， 直到两个结点相遇， 此时所在结点即为LCA\n\n```cpp\nint dep[N], fa[N];\n\nint lca(int a, int b) {\n  if (dep[a] < dep[b]) swap(a, b);\n  while (dep[a] > dep[b]) a = fa[a];\n  while (a != b) a = fa[a], b = fa[b];\n  return a;\n}\n```\n\n### 时间复杂度分析\n\n预处理中， 只需要遍历一遍树， 时间复杂度为$O(n)$\n\n求lca过程中， 考虑树构成一条链的极端情况， 此时时间复杂度为$O(n)$, 在查询次数多时显然是无法让人接受的。\n\n## 倍增求LCA\n\n### 思想\n\n上面朴素做法最大的问题是每次只移动一步， 当要移动的总步数很大时， 效率就很低。\n\n因此， 能不能一次移动多步呢？\n\n```mermaid\ngraph TD;\n1((1)) --- 2((2))\n1 --- 3((3))\n3 --- 4((4))\n3 --- 5((5))\n4 --- 6((6))\n```\n\n我们先来声明一下， 在树中， 每个结点可能有多个祖先， 如6的祖先有`4、3、1`. 我们按顺序称4是6的第一个祖先， 3是6的第二祖先， 以此类推。\n\n众所周知， 任何一个正整数x转化为二进制， 都可以表示为若干唯一的2的不同幂次的和， 如$10 = 2^3 + 2^1, 13 = 2^3 + 2^2 + 2^0$.\n\n假设从结果上看， a要向上移动10次， 我们可以让其移动到它第八个祖先， 再移动到当前结点的第二个祖先， 这样就只移动了两次。\n\n但上述的前提是， 你需要记录每个结点的第$2^x, x=0, 1, 2...$个祖先是谁。\n\n我们定义$f[i][j]$为， `i`号结点的第$2^j$个祖先， 先假设已经求出了这个数组。\n\n同样的， 定义$dep[i]$为`i`号结点的深度。\n\n此时来考虑， 有了这些信息， 我们怎么求出两个结点的lca。\n\n---\n\n上面的暴力算法的第一步是， 将深度较大的结点上移至另一个结点的高度。\n\n我们假设a是深度较深的， b是深度较浅的。\n\n要跳的步数是a-b， 从二进制的角度分析我们可以知道， 最少的跳数， 就是a-b转化为2进制后1的个数， 且每种幂次只需要跳一次。\n\n因此我们从一个上限m($2^m$大于树的最大深度)开始向下枚举， 若a向上跳$2^i$步后， 深度不会小于b， 那就往上跳；最终可以快速的到达与b相同的深度。\n\n再来考虑， 深度相同后， 怎么快速的找到两个结点的最近公共祖先。\n\n此时策略就有所不同了。\n\n```mermaid\ngraph TD;\n1((1)) --- 2((2))\n1 --- 3((3))\n3 --- 4((4))\n3 --- 5((5))\n4 --- 6((6))\n```\n\n以上图距离， 假设要做4和5的lca， 也就是3， 但3的祖先也都是4和5的公共祖先， 因此如果跳到3及3以上的位置， 我们是不能判断这个结点是不是最近的公共祖先的。\n\n因此我们改变策略， 让此时已经同深度的a和b， 跳到它们的最近公共祖先的下一层， 因此我们就有明确的判断条件即两个结点跳了之后不能相同。\n\n倍增的思路基本就是这些了， 实现一下代码试试。\n\n```cpp\nint lca(int a, int b) {\n  if (dep[a] < dep[b]) swap(a, b);\n  //跳至相同深度\n  for (int i = MAX; i >= 0; i --) {\n    if (dep[f[a][i]] >= dep[b]) a = f[a][i];\n    if (a == b) return a;//如果b是a的祖先， 那么最终a会直接跳到b的位置\n  }\n  //同时往上跳\n  for (int i = MAX; i >= 0; i --) {\n    if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];\n  }\n  //当前结点的父结点即为a和b的lca\n  return f[a][0];\n}\n```\n\n---\n\n回头来考虑怎么初始化那些需要的信息。\n\n深度dep就不用说了。\n\n而倍增祖先数组`f`， 则要用到一个递推的性质。\n\n假设`u`的所有祖先的`f`信息我们都已经得到， 且已知了u的父结点(f\\[x][0])， 那么有递推式$f[u][i] = f[f[u][i - 1]][i - 1]$， 也就是`u`的第$2^i$个祖先是 u的第$2^{i-1}$个祖先的第$2^{i-1}$个祖先， 并不难理解。\n\n因此我们可以采用自顶向下的dfs来初始化`f`数组。\n\n```cpp\nint dep[N], f[N][MAX + 1];\n\nvoid dfs(int u, int fa) {\n  dep[u] = dep[fa] + 1, f[u][0] = fa;\n  for (int i = 1; (1 << i) <= dep[u]; i ++) f[u][i] = f[f[u][i - 1]][i - 1];\n  for (auto &v : g[u]) {\n    if (v != fa) dfs(v, u);\n  }\n}\n```\n\n### 练习\n\n> # 【模板】最近公共祖先（LCA）\n>\n> ## 题目描述\n>\n> 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n>\n> ## 输入格式\n>\n> 第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n>\n> 接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n>\n> 接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n>\n> ## 输出格式\n>\n> 输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n>\n> ## 样例 #1\n>\n> ### 样例输入 #1\n>\n> ```\n> 5 5 4\n> 3 1\n> 2 4\n> 5 1\n> 1 4\n> 2 4\n> 3 2\n> 3 5\n> 1 2\n> 4 5\n> ```\n>\n> ### 样例输出 #1\n>\n> ```\n> 4\n> 4\n> 1\n> 4\n> 4\n> ```\n>\n> ## 提示\n>\n> 对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n>\n> 对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n>\n> 对于 $100\\%$ 的数据，$1 \\leq N,M\\leq 500000$，$1 \\leq x, y,a ,b \\leq N$，**不保证** $a \\neq b$。\n>\n>\n> 样例说明：\n>\n> 该树结构如下：\n>\n>  ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n>\n> 第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n>\n> 第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n>\n> 第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n>\n> 第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n>\n> 第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n>\n> 故输出依次为 $4, 4, 1, 4, 4$。\n>\n> 2021/10/4 数据更新 @fstqwq：应要求加了两组数据卡掉了暴力跳。\n\n#### 注意点\n\n* 结点个数最大是5e5， 而$2^{20}$是1e6多一点， 所以MAX取20或19即可。\n* 结点编号一般从1开始， 0作为根结点的父节点， 0高度为0， 且0的父节点是0\n\n#### 参考代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 10;\nvector<int> g[N];\nint dep[N], f[N][25];\n\nvoid dfs(int u, int fa) {\n  dep[u] = dep[fa] + 1, f[u][0] = fa;\n  for (int i = 1; (1 << i) <= dep[u]; i ++) f[u][i] = f[f[u][i - 1]][i - 1];\n  for (auto &v : g[u]) {\n    if (v != fa) dfs(v, u);\n  }\n}\n\nint lca(int a, int b) {\n  if (dep[a] < dep[b]) swap(a, b);\n  for (int i = 20; i >= 0; i --) {\n    if (dep[f[a][i]] >= dep[b]) a = f[a][i];\n    if (a == b) return a;\n  }\n  for (int i = 20; i >= 0; i --) {\n    if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];\n  }\n  return f[a][0];\n}\n\nint main () {\n\tint n, m, s; cin >> n >> m >> s;\n\tfor (int i = 1; i < n; i ++) {\n\t\tint x, y; cin >> x >> y;\n\t\tg[x].push_back(y), g[y].push_back(x);\n\t}\n\tdfs(s, 0);\n\twhile (m --) {\n\t\tint a, b; cin >> a >> b;\n    cout << lca(a, b) << endl;\n\t}\n\treturn 0;\n}\n```\n\n![image-20230411213302406](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230411213302406.png)\n\n## 参考\n\n[最低的共同祖先 - 维基百科 (wikipedia.org)](https://en.wikipedia.org/wiki/Lowest_common_ancestor)\n\n[算法详解之最近公共祖先(LCA) - hulean - 博客园 (cnblogs.com)](https://www.cnblogs.com/hulean/p/11144059.html)","tags":["倍增","LCA"],"categories":["图论"]},{"title":"概率论与数理统计","url":"/posts/6768/","content":"《概率论与数理统计》课程的知识点整理。\n\n[TOC]\n\n<!--more-->\n\n## 样本空间和概率\n\n### 集合论描述的样本空间和随机事件\n\n#### 样本空间与随机事件\n\n* **样本点：**随机试验的一种可能的结果， 用$\\omega$表示。\n\n* **样本空间：** 一个随机试验所有的样本点的集合， 用$\\Omega$表示。\n\n* **随机事件：**样本空间$\\Omega$的一个子集叫做随机事件， 简称事件， 常用大写字母$A、B、C..$表示。\n\n如\"掷一次骰子， 观察出现的点数\"这个随机试验中， 1、2、3、4、5、6都是样本点， 而样本空间为$\\{1, 2, 3, 4, 5, 6\\}$\n\n设事件A:  掷出奇数点。 则A包含了1, 3, 5这三个样本点， $A = \\{1, 3, 5\\}$\n\n#### 事件的关系(集合的运算)\n\n* **A的逆事件**： $\\overline{A}$, A不发生\n\n* **A是B的子事件**： $A \\subset B$, A发生一定导致B发生\n* **A和B的和事件**:  $A \\cup B$， A或B发生\n  * **多个事件的和事件**: $\\bigcup\\limits^{n}_{i=1}A_i$,  n个事件中至少一个发生\n* **A和B的积事件**： $A \\cap B\\  or \\  AB$， A和B同时发生\n  * **多个事件的积事件**: $\\bigcap\\limits_{i=1}^{n}A_i$, n个事件同时发生\n* **A和B的差事件**： $A - B$, A发生而B不发生\n* **A和B是互斥事件**:$A\\cap B = \\varnothing$ ， A和B不能同时发生\n* **A和B是对立事件**： $A \\cap B = \\varnothing\\  \\And \\ A\\cup B = \\Omega$， A、B不同时发生， 但必有一个发生\n\n#### 事件的运算\n\n* 交换律\n* 结合律\n* 分配律\n* **德摩根定理**： \n  * $\\overline{\\bigcap\\limits^n_{i=1}A_i} = \\bigcup\\limits^n_{i=1}\\overline{A_i}$\n  * $\\overline{\\bigcup\\limits^n_{i=1}A_i} = \\bigcap\\limits^n_{i=1}\\overline{A_i}$\n\n### 概率与概率模型\n\n#### 概率公理\n\n用$P(A)$表示事件A的概率\n\n* 非负性： $P(A) \\ge 0$\n* 可加性： 若A和B是互斥事件， 则$P(A\\cup B) = P(A) + P(B)$\n* 归一化： $P(\\Omega) = 1$\n\n#### 概率的常用性质\n\n* $P(A) = 1 - P(\\overline{A})$\n* **减法公式**: $P(A - B) = P(A) - P(AB)$\n* **广义加法公式**: $P(A\\cup B) = P(A) + P(B) - P(AB)$\n\n#### 古典概型（离散模型）\n\n若样本空间由有限个样本点组成， 且由每个样本点组成的事件(基本事件)的概率相等， \n\n有\n$$\nP(A) = \\dfrac{A事件包含的样本点个数}{样本点总数}\n$$\n如上面的“掷骰子试验”就是一个古典概型，\n\n事件A\"掷出奇数\"的概率$P(A) = \\frac{3}{6} = \\frac12$\n\n#### 几何概型（连续模型）\n\n若试验的样本空间是一个连续集合,其相应的概率律与离散情况有很大的差别.在离散情况下,用基本事件的概率就可以确定概率律,但连续情况却不同.\n\n> 罗密欧和朱丽叶约定在某时刻见面,而每个人到达约会地点的时间都会有延迟,延迟时间在0~1小时.第一个到达约会地点的人会在那儿等待15分钟,等了15分钟后,若对方还没有到达约会地点,先到者会离开约会地点.问他们能够相会的概率有多大?\n\n考虑直角坐标系的单位正方形$\\Omega = [0, 1] \\times [0, 1]$ .正方形中的每个点的两个坐标分别代表他们可能的延迟时间.每个点都可以是他们的延迟时间,而且是等可能的.由于等可能性的特点,我们将 $\\Omega$的子集出现的概率定义为这个子集的面积.这个概率律满足三条概率公理.罗密欧和朱丽叶能够相会的事件可用下图中阴影部分表示.它的概率等于7/16.\n\n![](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230301180156136.png)\n\n### 条件概率\n\n在事件$B$已发生的基础上, 求事件$A$发生的概率. 这个概率就叫做B发生之下A的条件概率, 记为$P(A|B)$.\n\n条件概率定义:\n$$\nP(A|B) = \\dfrac{P(AB)}{P(B)}\n$$\n\n### 全概率公式和贝叶斯公式\n\n**全概率公式**\n\n若事件$A_1, A_2, ..., A_n$构成样本空间$\\Omega$的一组划分, 则对于任意事件$B$, 有:\n$$\nP(B) = \\sum_{i=1}^{n}P(A_i \\cap B) = \\sum_{i=1}^{n}P(B|A_i)P(A_i)\n$$\n全概率定理是与著名的贝叶斯准则联系在一起的.贝叶斯准则将形如$P(A|B)$的条件概\n率与形如$P(B|A)$的条件概率联系起来.\n\n**贝叶斯公式**\n\n若事件$A_1, A_2, ..., A_n$构成样本空间$\\Omega$的一组划分, 且对于所有每一个$i$, 满足$P(i) > 0$, 则对于任意满足$P(B) > 0$的事件B, 有\n$$\n\\begin{array}{lcl}\nP(A_i | B) & =  &\\dfrac{P(A_iB)}{P(B)}\\\\\n& = & \\dfrac{P(B|A_i)P(A_i)}{\\sum\\limits_{j=1}^{n}P(B|A_j)P(A_j)}\n\\end{array}\n$$\n\n> 根据以往的记录，某种诊断肝炎的试验有如下效果：对肝炎病人的试验呈阳性的概率为0.95；非肝炎病人的试验呈阴性的概率为0.95．对自然人群进行普查的结果为：有千分之五的人患有肝炎．现有某人做此试验结果为阳性，问此人患有肝炎的概率为多少？\n>\n> 解:\n>\n> 设事件$A$:  患有肝炎, 事件$B$: 试验结果为阳性.\n>\n> 由题中信息可知, $P(B|A) = 0.95$, $P(\\overline{B}|\\overline{A}) = 0.95$, $P(A) = 0.005$\n>\n> 要求的也就是$P(A|B)$, $A$与$\\overline{A}$构成了一组划分, 由贝叶斯公式\n> $$\n> P(A|B) = \\dfrac{P(A)P(B|A)}{P(B|A)P(A) + P(B|\\overline{A})P(\\overline{A})} = \\dfrac{0.005 \\times 0.95}{0.005\\times 0.95 + (1-0.005)\\times (1-0.95)} \\approx 0.0872\n> $$\n> \n\n### 独立性\n\n对于事件$A、B$， 若满足$P(AB) = P(A)P(B)$, 则称$A、B$相互独立。\n\n当满足$P(A) > 0$ 且$P(B) > 0$时， $A和B相互独立\\iff A和B不互斥$， $A和B互斥\\iff A和B不相互独立$。\n\n**多个事件的独立性**\n\n若从n个事件$\\{A_1, A_2, ..., A_n\\}$中任取m$(m \\ge 2)$个事件$\\{A_{i1}, A_{i2}, ..., A_{im}\\}$， 都有$P(A_{i1}A_{i2}...A_{im}) = P(A_{i1})P(A_{i2})...P(A_{im})$， 则称这n个事件是相互独立的。\n\n如$A, B, C$若相互独立， 当且仅当:\n$$\n\\begin{array}{lcl}\nP(ABC) = P(A)P(B)P(C) \\\\\nP(AB) = P(A)P(B) \\\\\nP(AC) = P(A)P(C) \\\\\nP(BC) = P(B)P(C)\n\\end{array}\n$$\n\n**若$A, B$相互独立， 则$A和\\overline{B}$、$\\overline{A}和B$、$\\overline{A}和\\overline{B}$都相互独立。**\n\n### 伯努利概型\n\n设试验$E$只有两种可能的结果$A和\\overline{A}$, , 将$E$独立地重复进行n次,这称这一系列重复的独立试验为n重伯努利试验或n重伯努利概型.\n\n定理: 设$P(A) = p, P(\\overline{A}) = 1 - p$, 则n次试验中， 事件A恰好发生$k$次的概率为:\n$$\nP_n(k) = C_{n}^{k}p^k(1-p)^{n - k}, \\ (k = 0, 1, 2, ..., n)\n$$\n\n\n## 离散随机变量\n\n### 随机变量\n\n在实际中， 随机试验的每一个样本点往往可以用数值来表示， 样本点和数值的映射被称为随机变量， 记为$X$。从数学上讲, 随机变量\n是试验结果的实值函数， 也就是说， 对于每一个样本点$\\omega$， 都有数值$X(\\omega)$与之对应.\n\n举个例子， 连续抛掷一枚硬币共5次,在这个试验中正面出现的次数是一个随机变量$X$, $X$的取值范围为$1, 2, 3, 4, 5$.\n\n然而作为试验结果的长度为5的正面和反面的序列却不能作为随机变量,因为它对于一个试验结果没有给出一个明显的数值.\n\n### 离散随机变量\n\n若一个随机变量的值域(随机变量的取值范围)为一个有限集合或最多为可数无限集合,则称这个随机变量为离散的.\n\n离散随机变量有如下特点：\n\n* 离散随机变量是试验结果的一个实值函数,但是它的取值范围只能是有限多个值或可数无限多个值;\n* 一个离散随机变量有一个分布列,它对于随机变量的每一个取值, 给出一个概率;\n* 离散随机变量的函数也是一个离散随机变量, 它的分布列可以从原随机变量的分布列得到.\n\n### 分布列\n\n使用离散随机变量可以方便的描述基本事件， 基本事件$\\{\\omega\\}$等同于$\\{X = X(\\omega)\\}$,  设$x = X(\\omega)$， 则随机变量$X$等于x的概率记为:$P_X(x)$.\n\n离散随机变量取每个值时的概率是随机变量的最重要的特征, 描述这一特征的函数或图表就是其分布列。\n\n如，设$X$为将硬币独立地抛两次的试验中， 正面向上的次数。\n\n则$X$的分布列为\n$$\n\\begin{array}{c|ccc}\nx & 0 & 1 & 2 \\\\ \\hline\nP_X(x) & \\frac14 & \\frac12 & \\frac14\n\\end{array}\n$$\n对于分布列， 有$\\sum\\limits_xP_X(x) = 1$\n\n#### 01分布\n\n当离散随机变量$X$只有两种可能的取值时， 我们称$X$是01分布， 或$X$是伯努利随机变量。\n$$\n\\begin{array}{c|ccc}\nx & 0 & 1\\\\ \\hline\nP_X(x) & 1-p & p\n\\end{array}\n$$\n\n#### 二项分布\n\n在伯努利概型中， 设$X$为n次试验中A发生的次数($P(A) = p$)， 则有分布列$P_X(x) = C_n^xp^x(1-p)^{n-x}$, 称$X$是参数为$(n, p)$的二项分布， 记作$X \\sim B(n, p)$。\n\n#### 几何分布\n\n在连续抛掷硬币的试验中, 每次抛掷, 正面出现的概率为 p ,反面出现的概率为 1-p, 而且各次抛掷是相互独立的.令 X 为连续地抛掷一枚硬币, 直到第一次出现正面所需要抛掷的次数. X 就称为几何随机变量.前 k-1 次抛掷的结果为反面向上, 第 k 次抛掷的结果为正面向上的概率为$(1-p)^{k-1}p$ . 因此 X 的分布列为$P_X(k) = (1-p)^{k-1}p, \\ k = 1, 2, 3, ..$\n\n![image-20230303212728760](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230303212728760.png)\n\n#### 泊松分布\n\n若随机变量$X$的分布列满足:\n$$\nP_X(k) = \\dfrac{\\lambda^k}{k!}e^{-\\lambda}, \\ k = 0, 1, 2, 3, ...\n$$\n则称$X$服从参数$\\lambda$的泊松分布。\n\n---\n\n\n\n##### 高数二知识补充\n> 高数二补充\n>\n> > $\\sum\\limits_0^{\\infty}\\dfrac{\\lambda^k}{k!} = e^\\lambda$\n\n![image-20230303213941942](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230303213941942.png)\n\n## 连续随机变量\n\n### 分布函数\n\n设$X$为一随机变量， x是任意实数， 则X的分布函数$F_X(x) = P_X(X \\leq x), -\\infty \\leq x \\leq +\\infty$, 分布函数简写为$CDF$\n\n### 密度函数\n\n设随机变量$X$分布函数为$F_X(x)$, 若非负函数$f(x)$满足$F_X(x) = \\int_{-\\infty}^x f(x)\\, dx$, 则$f(x)$被称为$X$的密度函数, $X$被称为连续型随机变量。\n\n密度函数简写为$PDF$\n\n**密度函数的性质**\n\n* 非负性， $f(x) \\geq 0$\n* 归一性， $\\int^{+\\infty}_{-\\infty}f(x) dx = 1$\n* 对于任意实数$a, b(a < b)$, 有$P(a < X \\leq b) = F_X(b) - F_X(a)= \\int_a^bf(x)dx$\n* $f(x)$的大小并不代表$X$取x的概率, 但$f(x)$越大, $X$在x附近取值的概率也就越大\n* 若$f(x)$在x处连续， 则有$f(x) = \\dfrac{dF_X}{dx}$ \n\n### 连续随机变量的性质\n\n对于连续型随机变量$X$, 有\n\n* $X$的分布函数$F_X(x)$连续\n* $P(X = x) = \\int_x^xf(x)dx = 0$, 所以对于连续型随机变量, 其在某一点上的取值概率没有意义, 我们更多关心其在区间内的取值概率.\n\n### 正态分布\n\n当一个随机变量X被称为正态分布时， 它的概率密度有如下格式：\n$$\nf(x) = \\dfrac{1}{\\sqrt{2\\pi\\sigma}}e^{-\\dfrac{(x-\\mu)^2}{2\\sigma^2}}\n$$\n随机变量X服从随机分布式, 简写为$X\\sim N(\\mu, \\sigma^2)$\n\n![image-20230316082220452](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230316082220452.png)\n\n**正态分布特点**\n\n* 正态分布曲线呈钟形, 且关于$x = \\mu$对称, 再$x = u$处达到最大值\n* $x = \\mu \\pm \\sigma$为曲线的拐点\n* $\\lim\\limits_{x\\rightarrow \\infty}f(x) = 0$, 所以x轴为正态分布的水平渐近线\n* 正态分布的均值为$\\mu$, 方差为$\\sigma^2$\n* 线性变换后随机变量的正态性保持不变, 如随机变量$Y = aX + b$, 均值为$a\\mu + b$, 方差为$a^2\\sigma^2$\n\n**标准正态分布**\n\n当$\\mu = 0, \\sigma = 1$时, 称X满足标准正态分布, 记为$X\\sim N(0, 1)$\n\n![image-20230316085903256](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230316085903256.png)\n\n**标准正态分布的性质**\n\n若随机变量$X \\sim N(0, 1)$, 则\n\n* $F_X(-x) = 1 - F_X(x)$(利用标准正态分布关于y轴对称的特点)\n* 如何正态分布都可以通过线性变换转换为标准正态分布. 设$X$为任意一正态随机变量, 令$Y = \\dfrac{X - \\mu}{\\sigma}$, $Y$显然为正态随机变量.\n\n### 二维随机变量(多个随机变量的联合分布)\n\n**二维随机变量的分布函数**\n\n定义$F(x, y) = P(X \\leq x, Y \\leq y)$为二维随机变量$(X, Y)$的分布函数。\n\n![image-20230423170030246](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230423170030246.png)\n\n**二维随机变量分布函数的性质**\n\n* $0 \\leq F(X, Y) \\leq 1$\n* $F(-\\infty, -\\infty) = 0, F(+\\infty, +\\infty) = 1$\n* 对于固定的值$x, y$， 有$F(-\\infty, y) = 0, F(x, -\\infty) = 0$\n\n#### 和分布的卷积公式\n\n设随机变量$X, Y$相互独立， 密度函数为$f_X(x), f_Y(y)$, 设$Z = X + Y $则\n$$\nf_Z(z) = \\int^{+\\infty}_{-\\infty}f_X(x)f_Y(z-y)dx\n$$\n\n\n### 边缘分布\n\n#### 定义\n\n二维随机变量$(X, Y)$通常使用分布函数$F(x, y)$来描述其本质特征， 而其中单个随机变量$X或Y$， 也可以用相应的分布函数$F_X(x)或F_Y(y)$单独描述。由单个$X$或$Y$确定的分布就称为边缘分布。\n\n#### 公式\n\n对于二维离散型随机变量$(X, Y)$， $P(X=x_i) = \\sum\\limits_1^nP(x_i, y_i)$\n\n---\n\n对于二维连续型随机变量$(X, Y)$。\n\n$F_X(x) = P(X \\leq x) = P\\{X\\leq x, Y < +\\infty\\} = F(x, +\\infty)$\n\n所以, 关于$X$的边缘分布函数为\n\n$F_X(x) = \\int_{-\\infty}^xdx\\int^{+\\infty}_{-\\infty}f(x, y)dy$\n\n关于$X$的边缘密度函数为\n\n$f_X(x) = \\dfrac{d}{dx}F_X(x) = \\int^{+\\infty}_{-\\infty}f(x, y)dy$\n\n## 数字特征\n\n### 数学期望\n\n#### 定义\n\n**离散型**\n$$\nEX = \\sum\\limits_{1}^{\\infty}x_ip_i\n$$\n**连续型**\n$$\nEX = \\int_{-\\infty}^{+\\infty}xf(x)dx\n$$\n\n#### 已知X的分布， 求$E[g(X)]$\n\n**离散型**\n$$\nEX = \\sum\\limits_{1}^{\\infty}g(x_i)p_i\n$$\n**连续型**\n$$\nEX = \\int_{-\\infty}^{+\\infty}g(x)f(x)dx \\\\\nE[g(X, Y)] = \\int_{-\\infty}^{+\\infty}{\\int_{-\\infty}^{+\\infty}g(x, y)f(x, y)dx}dy\n$$\n\n#### 性质\n\n* 对于k为常数, $E(kX) = kE(X)$\n* 对任意随机变量X, Y, 有$E(X + Y) = EX + EY$\n* 对于相互独立的两个随机变量X, Y, 有$E(XY) = E(X)E(Y)$\n\n#### 常见分布的数学期望\n\n![image-20230425135438938](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230425135438938.png)\n\n\n\n### 方差\n\n#### 定义\n\n$$\nD(X) = E[X - E(X)]^2 \\\\\nor\\\\\nD(X) = E(X^2) - E(X)^2\n$$\n\n$D(X)$是刻画X取值分散程度的一个量.\n\n若X的取值比较集中,则方差D(X)较小, E(X)作为随机变量的代表性好；\n\n若X的取值比较分散,则方差D(X)较大, E(X)作为随机变量的代表性差.\n\n**标准差**\n\n称$\\sqrt{D(X)}$为X的标准差.\n\n#### 性质\n\n* 若c为常数, 则$D(c) = 0$\n* 若k为常数, 则$D(kX) = k^2 D(X)$\n* 对于任意随机变量$X, Y$, 有$D(X\\pm Y) = D(X) + D(Y) \\pm 2E\\{[X - E(X)][Y-E(Y)]\\}$\n* 对于相互独立的两个随机变量X, Y, 有$D(X\\pm Y) = D(X) + D(Y)$\n\n#### 常见分布的方差\n\n![image-20230425140516258](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230425140516258.png)\n\n\n\n### 大数定律\n\n#### 切比雪夫不等式\n\n设随机变量$X$的数学期望$E(X)$和方差$D(X)$都存在, 则$\\forall \\varepsilon > 0$, 有\n$$\nP\\{|X - EX| \\geq \\varepsilon\\} \\leq \\dfrac{D(X)}{\\varepsilon^2} \\\\or\\\\\nP\\{|X - EX| < \\varepsilon\\} \\geq 1 - \\dfrac{D(X)}{\\varepsilon^2}\n$$\n\n## 参数估计与假设检验\n\n### 总体和样本\n\n**总体**： 统计问题研究对象的全体\n\n**个体**：总体中的每一个成员\n\n---\n\n#### 样本\n\n设$X_1,X_2,..., X_n$是取自总体$X$的的一组样本, 且满足\n\n* $X_1, X_2, ..., X_n$相互独立\n* $X_1, X_2, ..., X_n$与$X$同分布\n\n则称$X_1, X_2, ..., X_n$是容量为n的简单随机样本(简称样本).\n\n样本观测值： 对样本的观察值, 记作$x_1, x_2, ..., x_n$\n\n### 统计量与样本矩\n\n","tags":["概率论"],"categories":["数学","概率论"]},{"title":"树状数组","url":"/posts/5009/","content":"\n> 转载至 [骇客地球](https://www.hackerearth.com/practice/notes/binary-indexed-tree-made-easy-2/)\n>\n> 树状数组的代码很简单， 但思想却很复杂\n>\n> 搞清楚每一句代码背后的细节， 私以为是很重要的\n>\n> 这篇文章从一个新的角度，讲述树状数组实际上在做什么\n\n<!--more-->\n\nFor the past few days, I have been reading various explanations of the Binary Indexed Tree. For some reason, none of the explanations were doing it for me. All explanations told me the same thing over and over again. I was not able to find the motive behind this data structure, intuition behind this data structure.\n\nFinally, I decided to sit down, check some examples, diagram them out, check stack overflow and understand it. I now understand the beauty of this data structure, and I think, I can explain it. For those who have gone through this and also for those who don't want to go through this phase, I am writing this post..\n\nLet me tell you one thing, this is going to be a longer post. I will try to cover all the things associated with it. I have included examples for understanding. Give it half an hour, you will surely get new thing to learn.\n\nWasting no time, lets have a well defined problem.\n\n```\nWe will be given an array. And we are asked to answer few queries. \nQueries will be of two types:-\n1) Update X Y : Increment value at Xth index by Y.\n2) Sum L R : Print sum of values at index L to R inclusive.\n```\n\nLets have a look at other approaches in short, before going for BIT (Binary Indexed Tree), so that you will know the need of BIT.\n\n1. We can **update** any value in the array in single step. So, update operation will need time`O(1)`. Also, for **sum** operation, we can traverse the array and find sum. That operation will take time `O(n)`in worst case.\n2. One more thing we can do. At each index, we will store the cumulative frequency i.e. we will store sum of all elements before it including itself. We can construct this new array in . Lets say this array as CF[]. After that, All the **sum** operation will take time since we will just subtract CF[L-1] from CF[R] to get the answer for sum L R. But well, we will need to construct CF[] or at least update CF[] every-time update operation is made. The worst case time required for this will be .\n\nSince, the queries are huge in number, we can not always afford time complexity `O(n)`too. So, here comes the BIT for our rescue.\n\n---\n\n## **BINARY INDEXED TREE** or **FENWICK TREE**\n\n**CONSTRUCTION of BIT:**\n\nLets have an example with us. Input array is:\n\n```\n[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]\n  1     2     3     4     5     6     7\n```\n\nNow, think of what we did in 2nd approach. For each index, we were storing sum of all elements before that element to that index. Right? But because of that, we were needed to change values at all locations for every update.\n\nNow think it this way, what if we store sum of some elements at each index? i.e. Each index will store sum of some elements the number may vary. Similarly, for update operation also, we will need to update only few values, not all. We will see how!\n\nFormally, we will create some benchmarks. Each benchmark will store sum of all elements before that element; but other than those benchmarks, no other point will store sum of all elements, they will store sum of few elements. Okay, if we can do this, what we will need to do to get sum at any point is - intelligently choosing right combination of positions so as to get sum of all elements before that point. And then we will extend it to sum of elements from L to R (for this, the approach will be same as we did in second approach). We will see that afterwards.\n\nNow, having done the base work, lets move ahead.\n\nBefore telling HOW will we be doing, I would like to tell you WHAT are we going to do. To remind you, we are going to create BIT[] of given input array.\n\n**WHAT:**\n\nThis is a kind of manual process I am showing.\n\nThe benchmarks I was talking about are the powers of 2. Each index, if it is a power of 2, will store the sum of all elements before that. And we will apply this repetitively so as to get what each index will store.\n\nSuppose, we have an array of 16 elements, [1 .. 16].\n\nPowers of 2 are:- 1, 2, 4, 8, 16\n\nThese index will store sum of all elements before them.\n\nFine?\n\nWhat about others?\n\nDivide this array in two halves:- we get [1..8] and [9 .. 16].\n\nNow think recursively what we did for array of 16, apply same for this, okay?\n\nSeems like little bouncer? Wait, have an example of 8 elements only. Say 8 elements are :\n\n```\n1   2   3   4   5   6   7   8\n```\n\nOk, powers of 2 are: 1 2 4 8 so, in BIT[] indiced 1 2 4 8 will store 1 = 1, 1 + 2 =3, 1 + 2 + .. + 4 = 10 and 1 + 2 + .. + 8 = 36 respectively. Right? Remember, sum of all elements before that element? Right? Good. So, till now, BIT looks like this:-\n\n```\n[ 1 ] [ 3 ] [  ] [ 10 ] [   ] [   ] [  ] [36] \n  1    2    3    4    5     6    7   8\n```\n\nNow, divide the given array in 2 halves.\n\nArr1:\n\n```\n1   2   3   4\n```\n\nArr2:\n\n```\n5   6   7   8\n```\n\nConsider Arr1 first. Powers of 2 are:- 1 2 4 They already have their right values, no need to update.\n\nNow, Consider Arr2: Powers of 2 are: 1 2 4\n\nSo, at indices 1, 2 and 4 will store 5 = 5, 5 + 6 = 11, 5 + 6 + 7 + 8 = 26 respectively.\n\nThese are the indices according to this new 4-element array. So, actual indices with respect to original array are 4+1, 4+2, 4+4 i.e. 5, 6, 8. We will not care about index 8 as it is already filled in BIT[]. Hence we will update position 5 and 6 now.\n\nBIT will start looking like this now:-\n\n```\n[ 1 ] [ 3 ] [  ] [ 10 ] [ 5 ] [ 11 ] [  ] [ 36 ] \n  1     2     3    4      5     6      7    8\n```\n\nI think you guys have got what we are doing. Applying same procedure on Arr1 and Arr2, we will get 4 - two element arrays (2 from Arr1 and 2 from Arr2). Follow the same procedure, don't change the value at any index if it is already filled, you get this BIT finally.\n\n```\n[ 1 ] [ 3 ] [ 3 ] [ 10 ] [ 5 ] [ 11 ] [ 7 ] [ 36 ] \n  1     2     3     4      5     6      7     8\n```\n\nGuys, do take an example of 16 element array and convert it to BIT manually to get the gist.\n\nNow see how will we do this in program.\n\n**HOW:**\n\nWe will continue with our previous example.\n\nNow, start thinking of our array as a binary tree, like this:-\n\n```\nBEFORE:\n[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]\n  1     2     3     4     5     6     7\n\nNOW:\n\n         4\n       [ 4 ]\n      /     \\\n     2       6\n   [ 1 ]   [ 3 ]\n    / \\     / \\\n   1   3   5   7\n  [5] [6]  [2] [3]\n```\n\nNow, we will change value at each node by adding the sum of nodes in its **left sub-tree**.\n\n```\nUPDATED VERSION:\n\n         4\n       [ 16 ]\n      /     \\\n     2       6\n   [ 6 ]   [ 5 ]\n    / \\     / \\\n   1   3   5   7\n  [5] [6]  [2] [3]\n```\n\nI think you have got what we have just done! Take each node, find sum of all nodes in its left sub-tree and add it to value of that node. And this is what we call is BIT.\n\n```\nBIT:\n[ 5 ] [ 6 ] [ 6 ] [ 16 ] [ 2 ] [ 5 ] [ 3 ]\n  1     2     3     4      5     6     7\n```\n\n------\n\n**SUM and UPDATE operations:**\n\nNow, we have got the BIT. Lets move ahead and solve our real problem.\n\nHaving this tree structure with us, it is to find sum of elements till any index. The idea is to keep a variable `ans` initialized to 0. Follow the path from root to the node `index`. Whenever we need to follow a right link, add the value of current node to `ans` . Once we reach the node, add that value too.\n\nFor example, If we want sum of elements upto index 3.\n\nSee again,\n\n```\nINPUT ARRAY is:\n[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]\n  1     2     3     4     5     6     7\n```\n\n(so answer should come out as 5 + 1 + 6 = 12)\n\n```\nBIT is:\n\n         4\n       [ 16 ]\n      /     \\\n     2       6\n   [ 6 ]   [ 5 ]\n    / \\     / \\\n   1   3   5   7\n  [5] [6]  [2] [3]\n```\n\nFollowing the procedure given above.\n\n```\n1> node = root, ans = 0\n2> node is 4, index is 3. \n3> index < node, go left\n4> node = 2, index is 3.\n5> index > node, add value(node) to ans and go right\n      i.e. ans = ans + value(node 2)\n      i.e. ans = 0 + 6\n      i.e. ans = 6\n      Now, go right\n6> node = 3, index = 3\n7> node == index, add value of node 3 to ans and return ans\n     i.e. ans = ans + 6\n     i.e. ans = 12\n     return 12\n```\n\nIn actual implementation, we will be following the reverse path i.e. from node to root.\n\nWe will go in actual implementation too. Just have look at update operation as well.\n\nIf we want to increment `k` the value at `index` by say .\n\nThe idea is very similar to sum operation.\n\nFollow the path from root to the node. Whenever we need to follow a left link, add the value of to current node. Once we reach the node, add to that node too. This is because we will need to update the set of nodes in the tree that include that node in its left subtree, so that it will be consistent with our sum operation, right?`index``k``k`\n\nI don't think there is any need of example for this case again.\n\n------\n\nMoving ahead to the implementation.\n\nFor this, we will play a bit with **BITS -- Binary Numbers**. Here comes the fun with bits -- Binary numbers. You will have to do little more work here to figure out the things. I will try my best though.\n\n```\nTREE is:\n        100\n       [ 16 ]\n      /     \\\n    010     110\n   [ 6 ]   [ 5 ]\n    / \\     / \\\n  001 011 101 111\n  [5] [6] [2] [3]\n```\n\nWe have just changed the representation of out indices to binary. Ok?\n\nNow, For each index, find the right most SET-bit i.e. '1' and drop the all zeros along with that '1'. We get,\n\n```\n       (--)\n      [ 16 ]\n      /     \\\n     0       1\n   [ 6 ]    [ 5 ]\n    / \\      / \\\n  00   01   10  11\n  [5]  [6]  [2] [3]\n```\n\nHere is the thing to be observed. If we treat 0 as LEFT and 1 as RIGHT, each node tells you the path to be followed from root to reach that node. Really? Have example, say node 5, which has 10 there, i.e. RIGHT and LEFT. This is the path we need to follow from root to 5. Cool thing, right?\n\nThe reason why this is important to us is, our **sum** and **update** operations depends on the this path. Are they not? You remember, Left link, right link, right? During a **sum**, we just care about the left links we follow. During an **update**, we just care about the right links we follow. This binary indexed tree does all of this super efficiently by just using the bits in the index.\n\nThe key thing behind the efficiency of BIT is:\n\n> Given any index n, the next node on the path from root to that index where we go right is directly calculated by RESETing i.e. '0' the last (right most) SET-bit from the binary representation of . Apply this until we reach the root.`index`\n\nLets have examples:\n\n```\nTREE is:\n         4\n       [ 16 ]\n      /     \\\n     2       6\n   [ 6 ]   [ 5 ]\n    / \\     / \\\n   1   3   5   7\n  [5] [6] [2]  [3]\n```\n\nSay index is 5. The path from 4 to 5 is [ 4 -> RIGHT -> 6 -> LEFT -> 5 ] i.e. we take RIGHT at 4. Binary Representation of 5 is 101. RESET right-most SET-bit. 101 -> 100 4 is the one node from where we will go right STOP here. We have reached the root.\n\nSay index is 7. The path from 4 to 7 is [ 4 -> RIGHT -> 6 -> RIGHT -> 7 ] i.e. we take RIGHT at 4 and 6. Binary Representation of 7 is 111. RESET right-most SET-bit. 111 -> 110 6 is the node from where we will go right RESET right-most SET-bit. 110 -> 100 4 is the node from where we will go right STOP here. We have reached the root.\n\nWe will use this information in our implementation.\n\n**Implementation:**\n\nNow we know, how to go from any index to the root and find what all right-links come in our path.\n\nI will repeat some part of what we have looked.\n\n> For SUM: The idea is to keep a variable initialized to 0. Follow the path from root to the node. Whenever we need to follow a right link, add the value of current node to . Once we reach the node, add that value too.`ans``index``ans`\n>\n> For UPDATE: Follow the path from root to the node. Whenever we need to follow a left link, add the value of to current node. Once we reach the node, add to that node too.`index``k``k`\n\nNow you have got the complete picture I guess. Everything of What we saw, Why we saw?\n\nFor SUM, We need to follow RIGHT-links no matter from root to index or reverse. And we also know how to do that. Right?\n\nSo algorithm is:\n\n```\nSUM(index):\n    ans = 0\n    while(index != 0):\n        ans += BIT[index]\n        index = Reset_Rightmost_SET_bit(index)\n    return ans\n```\n\nNow, the thing remain unanswered is: How to Reset rightmost SETbit? This is a very simple task which I have already covered in my this note. By some observations, we can arrive at a conclusion that, whenever we subtract one from any number say n, the part before a right-most set bit remain same while part after right-most set bit gets inverted. So, just ANDing these can solve our problem.\n\n```\nReset_Rightmost_SET_bit(n):\n    return n&(n-1)\n```\n\nPlease be focused and try to understand this.\n\nWe need all left links but we can only know right links with the technique we studied earlier.\n\nWe know that, dropping the right-most SET bit and part after that gives us the path from root to node.\n\nSo, zeros which come after the right-most one are not useful to us at all.\n\nWe will use both these fact and try to find a way.\n\nYou must have observed, what happens when we add a 1 to right-most SET bit of a number? [Consider scan from right to left]\n\n1. The first zero from right (which will come after i.e. left to, right-most ONE of number) turns into one\n2. Part after (i.e. left to) that ZERO remain unchanged and Part before that get inverted.\n\nIs this not the exact reverse procedure of what used to happen in SUM operation.\n\nThis is all what we wanted!\n\nAnd this is the value i.e. index from which we needed to take the left link to reach to our node from root.\n\nWe have successfully found the left link too.\n\nAdding one to right most one is nothing but adding place value of right-most ONE to the number.\n\nHence our Update operation is as simple as:\n\n```\nUPDATE(index, addition):\n    while(index < length_of_array):\n        BIT[index] += addition\n        index = index + (index & -index)\n```\n\nTry to check the similarity and difference, and you will never forget again.\n\nHere I will stop. I guess you have everything what you need to know about Binary Indexed Tree as a data structure. Now I advice you to implement it yourself and see if you can do it.\n\nYou can always refer to the code which I am providing you.\n\n```\n# About using the 2 functions:-\n# For update, pass index of location to be updated, input array, BIT, value to be added to original number\n# i.e. new value - original value\n# For getting sum of elements in range l to r,\n# Getsum returns sum of elements from beginning to index\n# Pass index, input array & BIT to function\n# getsum of l to r = getsum of r - getsum of (l-1)\n\ndef update(index, a, tree, value):\n# index is index to be updated, a is input array / list, tree is BIT array, value is value to be added to original \n# number at index location\n    add = value\n    n = len(a)\n    while index<n:\n        tree[index] += add\n        index = index + (index & (-index))\n\ndef getsum(index, a, tree):\n# index is location upto which you want the sum of elements from beginning\n# tree is BIT[], a is input array / list\n    n = len(a)\n    ans  = 0\n    while(index>0):\n        ans += tree[index]\n        index = index - (index & (-index))\n    return ans\n\n#Get the user input\nn = int(raw_input(\"Number of Elements in array: \"))\ninputArray = list(map(int, raw_input(\"Elements in array: \").split()))\ninputArray.insert(0,0)                 # insert dummy node to have 1-based indexing\n\n#Initialise Binary Indexed Tree to 0's considering that input array is all 0's\nBIT = []\nfor i in range(0, n):\n    BIT.append(0)\n\n# Now we will construct actual BIT\n# The 4th parameter is always an additional value which is to be added to element at index location\n# since we have considered input array as 0 earlier (while initialising BIT), for updating, we will pass actual \n# value\nfor i in range(1, n):\n    update(i, inputArray, BIT, inputArray[i])\n```\n\nIf you like this, Let me know :) Like, Share, Upvote[at the top]!!\n\nThank you for reading and also thanks for your patience.","tags":["树状数组"],"categories":["高级数据结构"]},{"title":"图着色","url":"/posts/23124/","content":"图着色问题(Graph Coloring Problem)是一个著名的$NPC$问题， 其内容是， 对于给定的无向图， 为每个顶点指定一颜色， 且使得相邻的顶点颜色不相同。\n\n将图G以如上规则着色所需要的最少颜色数表示为$\\chi(G)$, 被称为最小着色数。\n\n<!--more-->\n\n## 寻找图着色问题可行解——Welsh-Powell算法\n\nwelsh-powell算法用于找出一个$\\chi(G)$不超过 图的最大度 + 1 的图着色问题的解。\n\n**算法流程**\n\n1. 将所有未着色的顶点集按度降序排序\n2. 为度最大的顶点染一个未被使用过的颜色`color`\n3. 遍历未着色的所有顶点， 若其不与任何被染成`color`的顶点相邻， 则将其染成`color`\n4. 若仍有未着色的顶点， 重复123步骤， 否则结束\n\n### 举例\n\n以下无向图举例\n\n![graph0](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/graph0.png)\n\n根据度数降序排序后， 如下表所示\n\n|顶点编号|5|4|9|2|0|12|10|6|3|1|8|7|11|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|度数|5|5|4|4|4|3|3|3|3|3|2|2|1|\n\n* 第一轮染色， 5、9、2、6、7被染成相同颜色\n\n![graph1](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/graph1.png)\n\n* 第二轮染色， 4、12、10、3、11被染成相同颜色\n\n![graph2](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/graph2.png)\n\n* 第三轮染色， 0、1、8被染成相同颜色\n\n![graph3](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/graph3.png)\n\n> 以上图示使用网站工具[Graph Editor (csacademy.com)](https://csacademy.com/app/graph_editor/)绘制\n\n### 代码实现\n\n```cpp\nvector<int> welsh_powell(vector<vector<int>> &g) {\n  int n = g.size();\n  vector<int> color(n, 0);\n  vector<int> v;\n  for (int i = 0; i < n; i ++) v.push_back(i);\n  sort(v.begin(), v.end(), [&g] (const auto &a, const auto &b) {\n    return g[a].size() > g[b].size();\n  });\n  for (int cnt = 1; v.size(); cnt ++) {\n    vector<int> t;\n    for (auto &u : v) {\n      if (color[u] == -1) {\n        t.push_back(u);\n      } else {\n        color[u] = cnt;\n        for (auto &adj : g[u]) {\n          if (color[adj] == 0) color[adj] = -1;\n        }\n      }\n    }\n    for (auto &x : t) color[x] = 0;\n    v = t;\n  }\n  return color;\n}\n```\n\n## 饱和度算法\n\n饱和度算法(DSatur Algorithm)是对Welsh-Powell算法的改进， 它除了考虑考虑顶点的度外， 还考虑顶点的饱和度(已着色的邻接点数量)。\n\nDSatur算法同样不能保证得到最小着色数， 但表现上比Welsh-Powell算法更好。\n\n详见[DSatur Algorithm for Graph Coloring - GeeksforGeeks](https://www.geeksforgeeks.org/dsatur-algorithm-for-graph-coloring/)\n\n## 四色定理\n\n> **四色定理**（英语：four color theorem）又称为**四色地图定理**（英语：four color map theorem），是一个著名的[数学](https://zh.wikipedia.org/wiki/数学)[定理](https://zh.wikipedia.org/wiki/定理)[[1\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-pyx-1)：如果在[平面](https://zh.wikipedia.org/wiki/平面_(数学))上划出一些邻接的有限区域，那么可以用四种颜色来给这些区域染色，使得每两个邻接区域染的颜色都不一样[[2\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-Fritsch-2)[[3\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-soifer-3)\n\n\n\n![img](https://miro.medium.com/max/619/0*fiE_-5ZC7cQZdSxN.gif)\n\n> 四色定理是第一个主要由电脑验证成立的著名数学定理。这一证明刚开始并不被所有的数学家接受。1979年，逻辑哲学和数学哲学家[托马斯·蒂莫兹佐](https://zh.wikipedia.org/w/index.php?title=托马斯·蒂莫兹佐&action=edit&redlink=1)在《四色定理及其哲学意义》一文中提出，四色定理与其证明能否称之为“定理”和“证明”，尚有疑问。“证明”的定义也需要进行再次审视。蒂莫兹佐的理由包括两点：一方面，计算机辅助下的证明无法由人力进行核查审阅，因为人无法重复计算机的所有运算步骤；另一方面，计算机辅助的证明无法形成逻辑上正则化的表述，因为其中的机器部分依赖于现实经验的反馈，无法转换为抽象的逻辑过程[[22\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-22)[[23\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-23)。即便在数学界中，对四色定理证明的误解也存在着。有的数学家认为证明是杰出的进展，也有人认为依赖计算机给出的证明很难令人满意[[3\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-soifer-3):197。也有人认为，计算机辅助证明数学定理不过是对人的能力进行延伸的结果，因为电子计算机不过是依照人的逻辑来进行每一步的操作，实际上只是将人能够完成的工作用更短的时间来完成[[3\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-soifer-3):198。还有人将计算机辅助证明和传统证明的差别比喻为借助[天文望远镜](https://zh.wikipedia.org/wiki/天文望远镜)发现新星和用肉眼发现新星的区别[[24\\]](https://zh.wikipedia.org/wiki/四色定理#cite_note-pck-24)。\n\n**平面图：**如果无向图$G$能在平面上画出图解， 且没有任何边存在交叉， 则$G$是一个平面图。\n\n一张地图即可抽象为一个平面图， 四色定理也就说明， 对于平面图， $\\chi(G) \\le 4$.\n\n## 参考\n\n[图着色问题 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/图着色问题)\n\n[四色定理 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/四色定理)\n\n[独立集 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/独立集)\n\n[NP完全 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/NP完全)\n\n[Demystify Graph Coloring Algorithms | by Edward Huang | Better Programming](https://betterprogramming.pub/demystify-graph-coloring-algorithms-9ae51351ea5b)\n\n[图的着色 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/color/#welshpowell-算法)\n\n[Welsh Powell Graph colouring Algorithm - GeeksforGeeks](https://www.geeksforgeeks.org/welsh-powell-graph-colouring-algorithm/)\n\n[图论--图的着色 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/385512430)","tags":["图着色"],"categories":["图论"]},{"title":"latex数学公式手册","url":"/posts/48306/","content":"由于markdown语法的局限性， 在写markdown文本时经常需要用到扩展的语法来满足更多的需求。而内嵌式latex是最广泛的markdown编写数学公式的解决方案。\n\n![image-20230303215814126](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230303215814126.png)\n\n本文将以表格的形式分类介绍$L^AT_EX$的各种公式及语法， 其中只包含我用过的或觉得很重要的， 内容会随时间不断更新。\n\n<!--more-->\n\n## 保留字\n\n保留字是latex语法中有特殊含义的字符， 要使其以正常文本显示需要特定的语法。\n\n| 序号 | latex显示 | latex源码 | 解释 |\n| :-:| :-: | :-: | :-: |\n| 1 | $\\%$ | `\\%` | %在latex中用于注释 |\n| 2 | $\\{$ | `\\{` | `{`和`}`在latex中是作用域的界定符号 |\n| 3 | $\\}$ | `\\}` | `{`和`}`在latex中是作用域的界定符号 |\n| 4 | $\\backslash$ |`\\backlash`|`\\`是latex中用于转义的符号|\n\n## 希腊字母\n\n一下均为小写, 大写只需要首字母大写即可.\n\n| 序号 |   latex显示   |     latex源码     |\n| :--: | :-----------: | :---------------: |\n|  1   |   $\\alpha$    |     `\\alpha`      |\n|  2   |    $\\beta$    |      `\\beta`      |\n|  3   |   $\\delta$    |     `\\delta`      |\n|  4   |   $\\Delta$    |     `\\Delta`      |\n|  5   |   $\\theta$    |     `\\theta`      |\n|  6   |     $\\pi$     |       `\\pi`       |\n|  7   |    $\\chi$     |      `\\chi`       |\n|  8   |   $\\omega$    | `\\omega / \\Omega` |\n|  9   |   $\\lambda$   |     `\\lambda`     |\n|  10  |   $\\sigma$    |      `sigma`      |\n|  11  |     $\\mu$     |       `\\mu`       |\n|  12  | $\\varepsilon$ |   `\\varepsilon`   |\n\n## 运算符\n\n| 序号 | latex显示 |    中文名    | latex源码 |\n| :--: | :-------: | :----------: | :-------: |\n|  1   |    $+$    |      加      |    `+`    |\n|  2   |    $-$    |      减      |    `-`    |\n|  3   | $\\times$  |     叉乘     | `\\times`  |\n|  4   |  $\\cdot$  |     点乘     |  `\\cdot`  |\n|  5   |  $\\div$   |     除号     |  `\\div`   |\n|  6   |    $/$    |     除号     |    `/`    |\n|  7   | $\\oplus$  |     异或     | `\\oplus`  |\n|  8   |   $\\pm$   | 加或减(正负) |   `\\pm`   |\n\n## 关系符\n\n| 序号 | latex显示 |  中文名  |    latex源码    |\n| :--: | :-------: | :------: | :-------------: |\n|  1   |    $=$    |   等于   |       `=`       |\n|  2   |  $\\neq$   |  不等于  |     `\\neq`      |\n|  3   | $\\equiv$  |  恒等于  |    `\\equiv`     |\n|  4   |    $<$    |   小于   |       `<`       |\n|  5   |   $\\le$   | 小于等于 | `\\le` or `\\leq` |\n|  6   |    $>$    |   大于   |       `>`       |\n|  7   |   $\\ge$   | 大于等于 | `\\ge` or `\\geq` |\n## 集合关系\n\n|   latex显示    |  解释  |   latex源码    |\n| :------------: | :----: | :------------: |\n| $\\varnothing$  |  空集  | `\\varnothing`  |\n|   $A\\cap B$    |  交集  |   `A\\cap B`    |\n|   $A \\cup B$   |  并集  |   `A \\cup B`   |\n| $\\overline{A}$ |  补集  | `\\overline{A}` |\n|   $x \\in A$    |  属于  |   `x \\in A`    |\n|  $x \\notin A$  | 不属于 |  `x \\notin A`  |\n| $A \\subset B$  | 包含于 | `A \\subset B`  |\n|   $\\forall$    |  任意  |   `\\forall`    |\n|    $\\exist$    |  存在  |    `\\exist`    |\n\n## 上下标\n\n|    类型    |               latex显示               |               latex源码               |\n| :--------: | :-----------------------------------: | :-----------------------------------: |\n|    上标    |           $2^a, 2^{a + b}$            |           `2^a, 2^{a + b}`            |\n|    下标    |     $CO_2, log_2100, log_{ab}cd$      |     `CO_2, log_2100, log_{ab}cd`      |\n| 符号上下标 | $\\sum^n_{i=1}, \\ \\sum\\limits^n_{i=1}$ | `\\sum^n_{i=1}, \\ \\sum\\limits^n_{i=1}` |\n\n## 箭头符号\n\n| 序号 |   latex显示   |   latex源码   |\n| :--: | :-----------: | :-----------: |\n|  1   | $\\Rightarrow$ | `\\Rightarrow` |\n|  2   | $\\Leftarrow$  | `\\Leftarrow`  |\n|  3   |    $\\iff$     |    `\\iff`     |\n\n## 分数\n\n|   类型   |                    latex显示                     |                    latex源码                     |\n| :------: | :----------------------------------------------: | :----------------------------------------------: |\n| 普通分数 |           $\\frac{1}{2} \\frac{abc}{2}$            |           `\\frac{1}{2} \\frac{abc}{2}`            |\n| 大型分数 | $\\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a$ | `\\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a` |\n\n## 数学函数\n\n|   类型   |                    latex显示                     |                    latex源码                     |\n| :------: | :----------------------------------------------: | :----------------------------------------------: |\n| 对数函数 |       $\\ln c, \\lg d = \\log e, \\log_{10} f$       |       `\\ln c, \\lg d = \\log e, \\log_{10} f`       |\n| 三角函数 | $\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f$ | `\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f` |\n\n## 根式\n\n|  类型  |    latex显示    |    latex源码    |\n| :----: | :-------------: | :-------------: |\n| 平方根 |  $\\sqrt{abc}$   |  `\\sqrt{abc}`   |\n| n次根  | $\\sqrt[n]{abc}$ | `\\sqrt[n]{abc}` |\n## 模运算\n\n|          latex显示          |          latex源码          |\n| :-------------------------: | :-------------------------: |\n| $a^{n-1} \\equiv 1 \\pmod{n}$ | `a^{n-1} \\equiv 1 \\pmod{n}` |\n|         $a \\bmod b$         |         `a \\bmod b`         |\n\n## 大型运算符\n\n| 类型 |        latex显示         |        latex源码         |\n| :--: | :----------------------: | :----------------------: |\n| 求和 |  $\\sum\\limits_{i=1}^n$   |  ` \\sum\\limits_{i=1}^n`  |\n| 交集 | $\\bigcap\\limits_{i=1}^n$ | `\\bigcap\\limits_{i=1}^n` |\n| 并集 | $\\bigcup\\limits_{i=1}^n$ | `\\bigcup\\limits_{i=1}^n` |\n\n## 二项式系数\n\n| 类型 |            latex显示            |            latex源码            |\n| :--: | :-----------------------------: | :-----------------------------: |\n| 普通 |         $\\binom{n}{k}$          |         `\\binom{n}{k}`          |\n| 小型 |         $\\tbinom{n}{k}$         |         `\\tbinom{n}{k}`         |\n| 大型 | $\\dbinom{\\frac{a + b}{2}}{x^2}$ | `\\dbinom{\\frac{a + b}{2}}{x^2}` |\n\n## 积分\n\n|   类型   |      latex显示      |      latex源码      |\n| :------: | :-----------------: | :-----------------: |\n| 一重积分 | $\\int_{0}^1 e^x dx$ | `\\int_{0}^1 e^x dx` |\n| 多重积分 |   $\\iint, \\iiint$   |   `\\iint, \\iiint`   |\n\n## 空格\n\n|   类型   |     latex显示     |     latex源码     |\n| :------: | :---------------: | :---------------: |\n|  单空格  | $a \\quad b \\ c d$ | `a \\quad b \\ c d` |\n|  双空格  |   $a \\qquad b$    |   `a \\qquad b`    |\n| 转义空格 |      $a \\ b$      |      `a \\ b`      |\n\n## 文本颜色\n\n使用`{\\color{colorName}text}`即可使对应文本使用指定的颜色\n\n|                        latex显示                         |                        latex源码                         |\n| :------------------------------------------------------: | :------------------------------------------------------: |\n| ${\\color{orange}x^2} + {\\color{cyan}x} + {\\color{red}1}$ | `{\\color{orange}x^2} + {\\color{cyan}x} + {\\color{red}1}` |\n\n## 参考\n\n[Hank 博客](http://www.uinio.com/Math/LaTex/)\n\n[LaTeX - A document preparation system (latex-project.org)](https://www.latex-project.org/)","tags":["latex","markdown"],"categories":["数学"]},{"title":"组合数","url":"/posts/40979/","content":"\n本文只解决一个问题：求$C_a^b\\ \\%\\ p$.\n\n## 递归公式（杨辉三角)\n\n### 原理\n众所周知， $C^b_a = C^b_{a-1} + C^{b-1}_{a-1}$.\n\n<!--more-->\n\n可以从组合数的现实意义上证明其正确性：\n\n> $C_a^{b}$表示从a个不同物体中选出b个的所有方案数。\n>\n> 设a个物体中有一个物体x，则$C_a^b$可以分为 包含x的方案 和不包含x的方案。\n>\n> * 包含x， 则还需要从剩余的a-1个物体中再选b-1个， 即为$C^{b-1}_{a-1}$\n> * 不包含x， 则需要从另外的a-1个物体中选b个， 即为$C^b_{a-1}$\n>\n> 因此， $C^b_a = C^b_{a-1} + C^{b-1}_{a-1}$.\n\n使用此公式可以以$O(ab)$的时间复杂度预处理出$C^0_0到C_a^b$范围中所有的组合数。\n\n此方法适用于`a*b`在$1e8$范围内且需要频繁查询的问题。\n\n### 代码实现\n\n**c++**\n\n```cpp\nfor (int i = 0; i <= n; i ++) {\n\tC[i][0] = 1;\n\tfor (int j = 0; j <= i; j ++) {\n\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;\n\t}\n}\n```\n\n## 阶乘公式\n\n### 原理\n众所周知， $C_a^b = \\frac{a!}{b!(a - b)!}$.\n\n可以从排列数的角度证明其正确性：\n\n>$A_a^b$表示有先后顺序的从a个不同物体中选出b个的所有方案数，$A_a^b = \\frac{a!}{(a-b)!}$。\n>\n>若只选取固定的b个物品， 则选取顺序显然有$b!$种。\n>\n>即$A_a^b = b!C_a^b$, $C_a^b = \\frac{a!}{b!(a - b)!}$\n\n通常的， 可以预处理 1~a的阶乘以及阶乘的逆元， 如此一来使用$O(n)$的时间复杂度预处理， 即可$O(1)$的完成每次查询。\n\n但有一个值得注意的问题是， 既然需要计算逆元， 就得保证各阶乘的逆元存在。当p大于a时， 1~a的阶乘必然是存在的， 因为x与p互质、y与p互质， 则x*y同样也与p互质。\n\n所以此方法适用于a小于$1e8$且a小于p的问题。\n\n### 代码实现\n```c++\nfact[0] = inv[0] = 1;\nfor (int i = 1; i <= n; i ++) {\n\tfact[i] = (fact[i - 1] * i) % p;\n\tinv[i] = (inv[i-1] * modPow(i, p - 2, p)) % p;\n}\n```\n\n## Lucas定理\n\n### 原理\n\nLucas定理:\n\n对于素数p， 有\n$$\nC_a^b \\equiv C_{a\\%p}^{b\\%p} \\times C_{\\lfloor \\frac{a}{p}\\rfloor}^{\\lfloor \\frac{b}{p}\\rfloor} \\ (mod \\ p)\n$$\nLucas定理常见的应用场景是: a非常大， 而p较小。\n\n在实现时， 因为p比较小， 我们一般直接计算$C_{a\\%p}^{b\\%p}$. 而$C_{\\lfloor \\frac{a}{p}\\rfloor}^{\\lfloor \\frac{b}{p}\\rfloor}$则递归的使用Lucas定理计算。\n\n### 代码实现\n```cpp\nll lucas(ll a, ll b, ll p) {\n    return b == 0 ? 1 % p : C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\n```\n### 模板题\n> 给定 $n$组询问，每组询问给定三个整数 $a,b,p$其中 $p$是质数，请你输出$C_a^b\\ \\%\\ p$ 的值。\n>\n> #### 输入格式\n>\n> 第一行包含整数 $n$。\n>\n> 接下来 $n$行，每行包含一组 $a,b,p$。\n>\n> #### 输出格式\n>\n> 共 $n$行，每行输出一个询问的解。\n>\n> #### 数据范围\n>\n> $1≤n≤20$\n> $1≤b≤a≤10^{18}$,\n> $1≤p≤10^5$,\n>\n> #### 输入样例：\n>\n> ```\n> 3\n> 5 3 7\n> 3 1 5\n> 6 4 13\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> 3\n> 2\n> ```\n\n#### 参考代码\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5;\nll fact[N], inv[N];\n\nll modPow(ll a, ll n, ll p) {\n    ll res = 1 % p;\n    while (n) {\n        if (n & 1) res = res * a % p;\n        a = a * a % p, n >>= 1;\n    }\n    return res;\n}\n\nll C(ll a, ll b, ll p) {\n    return fact[a] * inv[b] % p * inv[a - b] % p;\n}\n\nll lucas(ll a, ll b, ll p) {\n    return b == 0 ? 1 % p : C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\n\nint main () {\n    int n; cin >> n;\n    while (n -- ) {\n        ll a, b, p; cin >> a >> b >> p;\n        fact[0] = inv[0] = 1 % p;\n        for (ll i = 1; i < p; i ++) {\n            fact[i] = fact[i - 1] * i % p;\n            inv[i] = inv[i - 1] * modPow(i, p - 2, p) % p;\n        }\n        cout << lucas(a, b, p) << endl;\n    }\n    return 0;\n}\n```\n\n### 时间复杂度\n\n$lucas$函数的执行次数显然是$\\log_pa$左右次， 而每次执行的时间复杂度取决于$C$函数。\n\n*  如果像如上代码一样， 预处理p内的阶乘fact和逆元inv， 则C函数的时间复杂度为$O(1)$, lucas算法的时间复杂度为$O(p + \\log_pa)$\n*  如果不予记录， 而是每次都在C函数内递推一遍， 则C函数的时间复杂度为$O(p)$, lucas算法的时间复杂度为$O(p\\log_pa)$.\n\n## 参考\n\n[二项式系数 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/二項式係數)\n\n[排列组合 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/combination/)\n\n[卢卡斯定理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/lucas/#习题)\n\n[卢卡斯定理 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/卢卡斯定理)\n\n[算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/116698264)","tags":["乘法逆元","递推","lucas定理","杨辉三角"],"categories":["数学","离散数学","组合数学"]},{"title":"乘法逆元","url":"/posts/24044/","content":"\n## 定义\n如果整数a, x满足$ax \\equiv 1 (mod \\ p)$, 则将x称为$a\\  mod \\ p$的逆元， 记作$a^{-1}$.\n\n逆元可以理解为模p同余式中a的倒数即$\\frac{1}{a}$, 相似的有一些简单的性质如$(ab)^{-1} \\equiv (a)^{-1}*(b)^{-1} (mod \\ p)， (\\frac{b}{a})^{-1} \\equiv \\frac{a}{b} (mod \\ p) \\ , 1^{-1} \\equiv 1 (mod \\ p)$.\n\n注意， 当a、p不互素时， 不存在相应的逆元。\n\n<!--more-->\n\n## 意义\n\n当我们要求$(\\frac{b}{a}) \\mod p$, 且b数值过大无法直接存储在变量中与a运算， 这时就可以使用乘法逆元。\n\n由乘法逆元定义有$bax \\equiv b (mod \\ p)\\iff bx \\equiv \\frac{b}{a} (mod\\ p)$。\n\n## 求法\n\n### 扩展欧几里得算法\n\n#### 过程\n\n已知， 扩展欧几里得算法可用于求$ax + by = gcd(a, b)$的一组可行解， 而**当$a、b$互质**时， $ax + by = gcd(a, b) \\iff ax + by = 1 \\iff ax \\equiv 1(mod\\ b)$。\n\n#### 代码实现\n\n**python**\n\n```python\ndef exgcd(a, b):\n    if b == 0: \n        return 1, 0\n    x, y = exgcd(b, a % b)\n    return y, x - y*(a // b)\nans = (exgcd(a, p)[0] % p + p) % p # 求a关于p的逆元\n```\n\n### 费马小定理\n\n费马小定理可用于在**p为素数**时互质的情况下求$a \\bmod p$的逆元。\n\n#### 过程\n\n由费马小定理， 当p为素数且a、p互质时， $a^{p-1} \\equiv 1(\\mod p)$, 而a和a的逆元x满足$ax \\equiv 1(\\mod p)$， 即$a^{p-1} \\equiv ax(\\mod p) \\iff x \\equiv a^{p-2}(\\mod p)$.\n\n所以在满足上述条件时， $a (mod \\ p)$的逆元即为$a^{p-2}(\\mod p)$, 使用快速幂计算即可。\n\n**python**\n\n#### 代码实现\n\n```python\ndef quick_pow(a, n, p):\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a % p\n        a = a * a % p\n        n >>= 1\n    return ans\nans = quick_pow(a, p - 2, p) # 求a关于p的逆元\n```\n\n### 线性求逆元(递推)\n\n递推法用于求`[1, a]`区间的每个数`mod p`的逆元。\n\n#### 过程\n\n$p \\% a = p - a\\lfloor \\frac{p}{a} \\rfloor$ \\ \n\n$\\Rightarrow p\\%a \\equiv - a\\lfloor \\frac{p}{a} \\rfloor (mod \\ p)$ \\ \n\n$\\Rightarrow a \\equiv (p\\%a) \\ / \\ (-\\lfloor \\frac{p}{a} \\rfloor) (mod \\ p)$\\ \n\n$\\Rightarrow a^{-1} \\equiv -\\lfloor \\frac{p}{a} \\rfloor (p\\%a)^{-1}(mod \\ p)$\\ \n\n所以有递推式$inv[n] \\equiv -\\lfloor \\frac{p}{n} \\rfloor * inv[p \\% n] \\ (mod \\ p)$; 而对于始项1，事实上， 对于任意整数p， 都有$1 * 1 \\equiv 1(mod \\ p)$ .\n\n#### 代码实现\n**c++**\n\n```cpp\ninv[1] = 1;\nfor (int i = 2; i <= n; ++i) {\n  inv[i] = (long long)(p - p / i) * inv[p % i] % p;\n}\n```\n\n## 参考\n\n[乘法逆元的几种计算方法 | Menci's OI Blog](https://oi.men.ci/mul-inverse/)\n\n[乘法逆元 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/inverse/)\n\n[乘法逆元详解 - MJT12044 - 博客园 (cnblogs.com)](https://www.cnblogs.com/mjtcn/p/7241896.html)","tags":["乘法逆元","扩展欧几里得算法","费马小定理","快速幂","递推"],"categories":["数论","乘法逆元"]},{"title":"欧几里得算法和扩展欧几里得算法","url":"/posts/5040/","content":"\n## 欧几里得算法\n\n> 在[数学](https://zh.wikipedia.org/wiki/数学)中，**辗转相除法**，又称**欧几里得算法**（英语：Euclidean algorithm），是求[最大公约数](https://zh.wikipedia.org/wiki/最大公约数)的[算法](https://zh.wikipedia.org/wiki/算法)。辗转相除法首次出现于[欧几里得](https://zh.wikipedia.org/wiki/欧几里得)的《[几何原本](https://zh.wikipedia.org/wiki/几何原本)》（第VII卷，命题i和ii）中，而在[中国](https://zh.wikipedia.org/wiki/中国)则可以追溯至[东汉](https://zh.wikipedia.org/wiki/东汉)出现的《[九章算术](https://zh.wikipedia.org/wiki/九章算术)》。\n\n### 过程\n\n欧几里得算法基于一个非常简单的原理：对于两个数a和b(a > b)， a和b的最大公约数与b和a - b的最大公约数相同。\n\n<!--more-->\n\n重复的迭代这个过程， 使$gcd(a, b) \\iff gcd(b, a - b)$. 如此一来， 参数不断减小， 最后某时刻两个参数的值必然相等， 此时a、b的值即为最大公约数.\n\n### 减运算代码实现\n```python\ndef gcd(a, b):\n    if b == a: # 或 if b == 0, 因为b == a时再迭代一次后必然是gcd(a, 0)\n        return a\n    if a < b:\n        return gcd(b, a)\n    return gcd(a - b, b)\n```\n\n![欧几里得算法过程](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/1571057712-3c62fade32895aa.gif)\n\n### 模运算\n但一般情况下， 我们会使用模运算来减少迭代的次数。\n\n设a(a > b)设为`a = kb + c， c < b`， 则用减法的欧几里得迭代过程的前面一部分显然是\n$$\ngcd(kb + c, b) \\iff gcd((k - 1)b + c, b) \\iff ...\\iff gcd(c, b)\n$$\n上述过程可以简化为\n$$\ngcd(a, b) \\iff gcd(a \\% b, b)\n$$\n由此我们可以写出用模运算代替减法运算的代码\n\n### 模运算代码实现\n\n**python**\n```python\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n```\n\n**c++**\n```cpp\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n```\n一个比较巧妙的点是， 如果a < b， 则$gcd(a, b) \\iff gcd(b, a \\% b) \\iff gcd(b, a）$, 通过一次递归调整回了第一个参数较大的情况。\n\n模运算的迭代过程相比减运算是跳跃式的， 所以不一定会经过a==b这个状态， 因此应该以b=0为结束条件。\n\n欧几里得算法的时间复杂度为$O(logn)$, 因为对于a、b(a > b)， a %= b至少会让a减少一半以上。\n\n## 扩展欧几里得算法\n\n### 裴属定理\n\n> 裴属定理：对于任意整数a、b， 都能找到两个整数x、y使得`ax + by = gcd(a, b)`. \n\n设a、b的最大公约数为c， 则有`a = i * c, b = j * c`, 且i、j互质。所以裴属定理的另一种形式是：对于两个互质的整数a、b， 都能找到两个整数x、y使得`ax + by = 1`。\n\n### 过程\n扩展欧几里得算法常用于寻找裴属定理的一组可行解。\n\n设$ax_1 + by_1 = gcd(a, b)$, $x_1$和$y_1$就是我们要求的解。\n\n在欧几里得算法中， 如果要求$gcd(a, b)$， 会递归的求$gcd(b, a \\% b)$.\n\n设$bx_2 + (a \\% b)y_2 = gcd(b, a\\%b)$.\n\n$\\because \\ $$gcd(a, b) = gcd(b, a\\%b)$\n\n$\\therefore \\ ax_1 + by_1 = bx_2 + (a \\% b)y_2$\n\n又$\\because \\ a \\% b = a - b * \\lfloor \\frac{a}{b} \\rfloor$\n\n\n\n$\\therefore \\ ax_1 + by_1 = bx_2 + (a \\% b)y_2 = bx_2 + (a - b * \\lfloor\\frac{a}{b} \\rfloor )y_2$\n\n化简得$ax_1 + by_1 = ay_2 + b(x_2 - y_2)\\lfloor\\frac{a}{b} \\rfloor$, 所以$x_1 = y_2, y_1 = x_2 - y_2\\lfloor\\frac{a}{b} \\rfloor$.\n\n要求$x_1, y_1$， 只需先递归的求出$x_2, y_2$即可。\n\n在欧几里得算法的递归终点$gcd(c, 0)$中, 要使$cx_3 + 0y_3 = gcd(c, 0) = c$, 一组可行的解是$x_3 = 1, y_3 = 0$。到达终点后， 不断回溯对$(x, y)$进行递推， 最后即可得到关于$(a, b)$的一组可行解。\n\n### 代码实现\n\n**python**\n```python\ndef exgcd(a, b):\n    if b == 0: \n        return 1, 0\n    x, y = exgcd(b, a % b)\n    return y, x - y*(a // b)\n```\n\n**c++**\n\n```cpp\nvoid exgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1, y = 0;\n    } else {\n        exgcd(b, a % b, x, y);\n        int t = x;\n        x = y, y = t - y * (a / b);\n    }\n}\n```\n\n## 参考\n\n[辗转相除法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/輾轉相除法)\n\n[小知识：什么是「欧几里得算法」_吴师兄学算法 (cxyxiaowu.com)](https://www.cxyxiaowu.com/995.html)\n\n[最大公约数 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/gcd/)\n\n[裴蜀定理_百度百科 (baidu.com)](https://baike.baidu.com/item/裴蜀定理?fromModule=lemma_search-box#9)\n\n[扩展欧几里得算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/扩展欧几里得算法)","tags":["最大公约数","裴属定理"],"categories":["数论","最大公约数"]},{"title":"素性检验","url":"/posts/42331/","content":"## 背景\n在知乎上冲浪时了解到一种很有趣的数：其所有非空后缀均为素数的数。\n例如`9613`, 其后缀`[9613, 613, 13, 3]`均为素数.\n而此类数的最大值为`357686312646216567629137`.\n\n证明方法非常直接:用计算机枚举. \n不妨为此类数随意的取个名叫做`后缀素数`, 不难发现, 后缀素数P的后缀必然是后缀素数. 因此对于长度为`N`的后缀素数必然可以由 最高位 和 一个长度为`N-1`的后缀素数拼接而成, 如9613可以由是9和613拼接.\n\n<!--more-->\n\n因此我们可以从一位的后缀素数集`[2, 3, 5, 7]`开始, 通过 枚举最高位 + 判断是否为素数, 得到下一级位数的所有后缀素数. 若N位的后缀素数集为空, 则最大的后缀素数就存在于N-1位的后缀素数中.\n\n\n\n## 冲突\n程序的实现可以分为两部分: 判断素数, 循环递推后缀素数.\n\n程序测试时, 等待了几分种仍然没有结果, 这时我才意识到可能程序的时间复杂度太高.我写的判断素数的函数使用的是非常普通的$O(\\sqrt{n})$级别的算法, 在我们已经知道`357686312646216567629137`为答案的情况下, $O(\\sqrt{n})$的算法得出结果或许需要几个小时.此时显然需要更高效的素数判断算法.\n\n## 素性检验\n素性检验是一种概率性检验一个数是否是素数的算法, 换句话说, 素性检验只能得出两种结果: 一个数不是素数 或 一个数大概率是个素数.\n\n\n\n### 费马素性检验(Fermat primality test)\n\n\n\n**费马小定理**\n\n若p是素数, a与p互质, 则 $a^{p-1} \\equiv 1(mod \\ p)$\n\n[维基百科上易懂的证明:](https://zh.wikipedia.org/wiki/费马小定理)\n\n> （i）若$a$是整数，$p$是质数，且$\\gcd(a,p)=1$。若$p$不能整除$x-y$，则$p$不能整除$a(x-y)$。取整数集$A$为所有小于$p$的正整数[集合](集合_(数学) \"wikilink\")（$A$构成$p$的完全剩余系，即$A$中不存在两个数同余$p$），$B$是$A$中所有的元素乘以$a$组成的集合。因为$A$中的任何两个元素之差都不能被$p$整除，所以B中的任何两个元素之差也不能被$p$整除。\n>\n> 换句话说，$\\gcd(a,p)=1$，考虑$1\\times a, 2\\times a, 3\\times a,....(p-1)\\times a$共$(p-1)$个数，將它们分別除以p，除数分別为$r_1,r_2,r_3,....,r_{p-1}$，則集合{r~1~,r~2~,r~3~,\\...,r~p-1~}为集合{1,2,3,\\...,(p-1)}的重新排列，即1,2,3,\\....,(p-1)在除数中恰好各出現一次；这是因为对于任兩个相异k\\*a而言（k=1,2,3\\....(p-1)），其差不是p的倍数（所以不会有相同除数），且任一个k\\*a亦不为p的倍数（所以除数不为0）。因此\n>\n> $$1 \\cdot 2 \\cdot 3 \\cdot \\dots \\cdot (p-1) \\equiv(1 \\cdot a)\\cdot(2 \\cdot a)\\cdot\\dots\\cdot((p-1) \\cdot a) \\pmod{ p},$$\n> 即\n>\n> $$W \\equiv W\\cdot a^{p-1} \\pmod{p},$$\n>\n> 在这里W=1·2·3·\\...·(p\\*1)，且(W, p) =\n> 1，因此将整个公式除以W即得到：\n>\n> $$a^{p-1} \\equiv 1 \\pmod{p}$$\n>\n> 也即 $a^p \\equiv a \\pmod{p}$\n>\n> （ii）若$p$整除$a$，则显然有$p$整除$a^{p}$，即$a^p \\equiv a\\equiv 0 \\pmod{p}$。\n\n**费马伪素数(Fermat pseudoprime)**\n\n对于某些合数x,可以找到与其互质的数a且满足$a^{x-1} \\equiv 1(mod / x)$, 则称合数x为*费马伪素数*, a为x的基. 最小的费马伪素数是341, 以2为基, $2^{340} \\equiv 1(mod \\ 341)$\n\n对于任意大于1的自然数a, 都有无限个以a为基的费马伪素数.\n\n这也说明, 费马小定理的反面是不成立的, 即使对于x能找到a满足同余式, x也不一定是素数.\n\n\n\n**卡迈克尔数(Carmichael number)**\n\n卡迈克尔数是费马小定理反面严格不成立的特例. 卡迈克尔数是正合数x, 且使任意与x互质的数a都满足$a^{x-1} \\equiv 1(mod \\  x)$.最小的卡迈克尔数是561.\n\n---\n\n根据费马小定理, 我们知道, 对于数x, 如果一个数a与x互质, 且$a^{x - 1} \\not\\equiv 1(mod \\ x)$, 则说明x不是一个素数, 将这样的a称为x是合数的凭证(witness).反之, a称为x是素数的强伪证(strong liar).\n\n为了检验x是否是素数, 我们可以选择若干个与x互质的数a, 判断是否$a^{x - 1} \\equiv 1(mod \\ x)$, 若都满足等于1, 则可以说x有可能是素数.\n\n$a$通常在区间`[2, x-1]`中进行选取, 此区间中的数显然都与x互质.\n\npython代码实现如下:\n\n```python\ndef fermat(x, test_time = 8):\n    # 小于3的数直接特判\n    if x <= 2:\n        return x == 2\n    for i in range(1, test_time + 1):\n        a = randint(2, x - 1)\n        # quick_pow为快速幂\n        if quick_pow(a, x - 1, x) != 1:\n            return False\n    return True\n```\n\n### 米勒-拉宾素性检验(Miller–Rabin primality test)\n\n当检验的数据范围增大时, 费马素性检验的正确率就满足不了人们的需求了.\n\n\n\n**二次探测定理**\n\n如果$p$是奇素数, 则$x^2 \\equiv 1(mod \\ p)$的解为$x \\equiv 1(mod \\ p)$或$x \\equiv -1(mod / p)$.\n\n特别的, 其小于p的解为$x \\equiv 1(mod \\ p)$或$x \\equiv p-1(mod \\ p)$\n\n> 特别提出其小于p的解是因为, 在诸多编程语言中, 模的结果不会取负数.\n\n证明:\n\n$$x^2 \\equiv 1(mod \\ p) \\iff (x + 1)(x - 1) \\equiv 0(mod \\ p) $$\n\n---\n\n前面我们知道, 在`[2, x-1]`取一数a, 如果$a^{x - 1} \\equiv 1(mod \\ x)$, 并不能说明x一定是素数, Miller-Rabin素性检验正是在这一步做进一步的纵深, 提高正确率.\n\n设`[a, x]`已经通过了费马检验, 即$a^{x - 1} \\equiv 1(mod \\ x)$, 且x不为偶数(特判2因子).\n\n由于x - 1是偶数, 所以可以转化为二次探测的格式:$a^{x - 1} \\equiv 1(mod \\ x) \\iff (a^{\\frac{x - 1}{2}})^2 \\equiv 1(mod \\ x)$.\n\n我们的目标是检验x是否是素数, 所以根据二次探测定理, 可以判断是否满足$a^{\\frac{x - 1}{2}} \\equiv 1(mod \\ x)$或$a^{\\frac{x - 1}{2}} \\equiv x-1(mod \\ x)$\n\n这时候会有三种结果:\n\n* 不符合二次探测定理, 此时可以断定x不为素数\n* $a^{\\frac{x - 1}{2}} \\equiv 1(mod \\ x)$. 如果$\\frac{x - 1}{2}$不是奇数, 则模仿前面的过程, 进行二次探测检验($a^{\\frac{x - 1}{4}}$);如果是奇数, 停止检验.\n* $a^{\\frac{x - 1}{2}} \\equiv x - 1(mod \\ x)$, 停止检验\n\npython程序实现如下:\n\n```python\ndef miller_rabin(x, test_time = 8):\n    if x < 3 | (x & 1):\n        return x == 2\n    for i in range(1, test_time + 1):\n        a = randint(2, x - 1)\n        # 费马小定理检验\n        if quick_pow(a, x - 1, x) != 1:\n            return False\n        # 二次探测定理检验\n        y = x - 1\n        while y % 2 == 0:\n            y //= 2\n            z = quick_pow(a, y, x)\n            if z == x - 1:\n                break\n            elif z != 1:\n                return False\n    return True   \n```\n\n## 验证\n\n回到最初的问题上, 现在我们已经有时间复杂度足够低($log^3n$)的算法来判断一个数是否是素数.\n\n后缀素数的递推代码如下:\n\n```python\nstart = time.time()\nprimes = [2, 3, 5, 7]\nj = 10\nwhile True:\n    new = []\n    for x in primes:\n        for i in range(1, 10):\n            a = i * j + x\n            if (miller_rabin(a)):\n                new.append(a)\n    if len(new) == 0:\n        print(\"answer:\", primes)\n        break\n    j *= 10\n    primes = new\nend = time.time()\nprint('time cost', end - start, 's')\n```\n\n运行结果如下:\n\n![运行结果](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230125211153759.png)\n\n## 参考\n\n[米勒-拉宾素性检验 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/米勒-拉宾检验)\n\n[【朝夕的ACM笔记】数论-Miller Rabin素数判定 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/349360074)\n\n[卡迈克尔数 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/卡邁克爾數)\n\n[Fermat pseudoprime - Wikipedia](https://en.wikipedia.org/wiki/Fermat_pseudoprime)\n\n[算法学习笔记(48): 米勒-拉宾素性检验 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/220203643)\n\n[费马素性检验 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/费马素性检验)","tags":["费马小定理","素数","数论","二次探测定理"],"categories":["数论","素数"]},{"title":"欧拉图","url":"/posts/29020/","content":"> 欧拉通路(路径): 一条经过了图中所有边的路径， 且每条边仅经过一次。\n> 欧拉回路: 起点和终点相同的欧拉通路。\n> 欧拉图: 存在欧拉回路的图\n> 半欧拉图: 不存在欧拉回路， 但存在欧拉通路的图\n\n之所以以欧拉的名字命名， 是因为欧拉解决了与此紧密相关的**一笔画问题**， 即在不重复、折返的情况下遍历一张无向图。\n\n![欧拉图示例](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/Euler-3.jpg)\n\n<!--more-->\n\n### 判别欧拉图\n\n欧拉图的判断可以使用欧拉提出的“一笔画定理”。\n\n\n\n> 连通的无向图有欧拉路径的充要条件是：![G](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b)中奇顶点（连接的边数量为奇数的顶点）的数目等于0或者2。\n>\n> 连通的无向图是欧拉图（存在欧拉回路）的充要条件是：中每个顶点的度都是偶数。\n\n证明可见:[一笔画问题 - 维基百科](https://zh.wikipedia.org/wiki/一笔画问题)\n\n#### 例题——欧拉路径\n> 判断一无向图是欧拉图、半欧拉图还是非欧拉图\n>  **输入格式**\n>\n> 第一行包含两个整数 N 和 M，表示无向图的点和边的数量。\n>\n> 接下来 M 行，每行包含两个整数 a,b，表示点 a 和 b 之间存在一条边。\n>\n> 所有点的编号从 **1∼N**。\n>\n> **输出格式**\n> 输出对该图的判断，`Eulerian`（欧拉图），`Semi-Eulerian`（半欧拉图），`Non-Eulerian`（非欧拉图）。\n>\n> 行尾不得有多余空格。\n\n**代码实现**\n\n* 使用并查集判断图是否连通\n* 构造顶点的度数组， 用于判断欧拉图\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510;\nint p[N], d[N];\nint n, m;\n\nint find(int x) {\n    if (x == p[x]) return x;\n    return p[x] = find(p[x]);\n}\n\n//使用并查集判断图是否连通\nbool isConnected() {\n    for (int i = 2; i <= n; i ++) {\n        if (find(i) != find(1)) return false;\n    }\n    return true;\n}\n\n//判断图中是否有欧拉路径\nbool hasEulerianPath() {\n    int odd = 0;\n    for (int i = 1; i <= n && odd <= 2; i ++) {\n        if (d[i] & 1) odd ++;\n    }\n    return odd == 0 || odd == 2;\n}\n\n//判断图中是否有欧拉回路\nbool hasEulerianCircuit() {\n    for (int i = 1; i <= n; i ++) {\n        if (d[i] & 1) return false;\n    }\n    return true;\n}\n\nint main () {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) p[i] = i;\n    while (m --) {\n        int a, b; cin >> a >> b;\n        d[a] ++, d[b] ++;\n        p[find(a)] = find(b);\n    }\n    \n    if (!isConnected()) cout << \"Non-Eulerian\";\n    else if (hasEulerianCircuit()) cout << \"Eulerian\";\n    else if (hasEulerianPath()) cout << \"Semi-Eulerian\";\n    else cout << \"Non-Eulerian\";\n    \n    return 0;\n}\n\n```\n\n### 求欧拉回路\n\n求欧拉回路一般使用**Hierholzer**算法。\n\n*Hierholzer算法*的基本流程如下：\n\n* 从任一点开始对图进行dfs遍历\n* 遍历过程中经过的边直接删除\n* 当一个顶点的出度减为0时， 加入栈中\n* dfs结束后， 将栈中元素出栈， 即为一条欧拉回路\n\n伪代码即为：\n\n```cpp\ndfs(node u) {\n    while (!u.edges.empty()) {\n        node next = u.edges.back();\n        u.edges.pop_back();\n        dfs(next);\n    }\n    stk.push(u);\n}\n```\n\n性质一： dfs的起点就是得到的欧拉回路的起点\n\n性质二： 若要求从某起点出发、字典序最小的欧拉回路， 只需要在遍历边时贪心的选择顶点编号最小的边即可， 可以使用排序或优先队列。\n\n#### 例题——重新安排行程\n\n> 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n>\n> 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n>\n> 例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前。\n> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n>\n> 来源：力扣（LeetCode）\n> 链接：https://leetcode.cn/problems/reconstruct-itinerary\n> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n> \n\n**Solution**\n显然这题是有向边求字典序最小的的欧拉回路。\n由于顶点是用字符串代表， 所以用哈希表记录每个顶点的出边集。\n预先对出边集排序， 在遍历时看最小的出边。\n\n```cpp\nclass Solution {\npublic:\n    map<string, vector<string>> e;\n    vector<string> stk;\n\n    void dfs(string u) {\n        while (e[u].size()) {\n            string ne = e[u].back(); e[u].pop_back();\n            dfs(ne);\n        }\n        stk.push_back(u);\n    }\n\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        for (auto &v : tickets) {\n            e[v[0]].push_back(v[1]);\n        }\n        for (auto &[s, v] : e) {\n            sort(v.begin(), v.end(), greater<>());\n        }\n        dfs(\"JFK\");\n        reverse(stk.begin(), stk.end());\n        return stk;\n    }\n};\n```","tags":["一笔画","dfs"],"categories":["图论"]},{"title":"矩阵快速幂","url":"/posts/25991/","content":"\n来聊聊如何将快速幂的思想应用到矩阵乘法上， 以及矩阵快速幂的应用。\n\n## 矩阵快速幂\n\n### 矩阵乘法\n\n在线性代数中学过， n行x列的矩阵A与x行m列的矩阵B是可以相乘的， 结果为一个n行m列的矩阵R， 且$R_{ij} = \\sum^{x}_{k = 1} A_{ik} * B_{kj}$.\n\n而对于方阵$M_{nn}$, 又有**幂**的概念， $M^n = M * M * M * ... * M$, 即n个M矩阵相乘.\n\n<!--more-->\n\n由此我们可以定义矩阵类型， 并实现矩阵乘法。\n\n```c++\n#define N 2\nstruct matrix {\n    int m[N][N];\n\n    matrix() {\n        memset(m, 0, sizeof(m));\n    }\n\n    matrix operator * (const matrix& b) const {\n        matrix res;\n        for (int i = 0; i < N; i ++) \n            for (int j = 0; j < N; j ++) \n                for (int k = 0; k < N; k ++)\n                    res.m[i][j] += m[i][k] * b.m[k][j];\n        return res;\n    }\n};\n```\n\n\n\n### 快速幂思想\n\n快速幂的细节不多说， 简单说快速幂的思想， 就是： 计算$a^n$时， 可以先计算$a^{\\frac{n}{2}}$, 再用$a^{\\frac{n}{2}} * a^{\\frac{n}{2}}$得到$a^n$。\n\n可以发现， 计算$a^n$只比$a^{\\frac{n}{2}}$多了一次（若n为奇数还要多一次), 相比于暴力做法(n / 2次)优秀很多， 而时间复杂度也从$O(n)$优化为$O(logn)$。\n\n### 矩阵快速幂\n\n我们可以套用快速幂的模板， 写出矩阵快速幂的代码。\n\n```cpp\nmatrix qpow(matrix a, int p) {\n    matrix res;\n    for (int i = 0; i < N; i ++) res.m[i][i] = 1; //单位矩阵\n    while (p) {\n        if (p & 1) res = res * a;\n        a = a * a;\n        p >>= 1;\n    }\n    return res;\n}\n```\n\n到此， 矩阵快速幂的实现就完成了。\n\n## 矩阵快速幂的应用\n\n### 典中典——斐波那契数列\n\n假设有这样一个问题：对于整数n， $n \\in (1, 1e9)$， 在1s内求出斐波那契数列的第n项模p的结果。\n\n显然常规$O(n)$做法是行不通的。\n\n斐波那契数列我们都知道存在关系式$f_n = f_{n-1} + f_{n-2}$, 那我们能否通过构造多项式， 将$f_n$和$f_1$联系起来， 得到一个公式呢？倘若这样， 才有可能在$O(n)$内完成。\n\n将$f_n和f_{n-1}$设为一个行向量， 则\n$$\n\\begin{pmatrix}\nf_n \\ f_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{n-1}+f_{n-2}\\ \\ f_{n-1}\n\\end{pmatrix}\n$$\n\n\n是否能通过$(f_{n-1} \\ f_{n-2})$来表示$(f_n \\ f_{n-1})$呢？\n\n可以发现\n$$\n\\begin{pmatrix}\nf_n\\\nf_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{n-1} + f_{n-2}\\ \nf_{n-1}\n\\end{pmatrix}\n =\n \\begin{pmatrix}\nf_{n-1}\\ \nf_{n-2}\n\\end{pmatrix}\n* \n \\begin{pmatrix}\n1\\  0 \\\\\n1 \\ 1\n\\end{pmatrix}\n$$\n将$f_{n-1}, f_{n-2}$看作自变量， 则$1 \\ 0 \\\\1 \\ 1$即为$(f_n, f_n-1)$的系数矩阵.\n\n由此递推可得\n$$\n\\begin{pmatrix}\nf_n\\\nf_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_1\\\nf_0\n\\end{pmatrix}\n*\n{\\begin{pmatrix}\n1\\  0 \\\\\n1 \\ 1\n\\end{pmatrix}}^{n-1}\n$$\n所以我们的主要任务就是算出此系数矩阵的n-1次幂，也就可以用上述提到的矩阵快速幂， 这样即使n是$10^9$也不会超时。 \n\n","tags":["快速幂","矩阵乘法"],"categories":["算法"]},{"title":"高精度模板","url":"/posts/61750/","content":"\n最近发现了一个很有意思的网站：codewars， 上面有很多有趣的'kata'， 通过kata可以提升你的段位。\n\ncodewars上的题目和传统的竞赛题目的风格不太一样， 而且用户是可以创建kata的， 这一点我觉得很有意思。\n\n在codewars中老是遇到高精度的题目(高精度在普通OJ中基本只有模板题)， 每次都要手写及处理细节十分的腻，于是决定把高精度好好的写一遍记录下来， 供未来copy。\n\n<!--more-->\n\n## 高模板模板类\n\n包含：\n\n* 高精度加高精度\n* 高精度减高精度\n* 高精度乘低精度\n* 高精度乘高精度\n* 高精度除以低精度\n* 高精度除以高精度\n\n```cpp\nnamespace BigNumber {\n    static string reversed(string &s) {//反转字符串并返回\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    static bool comp(string a, string b) {//判断a大于等于b\n        if (a.size() != b.size()) return a.size() > b.size();\n        return a > b || a == b;\n    }\n\n    static string add(string a, string b) {//高精度加高精度\n        string ans;\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry) {\n            if (i >= 0) carry += a[i--] - '0';\n            if (j >= 0) carry += b[j--] - '0';\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static string subtract(string a, string b) {//高精度减高精度\n        if (!comp(a, b)) return \"-\" + subtract(b, a);\n        string ans;\n        int n = a.size(), m = b.size(), carry = 0;\n        for (int i = n - 1, j = m - 1; i >= 0; i--, j--) {\n            carry += a[i] - '0';\n            if (j >= 0) carry -= b[j] - '0';\n            if (carry < 0) ans.push_back(carry + 10 + '0'), carry = -1;\n            else ans.push_back(carry + '0'), carry = 0;\n        }\n        while (ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return reversed(ans); \n    }\n\n    \n    template<typename T>\n    static string multiply(string s, T b) {//高精度乘以低精度\n        if (b == 0) return \"0\";\n        reversed(s);\n        string ans;\n        for (T i = 0, carry = 0; i < s.size() || carry; i++) {\n            if (i < s.size()) carry += (s[i] - '0') * b;\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static string multiply(string a, string b) {//高精度乘以高精度\n        reversed(a), reversed(b);\n        vector<int> ans(a.size() + b.size(), 0);\n        for (int i = 0; i < a.size(); i ++) \n            for (int j = 0; j < b.size(); j ++)\n                ans[i + j] += (a[i] - '0')  *(b[j] - '0');\n        int carry = 0; string res;\n        for (int i = 0; i < ans.size(); i ++) {\n            ans[i] += carry, carry = ans[i] / 10, ans[i] %= 10;\n            res.push_back(ans[i] + '0');\n        }\n        while(res.back() == '0' && res.size() > 1) res.pop_back();\n        return reversed(res);\n    }\n    \n    template<typename T>\n    static pair<string, T> divide(string a, T b) {//高精度除以低精度\n        if (b == 0) return {\"ERROR\", 0};\n        T r = 0;\n        string ans;\n        for (int i = 0; i < a.size(); i ++) {\n            r = r * 10 + a[i] - '0';\n            ans.push_back(r / b + '0'), r %= b;\n        }\n        reversed(ans);\n        while(ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return {reversed(ans), r};\n    }\n\n    static pair<string, string> divide(string a, string b) {//高精度除以高精度， 复杂度较高\n        if (b == \"0\") return {\"ERROR\", \"ERROR\"};\n        if (!comp(a, b)) return {\"0\", a};\n        int t = a.size() - b.size();\n        string ans;\n        for (int i = 0; i < t; i ++) b.push_back('0');\n        while (t >= 0) {\n            int cnt = 0;\n            while(comp(a, b)) a = subtract(a, b), cnt++;\n            ans.push_back(cnt + '0');\n            b.pop_back();\n            t--;\n        }\n        reversed(ans);\n        if (ans.back() == '0') ans.pop_back();\n        return {reversed(ans), a};\n    }\n}\n```\n\n## 实例 [codewars](https://www.codewars.com/kata/58a3fa665973c2a6e80000c4/) 2kyu--Challenge Fun #10: Integer Square Root\n\n> ### Task\n>\n> For each given a number N, the integer S is called `integer square root` of N if `S x S <= N` and `(S+1) x (S+1) > N`.\n>\n> In other words, `S = Math.floor(Math.sqrt(N))`\n>\n> Your task is to calculate the `integer square root` of a given `Number`.\n>\n> Note: Input is given in string format. That is, the `Number` may be very very large ;-)\n>\n> ### Example\n>\n> For: `Number = \"4\"`, result = `\"2\"`.\n>\n> For: `Number = \"17\"`, result = `\"4\"`.\n>\n> For: `Number = \"101\"`, result = `\"10\"`.\n>\n> For: `Number = \"23232328323215435345345345343458098856756556809400840980980980980809092343243243243243098799634\"`, result = `\"152421548093487868711992623730429930751178496967\"`.\n>\n> ### Input/Output\n>\n> - `[input]` string `Number`\n>\n> number in decimal form. \n>\n> 0 < Number < 10^100^\n>\n> - `[output]` a string\n>\n> integer squareroot of `Number`.\n\n显然是一道高精度二分， 调用模板完成即可。\n\n```cpp\nusing namespace BigNumber;\nstring integer_square_root(string n) {\n  string l = \"0\", r = n;\n  while (!comp(l, r)) {\n    auto [mid, rem] = divide(add(add(l, r), \"1\"), 2);\n    if (comp(n, multiply(mid, mid))) l = mid;\n    else r = subtract(mid, \"1\");\n  }\n  return l;\n}\n```\n\n## C++大数类模板\n\n我们可以模仿java的`BigInteger`类， 写一个c++类来模拟正常的整数的各种运算。\n\n由于c++的重载运算符功能， 我们可以做到和原生几乎没有使用区别。\n\n以下是尝试性的实现。\n\n```c++\n//\n// Created by trudbot on 2023/1/19.\n//\n\n#include \"iostream\"\n#include \"string\"\n#include \"algorithm\"\n#include \"map\"\n\nclass BigInteger {\npublic:\n    BigInteger() {}\n\n    BigInteger(long long num) {\n        if (num < 0) {\n            this->data = std::to_string(num).substr(1);\n            this->sign = -1;\n        } else {\n            this->data = std::to_string(num);\n            this->sign = 1;\n        }\n    }\n\n    BigInteger(std::string num) {\n        if (num[0] == '-') {\n            this->data = num.substr(1);\n            sign = -1;\n        } else {\n            this->data = num;\n            sign = 1;\n        }\n    }\n\n    BigInteger(const std::string& num, int sign) {\n        this->data = num, this->sign = sign;\n    }\n\n    BigInteger operator+(const BigInteger& b) const {\n        BigInteger ans;\n        if (this->sign == 1 && b.sign == 1) {\n            ans = BigInteger(add(this->data, b.data), 1);\n        } else if (this->sign == 1 && b.sign == -1) {\n            ans = BigInteger(subtract(this->data, b.data));\n        } else if (this->sign == -1 && b.sign == 1) {\n            ans = BigInteger(subtract(b.data, this->data));\n        } else {\n            ans = BigInteger(add(this->data, b.data), -1);\n        }\n        return ans;\n    }\n\n    BigInteger operator+(long long & b) const {\n        return this->operator+(BigInteger(b));\n    }\n\n    BigInteger operator-(const BigInteger &b) const {\n        BigInteger ans;\n        if (this->sign == 1 && b.sign == 1) {\n            ans = BigInteger(subtract(this->data, b.data));\n        } else if (this->sign == 1 && b.sign == -1) {\n            ans = BigInteger(add(this->data, b.data));\n        } else if (this->sign == -1 && b.sign == 1) {\n            ans = BigInteger(add(this->data, b.data), -1);\n        } else {\n            ans = BigInteger(subtract(b.data, this->data));\n        }\n        return ans;\n    }\n\n    BigInteger operator*(const BigInteger &b) {\n        return BigInteger(multiply(this->data, b.data), this->sign * b.sign);\n    }\n\n    BigInteger operator/(const BigInteger &b) {\n        if (lessEqual(b.data, limit)) {\n            return BigInteger(divide(this->data, std::stoll(b.data)).first, this->sign * b.sign);\n        }\n        return BigInteger(divide(this->data, b.data).first, this->sign * b.sign);\n    }\n\n    BigInteger operator%(const BigInteger &b) const {\n        return BigInteger(divide(this->data, b.data).second);\n    }\n\n    void operator*=(const BigInteger &b) {\n        this->sign *= b.sign;\n        this->data = multiply(this->data, b.data);\n    }\n\n    void operator/=(const BigInteger &b) {\n        this->sign *= b.sign;\n        if (lessEqual(b.data, limit)) {\n            this->data = divide(this->data, std::stoll(b.data)).first;\n        } else {\n            this->data = divide(this->data, b.data).first;\n        }\n    }\n\n    void operator++() {\n        *this = *this + 1;\n    }\n\n    void operator--() {\n        *this = *this - 1;\n    }\n\n    BigInteger& operator=(const BigInteger& b) {\n        this->data = b.data, this->sign = b.sign;\n        return *this;\n    }\n\n    template<typename T>\n    BigInteger& operator=(const T& b) {\n        *this = BigInteger(b);\n        return *this;\n    }\n\n    bool operator==(const BigInteger &b) {\n        return this->sign == b.sign && this->data == b.data;\n    }\n\n    bool operator<(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return true;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return less(this->data, b.data);\n        } else {\n            return greater(this->data, b.data);\n        }\n    }\n\n    bool operator>(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return false;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return greater(this->data, b.data);\n        } else {\n            return less(this->data, b.data);\n        }\n    }\n\n    bool operator<=(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return false;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return true;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return lessEqual(this->data, b.data);\n        } else {\n            return greaterEqual(this->data, b.data);\n        }\n    }\n\n    bool operator>=(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return false;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return greaterEqual(this->data, b.data);\n        } else {\n            return lessEqual(this->data, b.data);\n        }\n    }\n\n    bool operator!=(const BigInteger &b) {\n        return this->sign != b.sign || this->data != b.data;\n    }\n\n    friend std::ostream &operator<<(std::ostream &output, const BigInteger &integer) {\n        if (integer.sign == -1) {\n            output << \"-\" << integer.data;\n        } else {\n            output << integer.data;\n        }\n        return output;\n    }\n\n    friend std::istream &operator>>(std::istream  &input, BigInteger &integer) {\n        std::string s;\n        input >> s;\n        integer = BigInteger(s);\n        return input;\n    }\n\n    BigInteger pow(long long n) {\n        BigInteger res = 1, a = *this;\n        while (n) {\n            if (n & 1) res = res * a;\n            a = a * a;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    std::string value() {\n        return this->data;\n    }\n\nprivate:\n    std::string data;\n    int sign = 0;\n    const std::string limit = \"9223372036854775807\";\n\n    static std::string reversed(std::string &s) {//反转字符串并返回\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    static bool greaterEqual(const std::string& a, const std::string& b) {//判断a大于等于b\n        return greater(a, b) || a == b;\n    }\n\n    static bool less(const std::string& a, const std::string& b) {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n\n    static bool greater(const std::string& a, const std::string& b) {\n        if (a.size() != b.size()) return a.size() > b.size();\n        return a > b;\n    }\n\n    static bool lessEqual(const std::string& a, const std::string& b) {\n        return less(a, b) || a == b;\n    }\n\n    static std::string add(std::string a, std::string b) {//高精度加高精度\n        std::string ans;\n        int i = (int)a.size() - 1, j = (int)b.size() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry) {\n            if (i >= 0) carry += a[i--] - '0';\n            if (j >= 0) carry += b[j--] - '0';\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static std::string subtract(std::string a, std::string b) {//高精度减高精度\n        if (!greaterEqual(a, b)) return \"-\" + subtract(b, a);\n        std::string ans;\n        int n = a.size(), m = b.size(), carry = 0;\n        for (int i = n - 1, j = m - 1; i >= 0; i--, j--) {\n            carry += a[i] - '0';\n            if (j >= 0) carry -= b[j] - '0';\n            if (carry < 0) ans.push_back(carry + 10 + '0'), carry = -1;\n            else ans.push_back(carry + '0'), carry = 0;\n        }\n        while (ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return reversed(ans);\n    }\n\n    static std::string multiply(std::string s, long long b) {//高精度乘以低精度\n        if (b == 0) return \"0\";\n        reversed(s);\n        std::string ans;\n        for (size_t i = 0, carry = 0; i < s.size() || carry; i++) {\n            if (i < s.size()) carry += (s[i] - '0') * b;\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static std::string multiply(std::string a, std::string b) {//高精度乘以高精度\n        reversed(a), reversed(b);\n        int n = a.size() + b.size(), ans[n];\n        for (int i = 0; i < n; i ++) ans[i] = 0;\n        for (int i = 0; i < a.size(); i ++)\n            for (int j = 0; j < b.size(); j ++)\n                ans[i + j] += (a[i] - '0')  *(b[j] - '0');\n        int carry = 0; std::string res;\n        for (int i = 0; i < n; i ++) {\n            ans[i] += carry, carry = ans[i] / 10, ans[i] %= 10;\n            res.push_back(ans[i] + '0');\n        }\n        while(res.back() == '0' && res.size() > 1) res.pop_back();\n        return reversed(res);\n    }\n\n    static std::pair<std::string, long long> divide(const std::string& a, long long b) {//高精度除以低精度\n        if (b == 0) return {\"ERROR\", 0};\n        long long r = 0;\n        std::string ans;\n        for (char i : a) {\n            r = r * 10 + i - '0';\n            ans.push_back(r / b + '0'), r %= b;\n        }\n        reversed(ans);\n        while(ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return {reversed(ans), r};\n    }\n\n    static std::pair<std::string, std::string> divide(std::string a, std::string b) {//高精度除以高精度， 复杂度较高\n        if (b == \"0\") return {\"ERROR\", \"ERROR\"};\n        if (less(a, b)) return {\"0\", a};\n        int t = a.size() - b.size();\n        std::string ans;\n        for (int i = 0; i < t; i ++) b.push_back('0');\n        while (t >= 0) {\n            int cnt = 0;\n            while(greaterEqual(a, b)) a = subtract(a, b), cnt++;\n            ans.push_back(cnt + '0');\n            b.pop_back();\n            t--;\n        }\n        reversed(ans);\n        if (ans.back() == '0') ans.pop_back();\n        return {reversed(ans), a};\n    }\n};\n```\n\n\n\n用此模板， 上面那题的代码可改成\n\n```c++\nusing namespace std;\nusing Int = BigInteger;\n\nstring integer_square_root(string args) {\n  Int n = Int(args);\n  Int l = 0, r = n;\n  while (l < r) {\n    Int mid = (l + r + 1) / 2;\n    if (mid * mid <= n) l = mid;\n    else r = mid - 1;\n  }\n  return l.value();\n}\n```\n\n","tags":["模板","高精度","codewars"]},{"title":"最短路算法","url":"/posts/789/","content":"\n> 最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。\n\n![最短路算法概览](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png)\n\n# 单源最短路\n即对确定的源点（起点）， 求它到其它所有可达的点的最短路径。\n对于单源最短路算法， 又可以分为处理正权边图和带负权边图的两种。\n\n<!--more-->\n\n## 正权图——Dijkstra算法\n\n个人认为对Dijkstra算法的一个很形象的描述是： 将边看作一条条水渠， 边的权为水渠的长度(m)。在源点处倒入水， 假设水的速度恒定为1m/s， 那么**当水首次流到顶点X时， 所经过的时间就是源点到X的最短路径长度。**\n\n以下图举例：\n\n![例图](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n假设从A倒入水， 水四散向每个可能的方向流出。那么水流首先会到达B顶点， 这也是水流第一次经过B顶点， 所以A-B的最短路径长度即为1。 类似的， 我们可以得出水流依次经过的顶点顺序为`A -> B -> C -> D -> D`， 其中D取第一次经过时的时间， 也就是9。\n\nDijkstra算法的思想基本如此， 但抽象为计算机语言却有些不同， 接下来讲讲Dijkstra算法的实现过程。\n\n- 将顶点编号为1~n\n- 维护一个数组dist， dist[i]表示目前顶点i和源点的最短路径长度， 开始时dist初始化为正无穷， 而源点的dist设为0, 表示当前只知道源点到源点的路径长度为0.\n\n整个Dijkstra算法就是基于bfs以及贪心对dist数组更新的一个过程。\n\n在算法中重复执行此过程： 取出目前未遍历过且dist最小的一个顶点， 更新其所有指向的顶点的dist\n\n例如以此图举例\n\n![例图](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n第一次： dist[A] = 0， 其它都为正无穷， 因此遍历A结点， 并更新A指向的所有结点的dist\n\n更新完毕后dist[B] = 1, dist[C] = 5, dist[D] = 10.\n\n第二次： 取出B顶点遍历， dist[D] = min (dist[D], dist[B] + weight(B -> D)) （这一步也叫做松弛操作)， 所以dist[D]被更新为9\n\n以此类推。\n\n以不严谨的角度， 可以稍微解释下Dijkstra算法的正确性： 每次都只选择dist最小的顶点， 是因为dist更大的顶点可能被dist小的顶点再加一段路径而更新掉， 而最小的dist在没有负权边的情况下必然是最短路径。\n\n在代码实现上， 由选择dist最小顶点的手段的不同可以分为朴素Dijkstra和堆优化Dijkstra\n\n### 朴素Dijkstra\n\n朴素版本的Dijkstra在选择顶点时， 采用的方式是直接遍历dist数组， 而选出未被遍历过且dist最小的顶点。\n\n每次选择至少都会确定一个顶点的最短路径， 所以至多要选择n次； 而每次选择的过程中都要遍历一次dist数组， 因此时间复杂度为$O(n^2)$\n\n```cpp\nint n, m, g[N][N];\nint vis[N], dist[N];\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= n; i ++) {\n        int t = -1;\n        for (int j = 1; j <= n;  j++) {\n            if (!vis[j] && (t == -1 || dist[j] < dist[t])) {\n                t = j;\n            }\n        }\n        vis[t] = 1;\n        for (int j = 1; j <= n; j ++) {\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        }\n    }\n}\n```\n\n### 堆优化Dijkstra\n\n前面提到过Dijkstra本质上可以看成一个bfs的过程， 但bfs下次要遍历的顶点并不像普通的bfs那样随意， 而是要选择dist最小的顶点。 我们可以用优先队列(小根堆)来实现这一过程， 每次选择时， 直接取出堆顶元素， 然后更新dist并把被更新过的顶点及其dist加入优先队列。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint vis[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    priority_queue<pii, vector<pii>, greater<>> heap;\n    heap.push({0, src});\n    while (heap.size()) {//以堆被清空为结束标志\n        auto [v, x] = heap.top(); heap.pop();\n        if (vis[x]) {//已被遍历过， 直接跳过\n            continue;\n        }\n        vis[x] = true;\n        for (int i = h[x], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (v + w[i] < dist[j]) {//被更新\n                dist[j] = v + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n}\n```\n\n优先队列让取出dist最小的顶点能以O(1)的代价实现， 但每次取出后的调整为O($logn$)， 遍历所有边为O($mlogn$)， 因此时间复杂度为$O((n + m) logn)$\n\n### 两种实现方式的适用场景\n\n虽然堆优化Dijkstra的时间复杂度看上去比朴素算法更优秀， 但堆优化的时间会受到边数的影响， 当边数与顶点数的平方为一个量级时， 堆优化的时间和空间开销都不乐观。\n\n所以一般的， 当图为稠密图时（m 与 n^2^同一个量级), 使用邻接矩阵存储， 朴素Dijkstra；当图为稀疏图时(m远小于n^2^)， 使用邻接表存储， 堆优化Dijkstra.\n\n## 负权图最短路\n\n前面提到， dijkstra是不能处理带负权边的图的， 因为这会导致dijkstra算法最根本的贪心思想不再正确——当dist[i]最小时， dist[i]不一定是源点到i的最短路径， 因为dist[i]可能大于dist[j] + 某个负数。\n\n### Bellman-Ford算法\n\nBellman-Ford算法(以下简称BF算法)基于动态规划的思想， 与Dijkstra类似的是， BF算法同样维护最短路径长度数组dist。 不同的是， Dijkstra使用贪心思想， 选取目前dist最小的顶点， 并遍历其所有出边来更新dist数组；而BF算法则是直接在每次循环过程中遍历整个边集， 来达到更新dist数组的目的。\n\n即对于每一条边[src, dest, weight]， 都取出来并执行松弛操作：` dist[dest] = min(dist[dest], weight + dist[src])`\n\n假设顶点A到顶点B的最短路径中有k条边， 则k小于等于n-1； 显然可以发现的是， 每次遍历边集都至少更新A到B路径中的一条边为最短路径， 所以至多需要遍历n-1次。\n\n设边的数量为m， 则BF算法的时间复杂度为$O(nm)$。\n\n因为BF算法只需要遍历边集， 所以存储图的时候可以只建立一个边集数组。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\nint dist[N], n, m;\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i < n; i ++) {\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], dist[a] + w);\n        }\n    }\n}\n```\n\n### SPFA(队列优化Bellman-Ford)\n\nBF算法的时间复杂度为$O(nm)$， 在一般的图中m都是远大于n, 如此看来BF虽然能处理负权边， 但效率却远低于dijkstra。\n\nBF的效率低在了哪里？显然是每次都遍历整个边集数组， 但其实其中真正的更新了dist的边却不多。\n\nSPFA正是对BF算法这个痛点进行了优化。 \"SPFA\"， 即**Shortest Path Faster Algorithm**， 从名字上也能看出大家对其效率上的认可。\n\nSPFA基于这样一个事实： 对于边[src, dest, weight]， 只有当dist[src]发生改变后， 该边才可能用于更新dist[dest]， 这就是说**只有dist发生改变的顶点的出边才有被遍历的价值。**这一点与Dijkstra算法不谋而合， 所以SPFA与Dijkstra算法在形式上是类似的。\n\n对于SPFA是实现细节， 特别要提的一点是st数组， 在这里st[i]用于标记顶点i是否在队列中， 以免顶点重复入队， 这显然是没用意义的。\n\nSPFA的复杂度并不稳定， 对于一般数据， 它要比朴素BF快得多， 甚至能以同样的时间处理正权图；但对于针对型数据， 复杂度最坏能退化到和BF一样的$O(nm)$。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid spfa (int src) {\n    queue<int> q;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0, q.push(1);\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i];\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n}\n```\n\n### BF和SPFA的其它应用\n#### BF求解有边数限制的最短路径\n\n在BF算法那里我们提到， 假设1~n的最短路径中有k条边， 那么每次遍历边集都至少可以更新它的一条边。为什么是“至少”呢？这是因为在遍历边集的途中边的更新可能发生串联， 如`A->B->C`， 如果先遍历了`A->B`再遍历`B->C`， 则一次遍历就更新了两条边， 反之只能更新`A->B`这一条边。\n\n我们可以使用一些手段， 使得每次遍历边集都只能更新一条边， 那么若只循环k次， 则边数大于k的最短路径将不能被发现。\n\n这个手段就是， 在每次遍历边集前， 将dist数组拷贝一份为backup， 使用上一次的dist数组来更新当前的dist数组， 这就可以避免串联。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\n\nint dist[N], n, m, k, backup[N];\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= k; i ++) {\n        memcpy(backup, dist, sizeof dist);\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], backup[a] + w);\n        }\n    }\n}\n```\n\n#### SPFA判断负环\n普通的SPFA是不能处理带负环的图的， 否则会陷入死循环； 但是我们可以通过记录额外信息来判断图中是否出现负环。\n\n记录cnt[i]为当前i顶点到源点最短路径中的边数， 若cnt[i] >= n， 则显然存在负环。\n\n要注意的点是， 由于图可能并不连通， 因此初始时要把所有顶点入队； 在这里并不是为了求最短路， 所以dist可以不初始化， 只需要保证初始全部相同即可。\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], cnt[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nbool spfa () {\n    queue<int> q;\n    for (int i = 1; i <= n; i ++) {\n        q.push(i), st[i] = true;\n    }\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i], cnt[j] = 1 + cnt[u];\n                if (cnt[j] == n) {\n                    return true;\n                }\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n```\n\n# 多源最短路\n\n多源最短路， 也叫做全局最短路， 即求出图中任意两个点的最短路径。\n\n## Floyd-Warshell算法\n\n> **Floyd-Warshall算法**（英语：Floyd-Warshall algorithm），中文亦称**弗洛伊德算法**或**佛洛依德算法**[[1\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-1)，是解决任意两点间的[最短路径](https://zh.wikipedia.org/wiki/最短路径)的一种[算法](https://zh.wikipedia.org/wiki/算法)[[2\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-2)，可以正确处理[有向图](https://zh.wikipedia.org/wiki/有向图)或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包[[3\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-3)。\n\nF-W算法基于动态规划， 它依赖于这样一个事实： 若i到j的最短路径为dist\\[i][j]， 则对于任意顶点k， dist\\[i][k] + dist\\[k][j] >= dist\\[i][j]。 反之dist\\[i][j]就不为最短路径， 应更新为dist\\[i][k] + dist\\[k][j]。\n\n动态规划的思想如下：\n\n* 使用三维数组f\\[k]\\[i][j]表示**路径中(除源点和汇点)只出现过前k个顶点时**， i顶点到j顶点的最短路径\n\n* 当考虑f\\[k]\\[i][j]时， 可分为两种情况： i->j最短路径不经过k顶点， 即f\\[k-1]\\[i][j]; 经过k顶点， 即f\\[k - 1]\\[i][k] + f\\[k - 1]\\[k][j]。所以状态转移方程为：\n  $$\n  f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k] + f[k - 1][k][j])\n  $$\n\n可以发现， f[k]只与f[k-1]相关， 所以只需要用二维数组存储每次迭代完的状态, 然后在上一次迭代的基础上进行状态转移。\n\n对应到图的存储， 只需要用邻接矩阵存储图， 然后在矩阵中进行递推即可。\n\n```cpp\nint g[N][N], n;\n\nvoid floyd () {\n    for (int k = 1; k <= n; k++)\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j ++)\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n}\n```\n\n","tags":["最短路"],"categories":["图论"]},{"title":"排序算法","url":"/posts/61237/","content":"\n没什么写， 突发奇想总结一下以前写过的排序算法， 权当复习。\n\n> 以下皆以升序举例， a为默认数组名， n默认为数组长度\n\n\n## 冒泡排序\n大多数人学的第一个排序算法就算冒泡排序， 思想是每次比较相邻的两个数， 如果与升序不符合就进行交换； 从前到后一轮交换下来， 不难发现最大值会被交换到最后位， 因此下次只需要对前n-1个元素进行遍历即可。\n\n每轮交换至少确定一个数的位置， 所以最多需要进行n - 1轮, 时间复杂度为$O(n ^ 2)$\n\n<!--more-->\n\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j < n - i - 1; j ++) {\n            if (a[j] > a[j + 1]) {\n                swap(a[j], a[j + 1]);\n            }\n        }\n    }\n}\n```\n\n## 选择排序\n\n思想是每次都从剩余序列中选出一个最小值放到前面， 经过n-1次选择后数组即有序。\n\n可以发现选择排序的过程其实和冒泡排序差不多， 但选择排序第`i`次选择只需要交换一次， 比较`n - i + 1`次， 而冒泡排序在比较次数相同的情况下， 还会有更多次交换。 因此选择排序的常数要比冒泡排序小。\n\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n - 1; i ++) {\n        int m = i;\n        for (int j = i + 1; j < n; j ++) {\n            if (a[j] < a[m]) {\n                m = j;\n            }\n        }\n        swap(a[i], a[m]);\n    }\n}\n```\n\n## 插入排序\n\n插入排序是$O(n^2)$排序中表现最好的排序， 思想正如其名， 先将前`i`个元素排序， 在把第`i + 1`个元素插入前面已经有序的序列中。\n\n插入排序的优势在于， 比较次数并不是死板的， 而是取决于元素应插入的位置。 特别的， 如果对有序序列进行插入排序， 那么每次插入只需要比较一次， 时间复杂度为$O(n)$。而对基本有序的序列， 插入排序效率也会更高。\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 1; i < n; i ++) {\n        int x = a[i], j = i - 1;\n        for (; j >= 0; j --) {\n            if (a[j] > x) {\n                a[j + 1] = a[j];\n            } else {\n                break;\n            }\n        }\n        a[j + 1] = x;\n    }\n}\n```\n\n\n\n## 希尔排序\n\n希尔排序基于对插入排序的优化， 是第一个出现的时间复杂度低于$O(n^2)$的排序。\n\n前面提到， 当序列有序程度增大时， 插入排序的效率也会随之升高。希尔排序会先对数组的子数组进行插入排序， 直到数组有序程度较高， 再对整个数组进行插入排序。\n\n在子数组的选择策略上， 我们选择从第一个元素开始的、下标间隔相同的所有元素， 如`[3, 8, 3, 2, 4]`， 若间隔为2， 子数组应该是`[3, 3, 4]`。\n\n在实现上， 我们选择多组不同的间隔， 这里也叫做增量， 按增量从大到小的顺序依次对相应的子数组进行插入排序。 这里引入一个新的名词：***增量序列***， 增量序列是一个递增、初始项为1的正整数序列， 即为我们选择的间隔序列， 如`[1, 2, 4, 8]`， 如果我们要对长度为7的子数组使用该增量序列进行希尔排序， 则我们应该依次对增量为4, 2, 1的子数组进行插入排序， 显然增量为1的子数组即为原数组， 所以按增量序列依次进行插入排序最后肯定是能达到排序的效果的。\n\n显然希尔排序的效率会受到增量序列的影响， 希尔排序的时间复杂度证明非常复杂， 受限于水平不在此说明。\n\n比较常见的增量序列有发明者希尔推荐的**希尔序列**：`[1, ..., len / 4, len / 2]`, 以及效率更高的**Sedgewick序列**\n\n```cpp\nint Sedgewick[]={28,\n    1,5,19,41,109,209,505,929,\n    2161,3905,8929,16001,36289,64769,146305,260609,\n    587521,1045505,2354689,4188161,9427969,16764929,37730305,67084289,\n    150958081,268386305,603906049,1073643521};\n```\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = n >> 1; i;  i >>= 1) {//使用Shell序列\n        for (int j = i; j < n; j ++) {\n            int x = a[j];\n            for (int k = j - i; k >= 0 && a[k] > x; k -= i) {\n                a[k + i] = a[k];\n            }\n            a[k + i] = x;\n        }\n    } \n}\n```\n\n## 归并排序\n\n归并排序是非常经典的分治算法， 思想是非常简单的：\n\n* 将数组分为左右两半\n* 对左半边数组和右半边数组进行归并排序\n* 将两段有序数组合并成一个有序数组\n\n显然很适合用递归来实现， 而用递归最重要的就算确定递归的边界， 这里的边界就是数组的长度小于1， 此时数组已然是有序的。\n\n在合并数组时， 若要达到线性的合并时间， 就要用到一个辅助数组， 将两边数组按大小依次填入辅助数组， 最后将辅助数组的数据写回原数组;显然辅助数组的长度最大要为n, 因此空间复杂度为$O(n)$。\n\n在时间复杂度上， 考虑递归的层数。 因为每次递归会将数组分成两半， 所以层数最大为$O(log n)$， 由于合并的时间复杂度为线性， 所以时间复杂度应为$O(nlog n)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r, int t[]) {\n    if (l >= r) {\n        return;\n    }\n    int m = (l + r) >> 1;\n    Sort(a, l, m, t), Sort(a, m + 1, r, t);\n    //合并\n    int i = l, j = m + 1, k = l;\n    while (i <= m && j <= r ) {\n        if (a[i] < a[j]) {\n            t[k ++] = a[i ++];\n        } else {\n            t[k ++] = a[j ++];\n        }\n    }\n    while (i <= m) {\n        t[k ++] = a[i ++];\n    }\n    while (j <= r) {\n        t[k ++] = a[j ++];\n    }\n    for (i = l; i <= r; i ++) {\n        a[i] = t[i];\n    }\n}\n```\n\n## 快速排序\n\n快速排序也是一个分治算法， 思想如下：\n\n* 从当前数组选出任意一个数作为枢纽p\n* 把数组中所有比p小的数放到p左边， 大的数放到右边(相等随意)， 这个过程叫做划分。\n* 对p左边的元素和右边的元素进行快速排序。\n\n第一次看到时肯定是很迷茫的， 经过上面的递归过程数组怎么就有序了呢？\n\n可以用类似数学归纳法的方法证明：\n\n* 首先来看递归边界： 当数组的长度小于等于1时， 数组本身是有序的。\n\n* 设数组经过划分后， 分出左右两个子数组为L/R， **假设L, R经过快速排序， 可以变成有序**\n* 此时有`L < p < R`， 显然当前数组也为有序\n\n以上就是快速排序的思想， 但要想让快速排序‘快速’， 我们就要考虑划分操作的实现。\n\n最容易想到的是， 使用两个辅助数组， 来记录两边的信息；这当然是可以的， 但空间复杂度将于归并排序相同为$O(n)$\n\n但先人发明了一个非常巧妙的双指针算法， 能以$O(n)$时间复杂度、$O(1)$空间复杂度完成划分操作。\n\n基本思想是： 使用两个指针i, j， 从数组两边想中间遍历， i会停止在大于p的元素上， j会停止在小于p的元素上；当i， j都停止时， 将i、j指向元素进行一次交换。 遍历结束于i，j相遇。\n\n关于时间复杂度， 我们同样关注递归的深度。 但快排于归并排序不同的是， 每次划分后两边的元素数量不一定相等， 因此快排的时间复杂度会取决于数据， 具有随机性。\n\n对于快排的最好情况：每次划分都能划分为两个元素数量差不多的两边， 此时时间复杂度为$O(nlog n)$； 对于快排的最坏情况， 每次划分都把全部元素划分到一边， 而另一边为空， 此时递归深度为n, 时间复杂度为$O(n^2)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int p = a[(l + r) >> 1], i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while(a[i] < p);\n        do j--; while(a[j] > p);\n        if (i < j) swap(a[i], a[j]);\n    }\n    Sort(a, l, j), Sort(a, j + 1, r);\n}\n```\n\n## 堆排序\n\n堆这个数据结构的原理就不多赘述了， 主要如何以数组自建堆、以$O(1)$的空间复杂度实现堆排序。\n\n首先我们将待排序的数组看作一个完全二叉树， 然后**自底向上**的将二叉树调整为堆。\n\n过程如下：\n\n* 首先将i的两个子树调整为堆\n* 此时将i下滤， i所在的二叉树即变成了堆。\n* 递归的终止条件为， 当结点i没有子树时， 即可以返回。\n\n而由于完全二叉树数组存储的特殊性， 我们只需要从后往前的遍历数组， 即可保证每个结点被遍历前其子树已被遍历。\n\n经过n次遍历， 数组已经变成了一个堆。 接下来是堆排序的第二个关键点：从堆中取n次堆顶元素得到排序序列。\n\n我们可以发现每次弹出堆顶元素， 堆的大小减一， 即所需的数组大小减一。\n\n参考堆实现中的删除顶点元素操作：将堆顶与最后一个元素交换， 此时堆顶的两个子树都是堆， 只需要将堆顶再次下滤， 即可完成对堆的调整；而原来的堆顶元素显然就可以保存在原堆的最后一个元素那里。\n\n**时间复杂度**\n\n每次下滤操作的时间复杂度为$O(\\log n)$， 在调整原原数组及从堆中删除堆顶元素过程中， 总共需要差不多`2n`次下滤， 因此时间复杂度为$O(n\\log n)$\n\n**空间复杂度**\n\n由于我们始终是在对数组进行操作， 并没有使用到其它的额外空间。 因此空间复杂度为$O(1)$.\n\n### 代码实现\n\n```c++\n#define Left(i) 2 * i + 1\nvoid down(int a[], int i, int n) {\n    int t = a[i];\n    for (int son = Left(i); son <= n; son = Left(i)) {\n        if (son != n && a[son + 1] > a[son]) son ++;\n        if (t > a[son]) break;\n        else a[i] = a[son], i = son;\n    }\n    a[i] = t;\n}\n\nvoid Sort(int a[], int n) {\n    for (int i = n - 1; i >= 0; i --) down(a, i, n-1);\n    for (int i = n-1; i > 0; i --) swap(a[0], a[i]), down(a, 0, i-1);\n}\n```\n\n\n\n","tags":["排序"],"categories":["算法"]},{"title":"线段树","url":"/posts/48555/","content":"\n## 线段树简介\n线段树常用来解决多次区间修改以及区间性质查询的问题， 且区间的性质一般可以由子区间推出， 如最大值、区间和。\n\n## 线段树的结构\n线段树顾名思义显然是一棵树， 且一般实现为二叉树。\n线段树满足：\n\n- 树上每一个结点都代表着一段区间\n\n- 每个结点的两个子结点分别代表该区间的左右子区间。\n\n<!--more-->\n\n如区间[1, 5]用线段树表示为\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n显然， 线段树具有搜索树的性质。\n\n## 基本建树\n\n### 线段树的存储\n\n线段树常用存储完全二叉树的方式、数组形式存储， 即根结点下标为1， 对于结点i， 它的左儿子下标为`2 * i`， 右儿子下标为`2 * i + 1`。\n\n下面以图的形式展示各结点下标关系\n\n```mermaid\ngraph TD;\n\tA((\"1<br>[1, 5]\")) --> B((\"2<br>[1, 3]\"))\n\tA --> C((\"3<br>[4, 5]\"))\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n至于数组的大小， 一般开到区间长度的四倍， 因为结点个数最多不会操过区间长度的四倍， 可自行证明。\n\n\n### 代码实现\n\n假设区间性质为区间和\n\n```c++\nconst int N = xxx;\nint a[N];//原数组\nint f[N << 2];//存储线段树结点的某性质\n\nvoid bulid (int k, int l, int r) {\n    if (l == r) {\n        f[k] = a[i];\n        return;\n    }\n\t int m = l + r >> 1;\n\t build(2 * k, l, m), bulid(2 * k + 1, m + 1, r);\n    f[k] = f[2 * k] + f[2 * k + 1];//由子区间推出当前区间\n}\n```\n\n## 线段树的单点修改及查询\n\n### 例题 - [洛谷P3374](https://www.luogu.com.cn/problem/P3374)\n\n>#### 题目描述\n>\n>如题，已知一个数列，你需要进行下面两种操作：\n>\n>- 将某一个数加上 x*\n>- 求出某区间每一个数的和\n>\n>#### 输入格式\n>\n>第一行包含两个正整数 n*,*m*，分别表示该数列数字的个数和操作的总个数。\n>\n>第二行包含 *n* 个用空格分隔的整数，其中第 *i* 个数字表示数列第 i*i* 项的初始值。\n>\n>接下来 *m* 行每行包含 33 个整数，表示一个操作，具体如下：\n>\n>- `1 x k` 含义：将第 x*x* 个数加上 *k*\n>- `2 x y` 含义：输出区间 [x,y][*x*,*y*] 内每个数的和\n>\n>#### 输出格式\n>\n>输出包含若干行整数，即为所有操作 2 的结果。\n>\n>#### 输入输出样例\n>\n>**输入 #1**\n>\n>```\n>5 5\n>1 5 4 2 3\n>1 1 3\n>2 2 5\n>1 3 -1\n>1 4 2\n>2 1 4\n>```\n>\n>**输出 #1**\n>\n>```\n>14\n>16\n>```\n>\n>#### 说明/提示\n>\n>【数据范围】\n>\n>$1 \\leq n, m \\leq 10^5$\n\n### 单点修改\n\n在区间和线段树已经构建完成的情况下， 此时若要将某元素的值增大，则会有多个区间的和发生变化。\n\n因此可以对线段树进行一次搜索， 将所有包含被修改元素的区间的区间和增大。\n\n```c++\n//k, l, r表示当前区间的下标及边界， x、y为被修改的元素下标和增大的值\nvoid modify (int k, int l, int r, int s, int v) {\n    f[k] += v;\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    if (s <= m) {//x在左半边\n        modify(2 * k, l, m, s, v);\n    } else {//x在右半边\n        modify(2 * k + 1, m + 1, s, v);\n    }\n}\n```\n\n显然单点修改线段树的时间复杂度与树高有关， 为$O（log n)$\n\n\n### 区间查询\n\n由于区间和是可以由子区间推出的， 所以要求出[b, e]区间的区间和， 就要把[b, e]区间分解为若干个线段树上存在的区间。\n\n如\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n若要查询[3, 5], 则应该分解为[3, 3] + [4, 5]\n\n```c++\nint query (int k, int l, int r, int b, int e) {\n    if (l == b && r == e) {\n        return f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {//[b, e]完全在左区间\n        return query(2 * k, l, m, b, e);\n    } else if (b > m) {//完全在右区间\n        return query(2 * k + 1, m + 1, b, e);\n    } else {//[b, e]在左右区间均有分布\n        return query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, b, e);\n    }\n}\n```\n\n查询时， 最坏情况下最遍历到最底层, 且支数是有限的， 时间复杂度为$O(log n)$\n\n\n### 完整代码\n\n```cpp\n//\n// Created by trudbot.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5;\nint a[N], f[N << 2];\nint n, m;\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m);\n\tbuild(2  *k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int s, int v) {\n\tf[k] += v;\n\tif(l == r) {\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tif(s <= m) {\n\t\tmodify(2 * k, l, m, s, v);\n\t} else {\n\t\tmodify(2 * k + 1, m + 1, r, s, v);\n\t}\n}\n\nint query(int k, int l, int r, int b, int e) {\n\tif(l == b && r == e) {\n\t\treturn f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(e <= m) {\n\t\treturn query(2 * k, l, m, b, e);\n\t} else if(b > m) {\n\t\treturn query(2 * k + 1, m + 1, r, b, e);\n\t} else {\n\t\treturn query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\t\n\twhile(m --) {\n\t\tint x, a, b; cin >> x >> a >> b;\n\t\tif(x == 1) {\n\t\t\tmodify(1, 1, n, a, b);\n\t\t} else {\n\t\t\tcout << query(1, 1, n, a, b) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n## 线段树的区间修改及查询\n\n### 例题\n\n> #### 【模板】线段树 1\n>\n> #### 题目描述\n>\n> 如题，已知一个数列，你需要进行下面两种操作：\n>\n> 1. 将某区间每一个数加上 $k$。\n> 2. 求出某区间每一个数的和。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n>\n> 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n>\n> 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n>\n> 1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。\n> 2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。\n>\n> #### 输出格式\n>\n> 输出包含若干行整数，即为所有操作 2 的结果。\n>\n> #### 样例 #1\n>\n> ##### 样例输入 #1\n>\n> ```\n> 5 5\n> 1 5 4 2 3\n> 2 2 4\n> 1 2 3 2\n> 2 3 4\n> 1 1 5 1\n> 2 1 4\n> ```\n>\n> ##### 样例输出 #1\n>\n> ```\n> 11\n> 8\n> 20\n> ```\n>\n> #### 提示\n>\n> 对于 $30\\%$ 的数据：$n \\le 8$，$m \\le 10$。  \n> 对于 $70\\%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。  \n> 对于 $100\\%$ 的数据：$1 \\le n, m \\le {10}^5$。\n>\n> 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n>\n> **【样例解释】**\n>\n> ![](https://cdn.luogu.com.cn/upload/pic/2251.png)\n\n\n### 区间修改与永久懒惰标记\n\n这次要求将区间所有元素都加上某个数， 直接遍历加上再重新建树肯定不行， 这样时间复杂度会来到$O(n)$；更加不能对区间每一个元素都进行单点修改， 否则时间复杂度为$O(n log n)$。\n\n这时我们需要用一个懒惰标记的手段， 对于修改的区间[b, e]， 我们把它分解为线段树上若干的区间， 对这些区间增加一个“标记”， 即标记增加了x。而对分解区间的父区间， 则是直接修改f值。\n\n如下图， 假设为在[3, 5]区间加上x， 且用v[N<<2]来记录某结点区间加的值。\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>f[1] += (5-3+1) * x\") --> B(\"2<br>[1, 3]<br>f[2] += (3-3+1)*x\")\n\tA --> C(\"3<br>[4, 5]<br>v[3] += x\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>v[5] += x\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n```c++\nvoid modify (int k, int l, int r, int b, int e, int x) {\n    if (b == l && e == r) {\n        v[k] += x;\n        return;\n    }\n    f[k] += (e - b + 1) * x;\n    int m = l + r >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, x);\n    } else if (b > m) {\n        modify(2 * k + 1, m+1, r, b, e, x);\n    } else {\n        modify(2 * k, l, m, b, m, x);\n        modify(2 * k + 1, m + 1, r, m + 1, e, x);\n    }\n}\n```\n\n\n\n### 区间查询\n\nv[i] += x表示在对i号结点区间[l, r]上的每个元素都加上了x， 所有包含[l, r]的大区间也都已经都记录了变化； 但如果我们要查询的是[l, r]的子区间呢？\n\n这时对懒惰标记的处理就至关重要了， 在向下遍历线段树的途中用一个变量来记录沿途的标记， 最后在加到被查询区间上。\n\n如\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>v[1] = x\") --> B((\"2<br>[1, 3]<br>\"))\n\tA --> C(\"3<br>[4, 5]<br>v[3] = y\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n此时v[1]和v[3]上均有标记， 若我们要查询[4, 4]的区间和， 在搜索改区间的过程上会记录路径上的所有标记的和， 所以结果应该为`f[6] + (x + y) * (4 - 4 + 1)`\n\n```c++\n\nll query(int k, int l, int r, int b, int e, int p) {\n    p += v[k];\n    if(l == b && r == e) {\n        return p * (r - l + 1) + f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {\n        return query(2 * k, l, m, b, e, p);\n    } else if (b > m) {\n        return query(2 * k + 1, m + 1, r, b, e, p);\n    } else {\n        return query(2 * k, l, m, b, m, p) + query(2 * k + 1, m + 1, r, m + 1, e, p);\n    }\n}\n```\n\n \n\n### 完整代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N<<2], v[N<<2];\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m), build(2 * k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int x, int y, int z) {\n\tif(l == x && r == y) {\n\t\tv[k] += z;\n\t\treturn;\n\t}\n\tf[k] += (y - x + 1) * z;\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\tmodify(k * 2, l, m, x, y, z);\n\t} else if(x > m) {\n\t\tmodify(k * 2 + 1, m + 1, r, x, y, z);\n\t} else {\n\t\tmodify(2 * k, l, m, x, m, z);\n\t\tmodify(2 * k + 1, m + 1, r, m + 1, y, z);\n\t}\n}\n\nll query(int k, int l, int r, int x, int y, ll p) {\n\tp += v[k];\n\tif(l == x && r == y) {\n\t\treturn p * (r - l + 1) + f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\treturn query(2 * k, l, m, x, y, p);\n\t} else if(x > m) {\n\t\treturn query(2 * k + 1, m + 1, r, x, y, p);\n\t} else {\n\t\treturn query(2 * k, l, m, x, m, p) \n\t\t\t+ query(2 * k + 1, m + 1, r, m + 1, y, p);\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\twhile (m --) {\n\t\tint t; cin >> t;\n\t\tif(t == 1) {\n\t\t\tint x, y; ll z; cin >> x >> y >> z;\n\t\t\tmodify(1, 1, n, x, y, z);\n\t\t} else {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcout << query(1, 1, n, x, y, 0) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 标记下传与自下而上更新\n\n在上述标记永久化方法中， 对标记的处理方法是：\n\n* modify时的被标记区间的父区间不标记， 而是直接修改。\n* query时， 会累加遍历路径中的标记， 最后作用于查询区间。\n\n但使用标记永久化的很重要的一个条件是标记可以累加， 很多时候可以并不能满足。\n\n而标记下传是适用性更广的一种标记处理方法， 有两个核心方法：\n\n* pushdown， 把当前结点的标记下传\n* pushup， 由子结点更新当前结点。\n\n标记下传的基本规则是：\n\n* 为某结点添加标记时， 会修改结点的值。\n* 在遍历到线段树的某个结点时， 若还要往下遍历， 则把标记下传， 并在遍历完子树后更新当前结点。\n\n标记下传是一种延迟修改的思想， 在修改[l, r]时如果直接把它的每一个子区间都修改， 显然在时间复杂度上是灾难。 但标记下传只在需要查询/修改子区间时把上一次的修改作用于子区间， 修改的过程融合在了查询/其它修改 的过程中。\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N << 2], v[N << 2];\n\nvoid pushup(int k) {\n    f[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid pushdown(int k, int l, int r) {\n    if (v[k]) {\n        int left = 2 * k, right = left + 1, m = (l + r) >> 1;\n        f[left] += v[k] * (m - l + 1), f[right] += v[k] * (r - m);\n        v[left] += v[k], v[right] += v[k], v[k] = 0;\n    }\n}\n\nvoid build(int k, int l, int r) {\n    if(l == r) {\n        f[k] = a[l];\n        return;\n    }\n    int m = (l + r) >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n    pushup(k);\n}\n\nvoid modify (int k, int l, int r, int b, int e, int s) {\n    if(l == b && e == r) {\n        f[k] += (r - l + 1) * s;\n        v[k] += s;\n        return;\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, s);\n    } else if (b > m) {\n        modify(2 * k + 1, m + 1, r, b, e, s);\n    } else {\n        modify(2 * k, l, m, b, m, s), modify(2 * k + 1, m + 1, r, m + 1, e, s);\n    }\n    pushup(k);\n}\n\nll query(int k, int l, int r, int b, int e) {\n    if (l == b && e == r) {\n        return f[k];\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    ll res;\n    if (e <= m) {\n        res = query(2 * k, l, m, b, e);\n    } else if (b > m ) {\n        res = query(2 * k + 1, m + 1, r, b, e);\n    } else {\n        res = query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n    }\n    pushup(k);\n    return res;\n}\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int b, e, x; cin >> b >> e >> x;\n            modify(1, 1, n, b, e, x);\n        } else {\n            int b, e; cin >> b >> e;\n            cout << query(1, 1, n, b, e) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 线段树实战\n\n### 旅馆\n\n[261. 旅馆 - AcWing题库](https://www.acwing.com/problem/content/description/263/)\n\n> 一家旅馆共有 N 个房间，这 N 个房间是连成一排的，标号为 1∼N。\n>\n> 现在有很多旅客以组为单位前来入住，每组旅客的数量可以用 Di来表示。\n>\n> 旅店的业务分为两种，入住和退房：\n>\n> 1. 旅客入住时，第 i 组旅客需要根据他们的人数 D~i~，给他们安排 D~i~ 个连续的房间，并且房间号要尽可能的小。如果房间不够，则无法安排。\n> 2. 旅客退房时，第 i 组旅客的账单将包含两个参数 X~i~ 和 D~i~，你需要将房间号 X~i~到 X~i~+D~i~−1之间的房间全部清空。\n>\n> 现在你需要帮助该旅馆处理 M 单业务。\n>\n> 旅馆最初是空的。\n>\n> #### 输入数据\n>\n> 第一行输入两个用空格隔开的整数 N 和 M。\n>\n> 接下来 M 行将描述 M 单业务：\n>\n> “1 D~i~”表示这单业务为入住业务。\n>\n> “2 X~i~ D~i~”表示这单业务为退房业务。\n>\n> #### 输出数据\n>\n> 每个入住业务输出一个整数，表示要安排的房间序列中的第一个房间的号码。\n>\n> 如果没办法安排，则输出 0。\n>\n> 每个输出占一行。\n>\n> #### 数据范围\n>\n> 1≤D~i~≤N≤50000\n> 1≤M<50000\n>\n> #### 输入样例：\n>\n> ```\n> 10 6\n> 1 3\n> 1 3\n> 1 3\n> 1 3\n> 2 5 5\n> 1 6\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 1\n> 4\n> 7\n> 0\n> 5\n> ```\n\n#### 题意解析\n对于长度为N的01串（下标从1开始）， 需实现以下两种操作：\n* 查询串中最靠左的长度为d的全0串， 并返回左端点（若不存在返回0）； 随后把这个全0串变成全1串。\n* 把区间[x, x + d - 1]变成全0\n\n#### 思路\n设计线段树的结点保存区间的三种信息：\n- 区间中的最长0串长度\n- 区间中以左端点开始的最长0串长度\n- 区间中以右端点结束的最长0串长度\n\n这样设计的巧妙之处在于：\n- 由两个子区间的信息可以推出当前区间的信息\n- 通过三个信息可以递归查找出最左的长度为d的0串\n\n#### 代码\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50010;\n\nstruct node{\n    int l, r;\n    int m, lm, rm;\n    int s;\n} f[N << 2];\n\ninline void allSet (int k, int v) {\n    f[k].m = f[k].lm = f[k].rm = v;\n}\n\ninline void build (int k, int l, int r) {\n    f[k].l = l, f[k].r = r, f[k].s = 0;\n    allSet(k, r - l + 1);\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n}\n\ninline void pushdown (int k) {\n    int left = 2 * k, right = left + 1;\n    if (f[k].s == 1) {\n        allSet(left, 0), allSet(right, 0);\n    } else if (f[k].s == -1) {\n        allSet(left, f[left].r - f[left].l + 1), \n        allSet(right, f[right].r - f[right].l + 1);\n    } else {\n        return;\n    }\n    f[left].s = f[right].s = f[k].s, f[k].s = 0;\n}\n\nvoid pushup (int k) {\n    int left = 2 * k, right  = left + 1;\n    f[k].m = max(f[left].m, max(f[right].m, f[left].rm + f[right].lm));\n    f[k].lm = f[left].lm;\n    if (f[left].lm == f[left].r - f[left].l + 1) {\n       f[k].lm += f[right].lm; \n    }\n    f[k].rm = f[right].rm;\n    if (f[right].rm == f[right].r - f[right].l + 1) {\n        f[k].rm += f[left].rm;\n    }\n}\n\nint query (int k, int len) {\n    if (f[k].m < len) {\n        return 0;\n    }\n    pushdown(k);\n    if (f[k].lm >= len) {\n        return f[k].l;\n    } else if (f[2 * k].m >= len) {\n        return query(2 * k, len);\n    } else if (f[2 * k].rm + f[2 * k + 1].lm >= len) {\n        return f[2 * k].r - f[2 * k].rm + 1;\n    } else {\n        return query(2 * k + 1, len);\n    }\n}\n\nvoid modify (int k, int l, int r, int s) {\n    if (f[k].l == l && f[k].r == r) {\n        if (s == 1) {\n            allSet(k, 0);\n        } else {\n            allSet(k, f[k].r - f[k].l + 1);\n        }\n        f[k].s = s;\n        return;\n    }\n    pushdown(k);\n    int m = f[k].l + f[k].r >> 1;\n    if (r <= m) {\n        modify(2 * k, l, r, s);\n    } else if (l > m) {\n        modify(2 * k + 1, l, r, s);\n    } else {\n        modify(2 * k, l, m, s), modify(2 * k + 1, m + 1, r, s);\n    }\n    pushup(k);\n}\n\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int d; cin >> d;\n            int b = query(1, d);\n            cout << b << endl; \n            if (b != 0) {\n                modify(1, b, b + d - 1, 1);\n            }\n        } else {\n            int x, d; cin >> x >> d;\n            modify(1, x, x + d -1, -1);\n        }\n    }\n    return 0;\n}\n```\n\n### 最长递增子序列\n\n> 给你一个整数数组 nums 和一个整数 k 。\n>\n> 找到 nums 中满足以下要求的最长子序列：\n>\n> 子序列 严格递增\n> 子序列中相邻元素的差值 不超过 k 。\n> 请你返回满足上述要求的 最长子序列 的长度。\n>\n> 子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。\n>\n> 示例 1：\n>\n> 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3\n> 输出：5\n> 解释：\n> 满足要求的最长子序列是 [1,3,4,5,8] 。\n> 子序列长度为 5 ，所以我们返回 5 。\n> 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。\n> 示例 2：\n>\n> 输入：nums = [7,4,5,1,8,12,4,7], k = 5\n> 输出：4\n> 解释：\n> 满足要求的最长子序列是 [4,5,8,12] 。\n> 子序列长度为 4 ，所以我们返回 4 。\n> 示例 3：\n>\n> 输入：nums = [1,5], k = 1\n> 输出：1\n> 解释：\n> 满足要求的最长子序列是 [1] 。\n> 子序列长度为 1 ，所以我们返回 1 。\n>\n>\n> 提示：\n>\n> 1 <= nums.length <= 10^5^\n> 1 <= nums[i], k <= 10^5^\n>\n> 来源：力扣（LeetCode）\n> 链接：https://leetcode.cn/problems/longest-increasing-subsequence-ii\n> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n#### 思路分析\n可以注意到数组的元素值是有范围的， 位于[1, 1e5]。\n\n定义a[j]为在数组nums中[0, i]以j结尾的满足题意的最长递增序列长度； 则当考虑nums[i + 1]是， 只需要把nums[i + 1]加到某个序列的末尾， 此序列的最后一个元素x应该满足：x < nums[i + 1] , x >= nums[i + 1] - k.\n\n可以得到x的范围为[nums[i + 1] - k, nums[i + 1] - 1]， 在此区间查找最长的子序列长度， 在更新a[nums[i + 1]]即可。\n\n查询某区间的最大值， 显然可以使用线段树。\n\n#### 代码参考\n时间复杂度：$O(n\\log_2x)$\n```c++\nconst int N = 1e5 + 10;\nint f[N << 2];\n\nvoid modify (int u, int l, int r, int x, int v) {\n    if (l == r) {\n        f[u] = max(f[u], v);\n        return;\n    }\n    int m = (l + r) >> 1;\n    if (x <= m) {\n        modify(2 * u, l, m, x, v);\n    } else {\n        modify(2 * u + 1, m + 1, r, x, v);\n    }\n    f[u] = max(f[2 * u], f[2 * u + 1]);\n}\n\nint query (int u, int l, int r , int b, int e) {\n    if (l == b && r == e) {\n        return f[u];\n    }\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        return query(2 * u, l, m, b, e);\n    } else if (b > m) {\n        return query(2 * u + 1, m + 1, r, b, e);\n    } else {\n        return max(query(2 * u, l, m, b, m),\n            query(2 * u + 1, m + 1, r, m + 1, e));\n    }\n}\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums, int k) {\n        memset(f, 0, sizeof f);\n        int mx = 0;\n        for (auto i : nums) {\n            mx = max(i, mx);\n        }\n        for (auto i : nums) {\n            int t;\n            if (i == 1) {//特判1, 因为比1小的数不在线段树区间范围内\n                t = 0;\n            } else {\n                t = query(1, 1, mx, max(1, i - k), i - 1);\n            }\n            modify(1, 1, mx, i, t + 1);\n        }\n        return f[1];\n    }\n};\n```\n\n","tags":["线段树","递归"],"categories":["高级数据结构"]},{"title":"二分查找","url":"/posts/42877/","content":"前言： 二分查找虽然并不是什么很难的东西， 但因为我始终背不下来， 每次要用的时候都得现场小心翼翼地推导细节， 十分苦恼。因此希望通过写一篇笔记总结， 把它刻入我的记忆。\n\n## 基本概念\n\n不再赘述， 引用维基百科：\n> 在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm）[2]，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n<!--more-->\n\n## 二分查找的框架\n\n二分查找的步骤大概是：\n* 定义二分查找的左右边界\n* 循环体， 循环条件一般为左边界不大于右边界\n* 取中值（**准确说是左右边界的平均值， 即中间元素**）\n* 用中值与查找的目标元素比较， 从而移动左右边界\n\n## 二分查找的三种应用形式\n\n通过对取中值以及对左右边界移动的细节处理， 可以得到不同功能的二分查找。\n\n### 最朴素的二分查找\n\n最朴素的二分查找的用法是： 查找某值是否在数组中出现过， 是则返回下标， 否则返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] == target) {\n            return mid;\n        } else if(nums[mid] > target) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n### 查找左边界 / 第一个大于等于target的元素\n\n在朴素二分中， 若数组中有多个值为target的元素， 返回的下标对于使用者而言是合理情况中的随机一个；若数组中中没有值为target的元素， 返回值将是无意义的-1.\n\n接下来两种二分便是为了解决这一类问题。\n\n在左边界二分中， 要查找的元素`e`满足：e左边的元素都小于target, e右边的元素及e都不小于（大于等于）target.\n\n```cpp\nint binarySearch_lower(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n```\n### 查找右边界 / 第一个小于等于target的元素\n\n类似的， 在左边界二分中， 要查找的元素`e`满足：e右边的元素都大于target, e右边的元素及e都不大于（小于等于）target.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n```\n### 细节1——取中值时的左偏和右偏\n\n当`[l, r]`中有奇数个元素时如`[1, 2, 3]`， 中值显然为中间那个元素。\n但当`[l, r]`中有偶数个元素时如`[1, 2, 3, 4]`， 中值到底是2还是3呢？\n\n这就取决于mid的取法了\n```cpp\nmid = (l + r) >> 1;\nmid = (l + r + 1) >> 1; \n```\nc++的中整数除法是与右移一位的效果完全相同的， 即整除， 当[l, r]中有偶数个元素时, 显然`l + r`为奇数， 所以`(l + r) >> 1`结果会偏向l这一边\n而相反的`(l + r + 1) >> 1`会偏向r这一边。\n\n取中的偏向是相当重要的问题， 若使用错误， 二分可能将陷入死循环。\n\n在结论上， 可以简单的记忆为左边界左偏， 右边界右偏\n\n### 细节2——左右边界的更新方式\n\n边界二分与朴素二分很大的一个区别是： 朴素二分靠mid查找目标值， 若nums[mid] == target就立即返回； 而边界二分是靠不断缩小查找的区间， 最终区间长度为1时(`l == r`)， 区间中唯一的元素即为目标值。\n以左边界二分举例\n```cpp\nwhile(l < r) {\n  int mid = (l + r) >> 1;\n  if(nums[mid] >= target) {\n  \tr = mid;\n  } else {\n  \tl = mid + 1;\n  }\n}\n```\n要找的是左边界， 当nums[mid] > target时， 是不能将`r`置为`mid - 1`的， 因为也许`mid`就是左边界； 类似的， 当nums[mid] == target时， 你不能确定mid左边是否是左边界， 但mid + 1往后的元素你可以确定一定不是左边界， 因此将r赋为`mid`， 缩小范围， 继续查找。\n而只有当nums[mid] < target时， 才移动l， 此时mid显然不是左边界， 所以将l赋为`mid + 1`\n\n### 补充1——取中值时的溢出\n\n在区间较大情况下， 使用(l + r)直接取中值时可能会溢出整型范围。\n所以可以用如下方式等价取代\n```cpp\nmid = l + ((r - l) >> 1);\nmid = l + ((r - l + 1) >> 1);\n```\n\n### 补充2——查找失败\n\n若要找第一个不小于target的元素， 但数组中所有元素都小于target?\n此时`l`会不断向右移动， 直到移到到`r`的位置。\n所以查找结束后， 可以在对结果进行一次判断， 如果不满足就返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return nums[l] <= target ? l : -1;\n}\n```\n## 二分查找的应用\n\n二分查找最常见的应用就是在数组中查找某个值的左边界或右边界， 但还有一种的用法是浮点数二分， 必如求一个浮点数的n次方根。\n\n> 给定一个浮点数 nn，求它的三次方根。\n>\n> #### 输入格式\n>\n> 共一行，包含一个浮点数 nn。\n>\n> #### 输出格式\n>\n> 共一行，包含一个浮点数，表示问题的解。\n>\n> 注意，结果保留 66 位小数。\n>\n> #### 数据范围\n>\n> −10000≤n≤10000−10000≤n≤10000\n>\n> #### 输入样例：\n>\n> ```\n> 1000.00\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 10.000000\n> ```\n\n**思路**\n用二分的思想不断更新左右边界， 使左右边界逐渐逼近答案， 当左右边界足够接近答案时（达到精度要求）， 即认为左/右边界就是答案。\n**参考代码**\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    double n; cin >> n;\n    double l = -100, r = 100;\n    while((r - l) > 1e-8) {\n        double mid = (l + r) / 2;\n        if(mid * mid * mid > n) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n    printf(\"%.6lf\\n\", l);\n    return 0;\n}\n```\n\n## 参考\n\n[二分 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/binary/)\n\n[二分查找算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/二分搜尋演算法)\n\n[二分查找、二分边界查找算法的模板代码总结 - SegmentFault 思否](https://segmentfault.com/a/1190000016825704)\n\n","tags":["二分查找"],"categories":["算法"]},{"title":"字符串哈希","url":"/posts/52567/","content":"\n# 理论基础\n\n字符串哈希， 即把一个字符串映射为一个整数， 这个整数称之为`hash code`。在理想状态下， 只有两个字符串完全相等， hash code才会相等。 因此可以用两个字符串的`hash code`来判断字符串是否相等。\n\n将字符串转化为整数的函数也叫做哈希函数。\n\n# 字符串前缀哈希\n\n字符串前缀哈希是前缀思想在哈希中的应用， 一般用来解决**多次查询子串哈希**的问题。\n\n> 单次计算一个字符串的哈希值复杂度是 `O(n)`，其中n为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。\n\n<!--more-->\n\n因此可以使用特别的哈希函数， 使用字符串前缀的哈希值而推出任一连续子串的哈希值。\n\n## 哈希函数及公式\n\n设字符串S， S中元素下标从1开始， S下标为i的元素为S[i].\n\n哈希函数：\n$$\nhashCode = \\sum_{i = 1}^nS[i] * p^{n - i}\n$$\n如字符串`\"abc\"`， 表达式为\n$$\na * p ^ 2  + b * p + c\n$$\n利用此公式， 我们可以求出S的所有前缀的哈希值\n\n但显然不可能对所有前缀都应用上述公式。事实上pref[i] 可以由pref[i-1]递推得到\n\n仍然以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n可以发现\n\n```F#\npref[i] = pref[i-1] * p + S[i]\n```\n\n## 区间哈希\n\n我们得到了一个字符串所有长度前缀的哈希值， 那么如何利用它来得到某个区间[l, r]的哈希值呢？\n\n以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n假设我们要求[2, 3]区间， 即`\"bc\"`的哈希， 按上述哈希函数应该是`b*p + c`\n\n类比前缀和`sum[l, r] = pref[r] - pref[l-1]`, 可以发现\n$$\nb * p + c = pref[3] - pref[1] * p ^ 2\n$$\n事实上， 存在以下通式\n$$\nhashCode[l, r] = pref[r] - pref[l - 1] * p^{r - l + 1}\n$$\n证明并不难， 若有兴趣自行研究， 就不在此赘述了。\n\n其中`r - l + 1`很明显的， 可以记忆为区间的长度。\n\n因此通过预处理字符串所有前缀的哈希， 我们可以以O(1)的时间代价求出任一子串的哈希值。\n\n## 代码实现(C++)\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N]; // hh[i] 表示长度为i的前缀子串的哈希\null p[N];// p[i]表示P的i次幂, 避免使用幂函数多次求幂\n\n// 初始化前缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n```\n\n**小科普： unsigned long long**\n\n\n\null(unsigned long long)表示64位无符号正整数， 之所以使用ull是因为ull溢出后， 不会像有符号整数如int那样变成负数， 而是会从0重新开始， 即等同于对$2 ^ {64}$自动取余。\n\n在上述哈希函数中， P选取为131(此质数在先人的实验中表现最好， 不容易发生冲突)， 而hashCode更是以幂级增长的， 因此很容易就溢出， 需要对其进行取模。\n\n# 算法应用\n\n## 判断子串是否相等\n\n要判断两个子串是否相等， 只需比较哈希值是否相等即可。预处理前缀哈希， 即可以O(1)的时间代价得到子串的哈希。\n\n### 例题\n\n**AcWing 841**\n\n> 给定一个长度为 *n* 的字符串，再给定 *m* 个询问，每个询问包含四个整数 `l1, r1, l2, r2`，请你判断 \\[l1,r1] 和 \\[l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n>\n> 字符串中只包含大小写英文字母和数字。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n 和 m，表示字符串长度和询问次数。\n>\n> 第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。\n>\n> 接下来 m 行，每行包含四个整数 `l1, r1, l2, r2`，表示一次询问所涉及的两个区间。\n>\n> 注意，字符串的位置从 1 开始编号。\n>\n> #### 输出格式\n>\n> 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。\n>\n> 每个结果占一行。\n>\n> #### 数据范围\n>\n> 1≤n,m≤$10^5$\n>\n> #### 输入样例：\n>\n> ```\n> 8 3\n> aabbaabb\n> 1 3 5 7\n> 1 3 6 8\n> 1 2 1 2\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> Yes\n> No\n> Yes\n> ```\n\n套上上面的板子即可\n\n**时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\n\nconst int N = 1e5 + 10;\nconst ull P = 131;\null hh[N], p[N];\nstring s;\nint n;\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> s;\n    s.insert(0, \"0\");\n    InitHash();\n    while(m --) {\n        int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;\n        cout << (get(l1, r1) == get(l2, r2) ? \"Yes\" : \"No\") << endl;\n    }\n}\n```\n\n\n\n## 判断子串是否是回文\n\n回文即源串与反转后的字符串是相同的。\n\n用字符串哈希的角度来解决就是判断一个字符串及其逆转后的字符串哈希值是否相等。\n\n因此我们可以预处理主串的正向哈希以及逆向哈希， 再判断某子串的正向哈希和逆向哈希是否相等来判断是否是回文。\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N], r_hh[N];//前缀、后缀哈希\null p[N];\n\n// 初始化前缀/后缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n```\n\n### 例题 **google kickstart Round E P3**\n\n> 给定一个长度为 N 的回文字符串 P，它仅由小写英文字母构成。\n>\n> 请你找到最短的**非空回文**字符串 Q，使得 P 与 Q 拼接而成的字符串 Q 也是一个回文串。\n>\n> #### 输入格式\n>\n> \n>\n> 第一行包含整数 T，表示共有 T 组测试数据。\n>\n> 每组数据第一行包含一个整数 N。\n>\n> 第二行包含一个长度为 N 的回文字符串 PP。\n>\n> #### 输出格式\n>\n> \n>\n> 每组数据输出一个结果，每个结果占一行。\n>\n> 结果表示为 `Case #x: y`，其中 xx 为组别编号（从 11 开始），y 为满足条件的最短**非空回文**字符串 Q。\n>\n> #### 数据范围\n>\n> \n>\n> 1≤T≤100\n> 1≤N≤10^5^，\n> 保证 P 是一个由小写字母构成的回文字符串。\n>\n> \n>\n> #### 输入样例：\n>\n> ```F#\n> 3\n> 4\n> abba\n> 4\n> cccc\n> 6\n> cdccdc\n> ```\n>\n> #### 输出样例：\n>\n> ```F#\n> Case #1: abba\n> Case #2: c\n> Case #3: cdc\n> ```\n>\n> #### 样例解释\n>\n> \n>\n> 在 Case 1 中，满足条件的最短回文串 Q 为 `abba`，此时串联字符串 Q 为 `abbaabba`，这是一个回文串。\n>\n> 在 Case 2 中，满足条件的最短回文串 Q 为 `c`，此时串联字符串 PQ为 `ccccc`，这是一个回文串。\n>\n> 在 Case 3 中，满足条件的最短回文串 Q 为 `cdc`，此时串联字符串 PQ 为 `cdccdccdc`，这是一个回文串。\n\n**题意分析**\n\n给定回文字符串P, 求一回文字符串Q， 使在P末尾拼接Q后， PQ仍为回文字符串。\n\n不难分析得到， 由于PQ是回文字符串， 则P中长度等于Q的前缀应该与Q成倒序关系， 设这个前缀为P1, P中除去P1的后半部分为P2。又因为Q为回文字符串， 所以P1会等于Q， P1为回文字符串。而P2显然也要是回文字符串， 这样才能满足PQ为回文字符串。\n\n**因此， 将问题剥析出来就是：求最小的整数mid（1~n）, 使得P[1, mid]和P[mid+1, n]均为回文字符串。**\n\n**参考代码， 时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long \nstring s;\nint n; \nconst ull P = 131;\nconst int N = 1e5 + 10;\null hh[N], r_hh[N];\null p[N];\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n//获取正哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\n//获取反哈希\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\n//判断回文\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n\nint main() {\n    int T; cin >> T;\n    for(int t=1; t<=T; t++) {\n        cout << \"Case #\" << t << \": \"; \n        cin >> n >> s;\n        s.insert(0, \"0\");//调整下标\n        InitHash();\n        for(int i=1; i<=n; i++) {//枚举mid\n            if(is_palindrome(1, i) && is_palindrome(i+1, n)) {\n                cout << s.substr(1, i) << endl;\n                break;\n            }\n        }\n    }\n}\n```\n\n# 模板类\n\n将相关代码封装为类， 需要时cv即可。\n\n使用时注意：\n\n* 直接传入原字符串\n* 获取子串哈希时， 下标从0开始。\n\n```c++\nclass HashString {\nprivate:\n    typedef unsigned long long ull;\n    const int P = 131;\n    vector<ull> p;\n    vector<ull> prefix;\n    int n;\npublic:\n    HashString(string s) {\n        n = s.size();\n        s.insert(0, \"0\");\n        p.resize(n + 1), p[0] = 1;\n        prefix.resize(n + 1, 0);\n        for(int i=1; i<=n; i++) {\n            p[i] = p[i-1] * P;\n            prefix[i] = prefix[i - 1] * P + s[i];\n        }\n    }\n\n    ull get(int l, int r) {\n        l++, r++;\n        return prefix[r] - prefix[l - 1] * p[r - l + 1];\n    }\n};\n```\n\n\n\n# 参考\n\n[字符串哈希 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/hash/)\n\n[【算法学习笔记】7：字符串前缀哈希法_LauZyHou的博客-CSDN博客](https://blog.csdn.net/SHU15121856/article/details/109553503)\n\n[AcWing 841. 字符串哈希 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/2691/)","tags":["递推","哈希","模板"],"categories":["算法"]},{"title":"一文搞定c++自定义排序","url":"/posts/45215/","content":"\n# 前言\n\nc++拥有强大的STL， 在对复杂的数据结构排序时只需要自定义去比较函数， 然后放到容器内调用api即可。\n\n本该是很简单的东西， 但我之前一直无法记住升序以及降序两种方向该分别怎么写，总是会搞混，  每次都得现场Google。终于下定决心要在今天把它彻底搞定。\n\n# 自定义排序的三种比较器形式\n\n\n\n## 比较函数\n\nSTL中的`sort`函数已经为我们提供了排序算法的框架，我们唯一要做的决定就是对于两个元素`a`和`b`， 谁在前、谁在后？\n\n<!--more-->\n\n\n\n> sort函数的一个原型\n\n```c++\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last);//无比较器， 升序排序， 会调用<进行元素比较, 小的会放前面\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);//传入比较器， 前后顺序由比较强返回值决定\n```\n\n在`sort`函数中这即为第三个参数：比较器\n\n**比较函数的基本形式**:\n\n```\nbool comp(const type& a, const type& b);\n```\n\n一般而言形参的形式为`const`、引用类型（当然不写也可以， 只是这样更安全、效率更高）。\n\n而返回值于a、b的前后关系是**返回true时， a在前面; 返回false时, b在前面.**\n\n如\n\n```c++\nbool comp(const int &a, const int &b) {\n    return a < b;\n}\n```\n\n返回值为`true`时， a在前面， 且`a<b`， 所以会是升序排序。\n\n所以更透彻的讲， 比较函数的内容其实是**a要想排在b前面所要满足的条件**\n\n**简单小例子**\n\n若用pair<string, int> 存储着若干个学生的`name`和`score`信息， 要对这些学生进行排序， \n\n要求：\n\n* 按分数从高到低\n* 分数相等时按名字字典序排列\n\n很容易的可以得到比较函数为\n\n```c++\nbool cmp(const pair<string, int> &a, const pair<string, int> &b) {\n\tif(a.second != b.second) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n```\n\n**lambda表达式**\n\n比较函数在大多场景下可能仅需使用一次， 因此我们可以用lambda表示式来简写\n\n如\n\n```c++\nsort(data.begin(), data.end(), [](const type& a, const type& b) -> bool {\n        //judge something\n    });\n```\n\n\n\n## 重载<运算符\n\n有时候我们会用结构体或类来定义较为复杂的数据结构， 要对它进行自定义排序除了使用比较函数外， 还可以用重载运算符的方式。\n\n以上面的学生例子举例\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu& b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n```\n\n上述代码重载了stu类的`<`运算符，和比较函数不同的时只有一个参数， 但其实只不过是a参数变成了当前的结构体 。\n\n由于`sort`函数默认为升序, 会把用`<`比较的两个函数中小的放前面， 所以函数体编写思想和比较函数完全一致：写入要把a放到前面满足的条件。\n\n\n\n## 函数对象比较器——重载()\n\n其实就是定义一个结构体或类作为比较器， 重载`()`, 这样类名+`()`就成为了比较函数。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n};\n\nstruct cmp {\n    bool operator() (const stu& a, const stu& b) {\n        if(a.score != b.score) {\n            return a.score > b.score;\n        }\n        return a.name < b.name;\n    }\n};\n\nint main() {\n    vector<stu> a{{\"abc\", 100}, {\"acb\", 100}};\n    sort(a.begin(), a.end(), cmp());\n    for(const auto& i : a) {\n        cout << i.name << \" \" << i.score << endl;\n    }\n}\n```\n\n# 容器应用\n\nSTL用两种比较对象来指代排序的两种方向， 分别是`less`和`greater`分别使用`<`和`>`， 对应升序和降序。在众容器中都默认使用less， 所以结构体要使用默认排序需要重载小于运算符。\n\n也可以显示指出方向， 如以下代码对数组进行了降序排序。\n\n```c++\nint main() {\n    vector<int> a{3, 8, 3, 2, 4};\n    sort(a.begin(), a.end(), greater<>());//重载了< / >运算符， 即可使用less<> / greater<>\n}\n```\n\n要注意的是在set， priority_queue这样的容器不能用比较函数的方式， 只能够使用重载的方式实现。\n\n---\n\n以及比较反人类的是当`priority_queue`使用`less`时其实是大根堆， 使用`greater<>`才是小根堆。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu & b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n\nint main() {\n    priority_queue<stu, vector<stu>> heap;\n    heap.push({\"a\", 100});\n    heap.push({\"b\", 100});\n    heap.push({\"c\", 110});\n    while(!heap.empty()) {\n        cout << heap.top().name << \" \" << heap.top().score << endl;\n        heap.pop();\n    }\n}\n\n//输出结果\n/*\nb 100\na 100\nc 110\n\n*/\n```\n","tags":["c++","stl"],"categories":["一文搞定系列"]},{"title":"有点学问在的缩进风格","url":"/posts/57442/","content":"\n### 什么是缩进风格\n\n缩进风格是代码风格的一部分， 是自发形成的一种约定， 用控制代码块缩进的方式传达程序的结构。\n\n缩进风格可以分为两个方面：`缩进大小`和`大括号位置`。\n\n### 缩进大小\n\n缩进在大部分语言中并不是强制要求， 但合理的缩进有利于人类理解程序的结构， 即提高了代码的清晰性。\n\n> 1983年在PASCAL代码上进行的一项实验发现，缩进大小显着影响了可理解性。2 到 4 个字符之间的缩进大小被证明是最佳的。\n\n在大部分的程序语言中， 默认使用四个空格或一个tab键（制表符可以与空格互相转换， 一个'\\t'等于4个空格）\n\n<!--more-->\n\n在部分的脚本语言或HTML中， 可能会使用2个空格， 以避免过长的缩进。\n\n下文中介绍的风格默认使用4字符缩进。\n\n### 大括号位置\n\n大括号用于声明程序的控制语句的作用域， 跟在`(····)`后面。\n\n下面将介绍几种主流的大括号风格。\n\n#### Allman风格\n\n由一位大牛的名字命名， 又叫做`BSD`风格。\n\n该风格的特点是大括号放到控制语句的下一行， 且与控制语句的缩进相同。\n\n```c\nint main()\n{\n\twhile(cond)\n\t{\n\t\tif(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse if(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//do something\n\t\t}\n\t}\n}\n```\n\n可以发现代码块中的代码与控制语句形成明显的区分， 左右大括号位于同一列， 一般而言对人来说更容易匹配到对应的带括号。\n\nallman风格由于其清晰的代码结构， 常被用于教育。但它的缺点是，当代码块较短时（特别是只有一句），  过多的空行会导致程序很长， 容易让人产生阅读压力以及抓不住焦点。\n\n#### K&R风格\n\n不知道你是否听说过被誉为 `“C语言圣经“`的《C程序设计语言》(*`The C programming language`*)， 这本书由两位大牛Kernighan & Ritchie （K&R）编写， 其中Ritchie正是C语言的创造者。\n\nK&R风格便是在这本书中使用的缩进风格， 同时K&R风格及其变体也是目前使用最广泛的风格。\n\nK&R风格的特点：\n\n* 函数的大括号位于单独一行\n* 控制语句的左大括号不换行， else或else if不换行\n* 只有一条语句的代码块不使用大括号, 而是换行后缩进\n\n```c\nint main()\n{\n\twhile (cond) {\n\t\tif (cond) \n\t\t\tputs(\"K&R \");\n\t\telse (cond)\n\t\t\tputs(\"is best style!\")\n\t\t\n\t\tif (cond) {// )与{中间有空格， 这属于其他部分的代码风格\n\t\t\t//do something\n\t\t} else if (cond) {\n\t\t\t//do something\n\t\t} else {\n\t\t\t//do something\n\t\t}\n\t}\n\t\n}\n```\n\n差不多也能体会到， K&R风格总结起来就是：尽可能的压缩代码。 有人分析这是因为这些代码是要打印到书籍上的， 为了降低成本而尽可能的减少代码行数， 因此也有人称之为印刷风格。\n\nK&R的缺点十分明显：左大括号不好找， 尤其在代码块较长时， 很容易找错左大括号。 就可读性而言确实是比不上Allman的， 但在现代IDE智能的高亮和匹配功能下， 也还行？\n\n#### K&R变体 - 1TBS\n\n”一个真正的大括号风格“（One True Brace Style）， 是K&R的变体之一， 主要区别是：1TBS强制使用大括号， 也就是说即使只有一行也需要用大括号而不能省略。\n\n1TBS存在的真实性存有疑问， 有些人认为它是如上所述的K&R变体， 有些人指出它不过是K&R的”行话“。\n\n#### Whitesmiths风格\n\n特点是大括号需要换行， 且需要缩进\n\n```c\nif (cond)\n\t{\n\tputs(\"This is the whitesmiths style\");\n\t}\nelse if (cond)\n\t{\n\tputs(\"like it?\");\n\t}\n```\n\n#### 圣战\n\nAllman风格(左括号换行， 位于左边)和K&R风格(左括号不换行， 位于右边)是两种最广泛使用的大括号风格， 无数程序员争论到底哪种才是最好的。\n\n在舆论上Allman总是占优， K&R被称为\"过时\"/\"伤害眼睛”。但K&R在早期大牛的影响下（如java API源码, linux源码， golang语法风格等等)的影响下， 在除C外的领域仍然是最主流的风格。\n\n### 总结\n\n永远不存在所谓正确的缩进风格， 最重要的事情是在整个程序中都保持一致的代码风格。\n\n---\n\n### 参考\n\n[缩进样式 - 维基百科)](https://en.wikipedia.org/wiki/Indentation_style#cite_note-catb.org-7)\n\n[缩进样式 (catb.org)](http://catb.org/jargon/html/I/indent-style.html)\n\n[indentation style - Slant](https://www.slant.co/topics/2478/~best-indentation-style-in-c)\n","tags":["缩进风格"],"categories":["杂谈"]},{"title":"认识一下吧","url":"/posts/36271/","content":"\n**Hi, 你好,  欢迎来到trudbot的私人网站。这里暂时内容很少， 但它会慢慢丰富**\n\n### 这是什么网站？\n\n这是我的个人博客网站， 使用开源框架`Hexo`， 托管于`github`上;  推荐桌面浏览器打开。\n\n### 这里会有什么内容？\n\n* 技术学习之路中记录笔记或经验分享\n* 有意思的算法题题目及题解分享\n\n### Notes\n\n* 流畅加载资源需要有正常访问github的能力(\n\n* 若引用了文字或其它内容，将以直链标注或在【参考】中注明。","tags":["博客","导读"]}]