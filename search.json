[{"title":"组合数","url":"/posts/40979/","content":"\n本文只解决一个问题：求$C_a^b\\ \\%\\ p$.\n\n## 递归公式（杨辉三角)\n\n### 原理\n众所周知， $C^b_a = C^b_{a-1} + C^{b-1}_{a-1}$.\n\n<!--more-->\n\n可以从组合数的现实意义上证明其正确性：\n\n> $C_a^{b}$表示从a个不同物体中选出b个的所有方案数。\n>\n> 设a个物体中有一个物体x，则$C_a^b$可以分为 包含x的方案 和不包含x的方案。\n>\n> * 包含x， 则还需要从剩余的a-1个物体中再选b-1个， 即为$C^{b-1}_{a-1}$\n> * 不包含x， 则需要从另外的a-1个物体中选b个， 即为$C^b_{a-1}$\n>\n> 因此， $C^b_a = C^b_{a-1} + C^{b-1}_{a-1}$.\n\n使用此公式可以以$O(ab)$的时间复杂度预处理出$C^0_0到C_a^b$范围中所有的组合数。\n\n此方法适用于`a*b`在$1e8$范围内且需要频繁查询的问题。\n\n### 代码实现\n\n**c++**\n\n```cpp\nfor (int i = 0; i <= n; i ++) {\n\tC[i][0] = 1;\n\tfor (int j = 0; j <= i; j ++) {\n\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;\n\t}\n}\n```\n\n## 阶乘公式\n\n### 原理\n众所周知， $C_a^b = \\frac{a!}{b!(a - b)!}$.\n\n可以从排列数的角度证明其正确性：\n\n>$A_a^b$表示有先后顺序的从a个不同物体中选出b个的所有方案数，$A_a^b = \\frac{a!}{(a-b)!}$。\n>\n>若只选取固定的b个物品， 则选取顺序显然有$b!$种。\n>\n>即$A_a^b = b!C_a^b$, $C_a^b = \\frac{a!}{b!(a - b)!}$\n\n通常的， 可以预处理 1~a的阶乘以及阶乘的逆元， 如此一来使用$O(n)$的时间复杂度预处理， 即可$O(1)$的完成每次查询。\n\n但有一个值得注意的问题是， 既然需要计算逆元， 就得保证各阶乘的逆元存在。当p大于a时， 1~a的阶乘必然是存在的， 因为x与p互质、y与p互质， 则x*y同样也与p互质。\n\n所以此方法适用于a小于$1e8$且a小于p的问题。\n\n### 代码实现\n```c++\nfact[0] = inv[0] = 1;\nfor (int i = 1; i <= n; i ++) {\n\tfact[i] = (fact[i - 1] * i) % p;\n\tinv[i] = (inv[i-1] * modPow(i, p - 1, p)) % p;\n}\n```\n\n## Lucas定理\n\n### 原理\n\nLucas定理:\n\n对于素数p， 有\n$$\nC_a^b \\equiv C_{a\\%p}^{b\\%p} \\times C_{\\lfloor \\frac{a}{p}\\rfloor}^{\\lfloor \\frac{b}{p}\\rfloor} \\ (mod \\ p)\n$$\nLucas定理常见的应用场景是: a非常大， 而p较小。\n\n在实现时， 因为p比较小， 我们一般直接计算$C_{a\\%p}^{b\\%p}$. 而$C_{\\lfloor \\frac{a}{p}\\rfloor}^{\\lfloor \\frac{b}{p}\\rfloor}$则递归的使用Lucas定理计算。\n\n### 代码实现\n```cpp\nll lucas(ll a, ll b, ll p) {\n    return b == 0 ? 1 % p : C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\n```\n### 模板题\n> 给定 $n$组询问，每组询问给定三个整数 $a,b,p$其中 $p$是质数，请你输出$C_a^b\\ \\%\\ p$ 的值。\n>\n> #### 输入格式\n>\n> 第一行包含整数 $n$。\n>\n> 接下来 $n$行，每行包含一组 $a,b,p$。\n>\n> #### 输出格式\n>\n> 共 $n$行，每行输出一个询问的解。\n>\n> #### 数据范围\n>\n> $1≤n≤20$\n> $1≤b≤a≤10^{18}$,\n> $1≤p≤10^5$,\n>\n> #### 输入样例：\n>\n> ```\n> 3\n> 5 3 7\n> 3 1 5\n> 6 4 13\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> 3\n> 2\n> ```\n\n#### 参考代码\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5;\nll fact[N], inv[N];\n\nll modPow(ll a, ll n, ll p) {\n    ll res = 1 % p;\n    while (n) {\n        if (n & 1) res = res * a % p;\n        a = a * a % p, n >>= 1;\n    }\n    return res;\n}\n\nll C(ll a, ll b, ll p) {\n    return fact[a] * inv[b] % p * inv[a - b] % p;\n}\n\nll lucas(ll a, ll b, ll p) {\n    return b == 0 ? 1 % p : C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\n\nint main () {\n    int n; cin >> n;\n    while (n -- ) {\n        ll a, b, p; cin >> a >> b >> p;\n        fact[0] = inv[0] = 1 % p;\n        for (ll i = 1; i < p; i ++) {\n            fact[i] = fact[i - 1] * i % p;\n            inv[i] = inv[i - 1] * modPow(i, p - 2, p) % p;\n        }\n        cout << lucas(a, b, p) << endl;\n    }\n    return 0;\n}\n```\n\n### 时间复杂度\n\n$lucas$函数的执行次数显然是$\\log_pa$左右次， 而每次执行的时间复杂度取决于$C$函数。\n\n*  如果像如上代码一样， 预处理p内的阶乘fact和逆元inv， 则C函数的时间复杂度为$O(1)$, lucas算法的时间复杂度为$O(p + \\log_pa)$\n*  如果不予记录， 而是每次都在C函数内递推一遍， 则C函数的时间复杂度为$O(p)$, lucas算法的时间复杂度为$O(p\\log_pa)$.\n\n## 参考\n\n[二项式系数 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/二項式係數)\n\n[排列组合 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/combination/)\n\n[卢卡斯定理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/lucas/#习题)\n\n[卢卡斯定理 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/卢卡斯定理)\n\n[算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/116698264)","tags":["乘法逆元","递推","lucas定理","杨辉三角"],"categories":["离散数学","组合数学"]},{"title":"乘法逆元","url":"/posts/24044/","content":"\n## 定义\n如果整数a, x满足$ax \\equiv 1 (mod \\ p)$, 则将x称为$a\\  mod \\ p$的逆元， 记作$a^{-1}$.\n\n逆元可以理解为模p同余式中a的倒数即$\\frac{1}{a}$, 相似的有一些简单的性质如$(ab)^{-1} \\equiv (a)^{-1}*(b)^{-1} (mod \\ p)， (\\frac{b}{a})^{-1} \\equiv \\frac{a}{b} (mod \\ p) \\ , 1^{-1} \\equiv 1 (mod \\ p)$.\n\n注意， 当a、p不互素时， 不存在相应的逆元。\n\n<!--more-->\n\n## 意义\n\n当我们要求$(\\frac{b}{a}) \\mod p$, 且b数值过大无法直接存储在变量中与a运算， 这时就可以使用乘法逆元。\n\n由乘法逆元定义有$bax \\equiv b (mod \\ p)\\iff bx \\equiv \\frac{b}{a} (mod\\ p)$。\n\n## 求法\n\n### 扩展欧几里得算法\n\n#### 过程\n\n已知， 扩展欧几里得算法可用于求$ax + by = gcd(a, b)$的一组可行解， 而当$a、b$互质时， $ax + by = gcd(a, b) \\iff ax + by = 1 \\iff ax \\equiv 1(mod\\ b)$。\n\n#### 代码实现\n\n**python**\n\n```python\ndef exgcd(a, b):\n    if b == 0: \n        return 1, 0\n    x, y = exgcd(b, a % b)\n    return y, x - y*(a // b)\nans = (exgcd(a, p)[0] % p + p) % p # 求a关于p的逆元\n```\n\n### 费马小定理\n\n费马小定理可用于在p为素数且a、p互质的情况下求$a \\mod p$的逆元。\n\n#### 过程\n\n由费马小定理， 当p为素数且a、p互质时， $a^{p-1} \\equiv 1(\\mod p)$, 而a和a的逆元x满足$ax \\equiv 1(\\mod p)$， 即$a^{p-1} \\equiv ax(\\mod p) \\iff x \\equiv a^{p-2}(\\mod p)$.\n\n所以在满足上述条件时， $a (mod \\ p)$的逆元即为$a^{p-2}(\\mod p)$, 使用快速幂计算即可。\n\n**python**\n\n#### 代码实现\n\n```python\ndef quick_pow(a, n, p):\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a % p\n        a = a * a % p\n        n >>= 1\n    return ans\nans = quick_pow(a, p - 2, p) # 求a关于p的逆元\n```\n\n### 线性求逆元(递推)\n\n递推法用于求`[1, a]`区间的每个数`mod p`的逆元。\n\n#### 过程\n\n$p \\% a = p - a\\lfloor \\frac{p}{a} \\rfloor$ \\ \n\n$\\Rightarrow p\\%a \\equiv - a\\lfloor \\frac{p}{a} \\rfloor (mod \\ p)$ \\ \n\n$\\Rightarrow a \\equiv (p\\%a) \\ / \\ (-\\lfloor \\frac{p}{a} \\rfloor) (mod \\ p)$\\ \n\n$\\Rightarrow a^{-1} \\equiv -\\lfloor \\frac{p}{a} \\rfloor (p\\%a)^{-1}(mod \\ p)$\\ \n\n所以有递推式$inv[n] \\equiv -\\lfloor \\frac{p}{n} \\rfloor * inv[p \\% n] \\ (mod \\ p)$; 而对于始项1，事实上， 对于任意整数p， 都有$1 * 1 \\equiv 1(mod \\ p)$ .\n\n#### 代码实现\n**c++**\n\n```cpp\ninv[1] = 1;\nfor (int i = 2; i <= n; ++i) {\n  inv[i] = (long long)(p - p / i) * inv[p % i] % p;\n}\n```\n\n## 参考\n\n[乘法逆元的几种计算方法 | Menci's OI Blog](https://oi.men.ci/mul-inverse/)\n\n[乘法逆元 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/inverse/)\n\n[乘法逆元详解 - MJT12044 - 博客园 (cnblogs.com)](https://www.cnblogs.com/mjtcn/p/7241896.html)","tags":["乘法逆元","扩展欧几里得算法","费马小定理","快速幂","递推"],"categories":["数论","乘法逆元"]},{"title":"欧几里得算法和扩展欧几里得算法","url":"/posts/5040/","content":"\n## 欧几里得算法\n\n> 在[数学](https://zh.wikipedia.org/wiki/数学)中，**辗转相除法**，又称**欧几里得算法**（英语：Euclidean algorithm），是求[最大公约数](https://zh.wikipedia.org/wiki/最大公约数)的[算法](https://zh.wikipedia.org/wiki/算法)。辗转相除法首次出现于[欧几里得](https://zh.wikipedia.org/wiki/欧几里得)的《[几何原本](https://zh.wikipedia.org/wiki/几何原本)》（第VII卷，命题i和ii）中，而在[中国](https://zh.wikipedia.org/wiki/中国)则可以追溯至[东汉](https://zh.wikipedia.org/wiki/东汉)出现的《[九章算术](https://zh.wikipedia.org/wiki/九章算术)》。\n\n### 过程\n\n欧几里得算法基于一个非常简单的原理：对于两个数a和b(a > b)， a和b的最大公约数与b和a - b的最大公约数相同。\n\n<!--more-->\n\n重复的迭代这个过程， 使$gcd(a, b) \\iff gcd(b, a - b)$. 如此一来， 参数不断减小， 最后某时刻两个参数的值必然相等， 此时a、b的值即为最大公约数.\n\n### 减运算代码实现\n```python\ndef gcd(a, b):\n    if b == a: # 或 if b == 0, 因为b == a时再迭代一次后必然是gcd(a, 0)\n        return a\n    if a < b:\n        return gcd(b, a)\n    return gcd(a - b, b)\n```\n\n![欧几里得算法过程](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/1571057712-3c62fade32895aa.gif)\n\n### 模运算\n但一般情况下， 我们会使用模运算来减少迭代的次数。\n\n设a(a > b)设为`a = kb + c， c < b`， 则用减法的欧几里得迭代过程的前面一部分显然是\n$$\ngcd(kb + c, b) \\iff gcd((k - 1)b + c, b) \\iff ...\\iff gcd(c, b)\n$$\n上述过程可以简化为\n$$\ngcd(a, b) \\iff gcd(a \\% b, b)\n$$\n由此我们可以写出用模运算代替减法运算的代码\n\n### 模运算代码实现\n\n**python**\n```python\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n```\n\n**c++**\n```cpp\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n```\n一个比较巧妙的点是， 如果a < b， 则$gcd(a, b) \\iff gcd(b, a \\% b) \\iff gcd(b, a）$, 通过一次递归调整回了第一个参数较大的情况。\n\n模运算的迭代过程相比减运算是跳跃式的， 所以不一定会经过a==b这个状态， 因此应该以b=0为结束条件。\n\n欧几里得算法的时间复杂度为$O(logn)$, 因为对于a、b(a > b)， a %= b至少会让a减少一半以上。\n\n## 扩展欧几里得算法\n\n### 裴属定理\n\n> 裴属定理：对于任意整数a、b， 都能找到两个整数x、y使得`ax + by = gcd(a, b)`. \n\n设a、b的最大公约数为c， 则有`a = i * c, b = j * c`, 且i、j互质。所以裴属定理的另一种形式是：对于两个互质的整数a、b， 都能找到两个整数x、y使得`ax + by = 1`。\n\n### 过程\n扩展欧几里得算法常用于寻找裴属定理的一组可行解。\n\n设$ax_1 + by_1 = gcd(a, b)$, $x_1$和$y_1$就是我们要求的解。\n\n在欧几里得算法中， 如果要求$gcd(a, b)$， 会递归的求$gcd(b, a \\% b)$.\n\n设$bx_2 + (a \\% b)y_2 = gcd(b, a\\%b)$.\n\n$\\because \\ $$gcd(a, b) = gcd(b, a\\%b)$\n\n$\\therefore \\ ax_1 + by_1 = bx_2 + (a \\% b)y_2$\n\n又$\\because \\ a \\% b = a - b * \\lfloor \\frac{a}{b} \\rfloor$\n\n\n\n$\\therefore \\ ax_1 + by_1 = bx_2 + (a \\% b)y_2 = bx_2 + (a - b * \\lfloor\\frac{a}{b} \\rfloor )y_2$\n\n化简得$ax_1 + by_1 = ay_2 + b(x_2 - y_2)\\lfloor\\frac{a}{b} \\rfloor$, 所以$x_1 = y_2, y_1 = x_2 - y_2\\lfloor\\frac{a}{b} \\rfloor$.\n\n要求$x_1, y_1$， 只需先递归的求出$x_2, y_2$即可。\n\n在欧几里得算法的递归终点$gcd(c, 0)$中, 要使$cx_3 + 0y_3 = gcd(c, 0) = c$, 一组可行的解是$x_3 = 1, y_3 = 0$。到达终点后， 不断回溯对$(x, y)$进行递推， 最后即可得到关于$(a, b)$的一组可行解。\n\n### 代码实现\n\n**python**\n```python\ndef exgcd(a, b):\n    if b == 0: \n        return 1, 0\n    x, y = exgcd(b, a % b)\n    return y, x - y*(a // b)\n```\n\n**c++**\n\n```cpp\nvoid exgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1, y = 0;\n    } else {\n        exgcd(b, a % b, x, y);\n        int t = x;\n        x = y, y = t - y * (a / b);\n    }\n}\n```\n\n## 参考\n\n[辗转相除法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/輾轉相除法)\n\n[小知识：什么是「欧几里得算法」_吴师兄学算法 (cxyxiaowu.com)](https://www.cxyxiaowu.com/995.html)\n\n[最大公约数 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/gcd/)\n\n[裴蜀定理_百度百科 (baidu.com)](https://baike.baidu.com/item/裴蜀定理?fromModule=lemma_search-box#9)\n\n[扩展欧几里得算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/扩展欧几里得算法)","tags":["最大公约数","裴属定理"],"categories":["数论","最大公约数"]},{"title":"素性检验","url":"/posts/42331/","content":"## 背景\n在知乎上冲浪时了解到一种很有趣的数：其所有非空后缀均为素数的数。\n例如`9613`, 其后缀`[9613, 613, 13, 3]`均为素数.\n而此类数的最大值为`357686312646216567629137`.\n\n证明方法非常直接:用计算机枚举. \n不妨为此类数随意的取个名叫做`后缀素数`, 不难发现, 后缀素数P的后缀必然是后缀素数. 因此对于长度为`N`的后缀素数必然可以由 最高位 和 一个长度为`N-1`的后缀素数拼接而成, 如9613可以由是9和613拼接.\n\n<!--more-->\n\n因此我们可以从一位的后缀素数集`[2, 3, 5, 7]`开始, 通过 枚举最高位 + 判断是否为素数, 得到下一级位数的所有后缀素数. 若N位的后缀素数集为空, 则最大的后缀素数就存在于N-1位的后缀素数中.\n\n\n\n## 冲突\n程序的实现可以分为两部分: 判断素数, 循环递推后缀素数.\n\n程序测试时, 等待了几分种仍然没有结果, 这时我才意识到可能程序的时间复杂度太高.我写的判断素数的函数使用的是非常普通的$O(\\sqrt{n})$级别的算法, 在我们已经知道`357686312646216567629137`为答案的情况下, $O(\\sqrt{n})$的算法得出结果或许需要几个小时.此时显然需要更高效的素数判断算法.\n\n## 素性检验\n素性检验是一种概率性检验一个数是否是素数的算法, 换句话说, 素性检验只能得出两种结果: 一个数不是素数 或 一个数大概率是个素数.\n\n\n\n### 费马素性检验(Fermat primality test)\n\n\n\n**费马小定理**\n\n若p是素数, a与p互质, 则 $a^{p-1} \\equiv 1(mod \\ p)$\n\n[维基百科上易懂的证明:](https://zh.wikipedia.org/wiki/费马小定理)\n\n> （i）若$a$是整数，$p$是质数，且$\\gcd(a,p)=1$。若$p$不能整除$x-y$，则$p$不能整除$a(x-y)$。取整数集$A$为所有小于$p$的正整数[集合](集合_(数学) \"wikilink\")（$A$构成$p$的完全剩余系，即$A$中不存在两个数同余$p$），$B$是$A$中所有的元素乘以$a$组成的集合。因为$A$中的任何两个元素之差都不能被$p$整除，所以B中的任何两个元素之差也不能被$p$整除。\n>\n> 换句话说，$\\gcd(a,p)=1$，考虑$1\\times a, 2\\times a, 3\\times a,....(p-1)\\times a$共$(p-1)$个数，將它们分別除以p，除数分別为$r_1,r_2,r_3,....,r_{p-1}$，則集合{r~1~,r~2~,r~3~,\\...,r~p-1~}为集合{1,2,3,\\...,(p-1)}的重新排列，即1,2,3,\\....,(p-1)在除数中恰好各出現一次；这是因为对于任兩个相异k\\*a而言（k=1,2,3\\....(p-1)），其差不是p的倍数（所以不会有相同除数），且任一个k\\*a亦不为p的倍数（所以除数不为0）。因此\n>\n> $$1 \\cdot 2 \\cdot 3 \\cdot \\dots \\cdot (p-1) \\equiv(1 \\cdot a)\\cdot(2 \\cdot a)\\cdot\\dots\\cdot((p-1) \\cdot a) \\pmod{ p},$$\n> 即\n>\n> $$W \\equiv W\\cdot a^{p-1} \\pmod{p},$$\n>\n> 在这里W=1·2·3·\\...·(p\\*1)，且(W, p) =\n> 1，因此将整个公式除以W即得到：\n>\n> $$a^{p-1} \\equiv 1 \\pmod{p}$$\n>\n> 也即 $a^p \\equiv a \\pmod{p}$\n>\n> （ii）若$p$整除$a$，则显然有$p$整除$a^{p}$，即$a^p \\equiv a\\equiv 0 \\pmod{p}$。\n\n**费马伪素数(Fermat pseudoprime)**\n\n对于某些合数x,可以找到与其互质的数a且满足$a^{x-1} \\equiv 1(mod / x)$, 则称合数x为*费马伪素数*, a为x的基. 最小的费马伪素数是341, 以2为基, $2^{340} \\equiv 1(mod \\ 341)$\n\n对于任意大于1的自然数a, 都有无限个以a为基的费马伪素数.\n\n这也说明, 费马小定理的反面是不成立的, 即使对于x能找到a满足同余式, x也不一定是素数.\n\n\n\n**卡迈克尔数(Carmichael number)**\n\n卡迈克尔数是费马小定理反面严格不成立的特例. 卡迈克尔数是正合数x, 且使任意与x互质的数a都满足$a^{x-1} \\equiv 1(mod \\  x)$.最小的卡迈克尔数是561.\n\n---\n\n根据费马小定理, 我们知道, 对于数x, 如果一个数a与x互质, 且$a^{x - 1} \\not\\equiv 1(mod \\ x)$, 则说明x不是一个素数, 将这样的a称为x是合数的凭证(witness).反之, a称为x是素数的强伪证(strong liar).\n\n为了检验x是否是素数, 我们可以选择若干个与x互质的数a, 判断是否$a^{x - 1} \\equiv 1(mod \\ x)$, 若都满足等于1, 则可以说x有可能是素数.\n\n$a$通常在区间`[2, x-1]`中进行选取, 此区间中的数显然都与x互质.\n\npython代码实现如下:\n\n```python\ndef fermat(x, test_time = 8):\n    # 小于3的数直接特判\n    if x <= 2:\n        return x == 2\n    for i in range(1, test_time + 1):\n        a = randint(2, x - 1)\n        # quick_pow为快速幂\n        if quick_pow(a, x - 1, x) != 1:\n            return False\n    return True\n```\n\n### 米勒-拉宾素性检验(Miller–Rabin primality test)\n\n当检验的数据范围增大时, 费马素性检验的正确率就满足不了人们的需求了.\n\n\n\n**二次探测定理**\n\n如果$p$是奇素数, 则$x^2 \\equiv 1(mod \\ p)$的解为$x \\equiv 1(mod \\ p)$或$x \\equiv -1(mod / p)$.\n\n特别的, 其小于p的解为$x \\equiv 1(mod \\ p)$或$x \\equiv p-1(mod \\ p)$\n\n> 特别提出其小于p的解是因为, 在诸多编程语言中, 模的结果不会取负数.\n\n证明:\n\n$$x^2 \\equiv 1(mod \\ p) \\iff (x + 1)(x - 1) \\equiv 0(mod \\ p) $$\n\n---\n\n前面我们知道, 在`[2, x-1]`取一数a, 如果$a^{x - 1} \\equiv 1(mod \\ x)$, 并不能说明x一定是素数, Miller-Rabin素性检验正是在这一步做进一步的纵深, 提高正确率.\n\n设`[a, x]`已经通过了费马检验, 即$a^{x - 1} \\equiv 1(mod \\ x)$, 且x不为偶数(特判2因子).\n\n由于x - 1是偶数, 所以可以转化为二次探测的格式:$a^{x - 1} \\equiv 1(mod \\ x) \\iff (a^{\\frac{x - 1}{2}})^2 \\equiv 1(mod \\ x)$.\n\n我们的目标是检验x是否是素数, 所以根据二次探测定理, 可以判断是否满足$a^{\\frac{x - 1}{2}} \\equiv 1(mod \\ x)$或$a^{\\frac{x - 1}{2}} \\equiv x-1(mod \\ x)$\n\n这时候会有三种结果:\n\n* 不符合二次探测定理, 此时可以断定x不为素数\n* $a^{\\frac{x - 1}{2}} \\equiv 1(mod \\ x)$. 如果$\\frac{x - 1}{2}$不是奇数, 则模仿前面的过程, 进行二次探测检验($a^{\\frac{x - 1}{4}}$);如果是奇数, 停止检验.\n* $a^{\\frac{x - 1}{2}} \\equiv x - 1(mod \\ x)$, 停止检验\n\npython程序实现如下:\n\n```python\ndef miller_rabin(x, test_time = 8):\n    if x < 3 | (x & 1):\n        return x == 2\n    for i in range(1, test_time + 1):\n        a = randint(2, x - 1)\n        # 费马小定理检验\n        if quick_pow(a, x - 1, x) != 1:\n            return False\n        # 二次探测定理检验\n        y = x - 1\n        while y % 2 == 0:\n            y //= 2\n            z = quick_pow(a, y, x)\n            if z == x - 1:\n                break\n            elif z != 1:\n                return False\n    return True   \n```\n\n## 验证\n\n回到最初的问题上, 现在我们已经有时间复杂度足够低($log^3n$)的算法来判断一个数是否是素数.\n\n后缀素数的递推代码如下:\n\n```python\nstart = time.time()\nprimes = [2, 3, 5, 7]\nj = 10\nwhile True:\n    new = []\n    for x in primes:\n        for i in range(1, 10):\n            a = i * j + x\n            if (miller_rabin(a)):\n                new.append(a)\n    if len(new) == 0:\n        print(\"answer:\", primes)\n        break\n    j *= 10\n    primes = new\nend = time.time()\nprint('time cost', end - start, 's')\n```\n\n运行结果如下:\n\n![运行结果](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/image-20230125211153759.png)\n\n## 参考\n\n[米勒-拉宾素性检验 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/米勒-拉宾检验)\n\n[【朝夕的ACM笔记】数论-Miller Rabin素数判定 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/349360074)\n\n[卡迈克尔数 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/卡邁克爾數)\n\n[Fermat pseudoprime - Wikipedia](https://en.wikipedia.org/wiki/Fermat_pseudoprime)\n\n[算法学习笔记(48): 米勒-拉宾素性检验 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/220203643)\n\n[费马素性检验 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/费马素性检验)","tags":["费马小定理","素数","数论","二次探测定理"],"categories":["数论","素数"]},{"title":"欧拉图","url":"/posts/29020/","content":"> 欧拉通路(路径): 一条经过了图中所有边的路径， 且每条边仅经过一次。\n> 欧拉回路: 起点和终点相同的欧拉通路。\n> 欧拉图: 存在欧拉回路的图\n> 半欧拉图: 不存在欧拉回路， 但存在欧拉通路的图\n\n之所以以欧拉的名字命名， 是因为欧拉解决了与此紧密相关的**一笔画问题**， 即在不重复、折返的情况下遍历一张无向图。\n\n![欧拉图示例](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/Euler-3.jpg)\n\n<!--more-->\n\n### 判别欧拉图\n\n欧拉图的判断可以使用欧拉提出的“一笔画定理”。\n\n\n\n> 连通的无向图有欧拉路径的充要条件是：![G](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b)中奇顶点（连接的边数量为奇数的顶点）的数目等于0或者2。\n>\n> 连通的无向图是欧拉图（存在欧拉回路）的充要条件是：中每个顶点的度都是偶数。\n\n证明可见:[一笔画问题 - 维基百科](https://zh.wikipedia.org/wiki/一笔画问题)\n\n#### 例题——欧拉路径\n> 判断一无向图是欧拉图、半欧拉图还是非欧拉图\n>  **输入格式**\n>\n> 第一行包含两个整数 N 和 M，表示无向图的点和边的数量。\n>\n> 接下来 M 行，每行包含两个整数 a,b，表示点 a 和 b 之间存在一条边。\n>\n> 所有点的编号从 **1∼N**。\n>\n> **输出格式**\n> 输出对该图的判断，`Eulerian`（欧拉图），`Semi-Eulerian`（半欧拉图），`Non-Eulerian`（非欧拉图）。\n>\n> 行尾不得有多余空格。\n\n**代码实现**\n\n* 使用并查集判断图是否连通\n* 构造顶点的度数组， 用于判断欧拉图\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510;\nint p[N], d[N];\nint n, m;\n\nint find(int x) {\n    if (x == p[x]) return x;\n    return p[x] = find(p[x]);\n}\n\n//使用并查集判断图是否连通\nbool isConnected() {\n    for (int i = 2; i <= n; i ++) {\n        if (find(i) != find(1)) return false;\n    }\n    return true;\n}\n\n//判断图中是否有欧拉路径\nbool hasEulerianPath() {\n    int odd = 0;\n    for (int i = 1; i <= n && odd <= 2; i ++) {\n        if (d[i] & 1) odd ++;\n    }\n    return odd == 0 || odd == 2;\n}\n\n//判断图中是否有欧拉回路\nbool hasEulerianCircuit() {\n    for (int i = 1; i <= n; i ++) {\n        if (d[i] & 1) return false;\n    }\n    return true;\n}\n\nint main () {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) p[i] = i;\n    while (m --) {\n        int a, b; cin >> a >> b;\n        d[a] ++, d[b] ++;\n        p[find(a)] = find(b);\n    }\n    \n    if (!isConnected()) cout << \"Non-Eulerian\";\n    else if (hasEulerianCircuit()) cout << \"Eulerian\";\n    else if (hasEulerianPath()) cout << \"Semi-Eulerian\";\n    else cout << \"Non-Eulerian\";\n    \n    return 0;\n}\n\n```\n\n### 求欧拉回路\n\n求欧拉回路一般使用**Hierholzer**算法。\n\n*Hierholzer算法*的基本流程如下：\n\n* 从任一点开始对图进行dfs遍历\n* 遍历过程中经过的边直接删除\n* 当一个顶点的出度减为0时， 加入栈中\n* dfs结束后， 将栈中元素出栈， 即为一条欧拉回路\n\n伪代码即为：\n\n```cpp\ndfs(node u) {\n    while (!u.edges.empty()) {\n        node next = u.edges.back();\n        u.edges.pop_back();\n        dfs(next);\n    }\n    stk.push(u);\n}\n```\n\n性质一： dfs的起点就是得到的欧拉回路的起点\n\n性质二： 若要求从某起点出发、字典序最小的欧拉回路， 只需要在遍历边时贪心的选择顶点编号最小的边即可， 可以使用排序或优先队列。\n\n#### 例题——重新安排行程\n\n> 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n>\n> 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n>\n> 例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前。\n> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n>\n> 来源：力扣（LeetCode）\n> 链接：https://leetcode.cn/problems/reconstruct-itinerary\n> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n> \n\n**Solution**\n显然这题是有向边求字典序最小的的欧拉回路。\n由于顶点是用字符串代表， 所以用哈希表记录每个顶点的出边集。\n预先对出边集排序， 在遍历时看最小的出边。\n\n```cpp\nclass Solution {\npublic:\n    map<string, vector<string>> e;\n    vector<string> stk;\n\n    void dfs(string u) {\n        while (e[u].size()) {\n            string ne = e[u].back(); e[u].pop_back();\n            dfs(ne);\n        }\n        stk.push_back(u);\n    }\n\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        for (auto &v : tickets) {\n            e[v[0]].push_back(v[1]);\n        }\n        for (auto &[s, v] : e) {\n            sort(v.begin(), v.end(), greater<>());\n        }\n        dfs(\"JFK\");\n        reverse(stk.begin(), stk.end());\n        return stk;\n    }\n};\n```","tags":["一笔画","dfs"],"categories":["图论"]},{"title":"矩阵快速幂","url":"/posts/25991/","content":"\n来聊聊如何将快速幂的思想应用到矩阵乘法上， 以及矩阵快速幂的应用。\n\n## 矩阵快速幂\n\n### 矩阵乘法\n\n在线性代数中学过， n行x列的矩阵A与x行m列的矩阵B是可以相乘的， 结果为一个n行m列的矩阵R， 且$R_{ij} = \\sum^{x}_{k = 1} A_{ik} * B_{kj}$.\n\n而对于方阵$M_{nn}$, 又有**幂**的概念， $M^n = M * M * M * ... * M$, 即n个M矩阵相乘.\n\n<!--more-->\n\n由此我们可以定义矩阵类型， 并实现矩阵乘法。\n\n```c++\n#define N 2\nstruct matrix {\n    int m[N][N];\n\n    matrix() {\n        memset(m, 0, sizeof(m));\n    }\n\n    matrix operator * (const matrix& b) const {\n        matrix res;\n        for (int i = 0; i < N; i ++) \n            for (int j = 0; j < N; j ++) \n                for (int k = 0; k < N; k ++)\n                    res.m[i][j] += m[i][k] * b.m[k][j];\n        return res;\n    }\n};\n```\n\n\n\n### 快速幂思想\n\n快速幂的细节不多说， 简单说快速幂的思想， 就是： 计算$a^n$时， 可以先计算$a^{\\frac{n}{2}}$, 再用$a^{\\frac{n}{2}} * a^{\\frac{n}{2}}$得到$a^n$。\n\n可以发现， 计算$a^n$只比$a^{\\frac{n}{2}}$多了一次（若n为奇数还要多一次), 相比于暴力做法(n / 2次)优秀很多， 而时间复杂度也从$O(n)$优化为$O(logn)$。\n\n### 矩阵快速幂\n\n我们可以套用快速幂的模板， 写出矩阵快速幂的代码。\n\n```cpp\nmatrix qpow(matrix a, int p) {\n    matrix res;\n    for (int i = 0; i < N; i ++) res.m[i][i] = 1; //单位矩阵\n    while (p) {\n        if (p & 1) res = res * a;\n        a = a * a;\n        p >>= 1;\n    }\n    return res;\n}\n```\n\n到此， 矩阵快速幂的实现就完成了。\n\n## 矩阵快速幂的应用\n\n### 典中典——斐波那契数列\n\n假设有这样一个问题：对于整数n， $n \\in (1, 1e9)$， 在1s内求出斐波那契数列的第n项模p的结果。\n\n显然常规$O(n)$做法是行不通的。\n\n斐波那契数列我们都知道存在关系式$f_n = f_{n-1} + f_{n-2}$, 那我们能否通过构造多项式， 将$f_n$和$f_1$联系起来， 得到一个公式呢？倘若这样， 才有可能在$O(n)$内完成。\n\n将$f_n和f_{n-1}$设为一个行向量， 则\n$$\n\\begin{pmatrix}\nf_n \\ f_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{n-1}+f_{n-2}\\ \\ f_{n-1}\n\\end{pmatrix}\n$$\n\n\n是否能通过$(f_{n-1} \\ f_{n-2})$来表示$(f_n \\ f_{n-1})$呢？\n\n可以发现\n$$\n\\begin{pmatrix}\nf_n\\\nf_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{n-1} + f_{n-2}\\ \nf_{n-1}\n\\end{pmatrix}\n =\n \\begin{pmatrix}\nf_{n-1}\\ \nf_{n-2}\n\\end{pmatrix}\n* \n \\begin{pmatrix}\n1\\  0 \\\\\n1 \\ 1\n\\end{pmatrix}\n$$\n将$f_{n-1}, f_{n-2}$看作自变量， 则$1 \\ 0 \\\\1 \\ 1$即为$(f_n, f_n-1)$的系数矩阵.\n\n由此递推可得\n$$\n\\begin{pmatrix}\nf_n\\\nf_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_1\\\nf_0\n\\end{pmatrix}\n*\n{\\begin{pmatrix}\n1\\  0 \\\\\n1 \\ 1\n\\end{pmatrix}}^{n-1}\n$$\n所以我们的主要任务就是算出此系数矩阵的n-1次幂，也就可以用上述提到的矩阵快速幂， 这样即使n是$10^9$也不会超时。 \n\n","tags":["快速幂","矩阵乘法"],"categories":["算法"]},{"title":"高精度模板","url":"/posts/61750/","content":"\n最近发现了一个很有意思的网站：codewars， 上面有很多有趣的'kata'， 通过kata可以提升你的段位。\n\ncodewars上的题目和传统的竞赛题目的风格不太一样， 而且用户是可以创建kata的， 这一点我觉得很有意思。\n\n在codewars中老是遇到高精度的题目(高精度在普通OJ中基本只有模板题)， 每次都要手写及处理细节十分的腻，于是决定把高精度好好的写一遍记录下来， 供未来copy。\n\n<!--more-->\n\n## 高模板模板类\n\n包含：\n\n* 高精度加高精度\n* 高精度减高精度\n* 高精度乘低精度\n* 高精度乘高精度\n* 高精度除以低精度\n* 高精度除以高精度\n\n```cpp\nnamespace BigNumber {\n    static string reversed(string &s) {//反转字符串并返回\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    static bool comp(string a, string b) {//判断a大于等于b\n        if (a.size() != b.size()) return a.size() > b.size();\n        return a > b || a == b;\n    }\n\n    static string add(string a, string b) {//高精度加高精度\n        string ans;\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry) {\n            if (i >= 0) carry += a[i--] - '0';\n            if (j >= 0) carry += b[j--] - '0';\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static string subtract(string a, string b) {//高精度减高精度\n        if (!comp(a, b)) return \"-\" + subtract(b, a);\n        string ans;\n        int n = a.size(), m = b.size(), carry = 0;\n        for (int i = n - 1, j = m - 1; i >= 0; i--, j--) {\n            carry += a[i] - '0';\n            if (j >= 0) carry -= b[j] - '0';\n            if (carry < 0) ans.push_back(carry + 10 + '0'), carry = -1;\n            else ans.push_back(carry + '0'), carry = 0;\n        }\n        while (ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return reversed(ans); \n    }\n\n    \n    template<typename T>\n    static string multiply(string s, T b) {//高精度乘以低精度\n        if (b == 0) return \"0\";\n        reversed(s);\n        string ans;\n        for (T i = 0, carry = 0; i < s.size() || carry; i++) {\n            if (i < s.size()) carry += (s[i] - '0') * b;\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static string multiply(string a, string b) {//高精度乘以高精度\n        reversed(a), reversed(b);\n        vector<int> ans(a.size() + b.size(), 0);\n        for (int i = 0; i < a.size(); i ++) \n            for (int j = 0; j < b.size(); j ++)\n                ans[i + j] += (a[i] - '0')  *(b[j] - '0');\n        int carry = 0; string res;\n        for (int i = 0; i < ans.size(); i ++) {\n            ans[i] += carry, carry = ans[i] / 10, ans[i] %= 10;\n            res.push_back(ans[i] + '0');\n        }\n        while(res.back() == '0' && res.size() > 1) res.pop_back();\n        return reversed(res);\n    }\n    \n    template<typename T>\n    static pair<string, T> divide(string a, T b) {//高精度除以低精度\n        if (b == 0) return {\"ERROR\", 0};\n        T r = 0;\n        string ans;\n        for (int i = 0; i < a.size(); i ++) {\n            r = r * 10 + a[i] - '0';\n            ans.push_back(r / b + '0'), r %= b;\n        }\n        reversed(ans);\n        while(ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return {reversed(ans), r};\n    }\n\n    static pair<string, string> divide(string a, string b) {//高精度除以高精度， 复杂度较高\n        if (b == \"0\") return {\"ERROR\", \"ERROR\"};\n        if (!comp(a, b)) return {\"0\", a};\n        int t = a.size() - b.size();\n        string ans;\n        for (int i = 0; i < t; i ++) b.push_back('0');\n        while (t >= 0) {\n            int cnt = 0;\n            while(comp(a, b)) a = subtract(a, b), cnt++;\n            ans.push_back(cnt + '0');\n            b.pop_back();\n            t--;\n        }\n        reversed(ans);\n        if (ans.back() == '0') ans.pop_back();\n        return {reversed(ans), a};\n    }\n}\n```\n\n## 实例 [codewars](https://www.codewars.com/kata/58a3fa665973c2a6e80000c4/) 2kyu--Challenge Fun #10: Integer Square Root\n\n> ### Task\n>\n> For each given a number N, the integer S is called `integer square root` of N if `S x S <= N` and `(S+1) x (S+1) > N`.\n>\n> In other words, `S = Math.floor(Math.sqrt(N))`\n>\n> Your task is to calculate the `integer square root` of a given `Number`.\n>\n> Note: Input is given in string format. That is, the `Number` may be very very large ;-)\n>\n> ### Example\n>\n> For: `Number = \"4\"`, result = `\"2\"`.\n>\n> For: `Number = \"17\"`, result = `\"4\"`.\n>\n> For: `Number = \"101\"`, result = `\"10\"`.\n>\n> For: `Number = \"23232328323215435345345345343458098856756556809400840980980980980809092343243243243243098799634\"`, result = `\"152421548093487868711992623730429930751178496967\"`.\n>\n> ### Input/Output\n>\n> - `[input]` string `Number`\n>\n> number in decimal form. \n>\n> 0 < Number < 10^100^\n>\n> - `[output]` a string\n>\n> integer squareroot of `Number`.\n\n显然是一道高精度二分， 调用模板完成即可。\n\n```cpp\nusing namespace BigNumber;\nstring integer_square_root(string n) {\n  string l = \"0\", r = n;\n  while (!comp(l, r)) {\n    auto [mid, rem] = divide(add(add(l, r), \"1\"), 2);\n    if (comp(n, multiply(mid, mid))) l = mid;\n    else r = subtract(mid, \"1\");\n  }\n  return l;\n}\n```\n\n## C++大数类模板\n\n我们可以模仿java的`BigInteger`类， 写一个c++类来模拟正常的整数的各种运算。\n\n由于c++的重载运算符功能， 我们可以做到和原生几乎没有使用区别。\n\n以下是尝试性的实现。\n\n```c++\n//\n// Created by trudbot on 2023/1/19.\n//\n\n#include \"iostream\"\n#include \"string\"\n#include \"algorithm\"\n#include \"map\"\n\nclass BigInteger {\npublic:\n    BigInteger() {}\n\n    BigInteger(long long num) {\n        if (num < 0) {\n            this->data = std::to_string(num).substr(1);\n            this->sign = -1;\n        } else {\n            this->data = std::to_string(num);\n            this->sign = 1;\n        }\n    }\n\n    BigInteger(std::string num) {\n        if (num[0] == '-') {\n            this->data = num.substr(1);\n            sign = -1;\n        } else {\n            this->data = num;\n            sign = 1;\n        }\n    }\n\n    BigInteger(const std::string& num, int sign) {\n        this->data = num, this->sign = sign;\n    }\n\n    BigInteger operator+(const BigInteger& b) const {\n        BigInteger ans;\n        if (this->sign == 1 && b.sign == 1) {\n            ans = BigInteger(add(this->data, b.data), 1);\n        } else if (this->sign == 1 && b.sign == -1) {\n            ans = BigInteger(subtract(this->data, b.data));\n        } else if (this->sign == -1 && b.sign == 1) {\n            ans = BigInteger(subtract(b.data, this->data));\n        } else {\n            ans = BigInteger(add(this->data, b.data), -1);\n        }\n        return ans;\n    }\n\n    BigInteger operator+(long long & b) const {\n        return this->operator+(BigInteger(b));\n    }\n\n    BigInteger operator-(const BigInteger &b) const {\n        BigInteger ans;\n        if (this->sign == 1 && b.sign == 1) {\n            ans = BigInteger(subtract(this->data, b.data));\n        } else if (this->sign == 1 && b.sign == -1) {\n            ans = BigInteger(add(this->data, b.data));\n        } else if (this->sign == -1 && b.sign == 1) {\n            ans = BigInteger(add(this->data, b.data), -1);\n        } else {\n            ans = BigInteger(subtract(b.data, this->data));\n        }\n        return ans;\n    }\n\n    BigInteger operator*(const BigInteger &b) {\n        return BigInteger(multiply(this->data, b.data), this->sign * b.sign);\n    }\n\n    BigInteger operator/(const BigInteger &b) {\n        if (lessEqual(b.data, limit)) {\n            return BigInteger(divide(this->data, std::stoll(b.data)).first, this->sign * b.sign);\n        }\n        return BigInteger(divide(this->data, b.data).first, this->sign * b.sign);\n    }\n\n    BigInteger operator%(const BigInteger &b) const {\n        return BigInteger(divide(this->data, b.data).second);\n    }\n\n    void operator*=(const BigInteger &b) {\n        this->sign *= b.sign;\n        this->data = multiply(this->data, b.data);\n    }\n\n    void operator/=(const BigInteger &b) {\n        this->sign *= b.sign;\n        if (lessEqual(b.data, limit)) {\n            this->data = divide(this->data, std::stoll(b.data)).first;\n        } else {\n            this->data = divide(this->data, b.data).first;\n        }\n    }\n\n    void operator++() {\n        *this = *this + 1;\n    }\n\n    void operator--() {\n        *this = *this - 1;\n    }\n\n    BigInteger& operator=(const BigInteger& b) {\n        this->data = b.data, this->sign = b.sign;\n        return *this;\n    }\n\n    template<typename T>\n    BigInteger& operator=(const T& b) {\n        *this = BigInteger(b);\n        return *this;\n    }\n\n    bool operator==(const BigInteger &b) {\n        return this->sign == b.sign && this->data == b.data;\n    }\n\n    bool operator<(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return true;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return less(this->data, b.data);\n        } else {\n            return greater(this->data, b.data);\n        }\n    }\n\n    bool operator>(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return false;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return greater(this->data, b.data);\n        } else {\n            return less(this->data, b.data);\n        }\n    }\n\n    bool operator<=(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return false;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return true;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return lessEqual(this->data, b.data);\n        } else {\n            return greaterEqual(this->data, b.data);\n        }\n    }\n\n    bool operator>=(const BigInteger &b) {\n        if (this->sign == 1 && b.sign == -1) {\n            return true;\n        } else if (this->sign == -1 && b.sign == 1) {\n            return false;\n        } else if (this->sign == 1 && b.sign == 1) {\n            return greaterEqual(this->data, b.data);\n        } else {\n            return lessEqual(this->data, b.data);\n        }\n    }\n\n    bool operator!=(const BigInteger &b) {\n        return this->sign != b.sign || this->data != b.data;\n    }\n\n    friend std::ostream &operator<<(std::ostream &output, const BigInteger &integer) {\n        if (integer.sign == -1) {\n            output << \"-\" << integer.data;\n        } else {\n            output << integer.data;\n        }\n        return output;\n    }\n\n    friend std::istream &operator>>(std::istream  &input, BigInteger &integer) {\n        std::string s;\n        input >> s;\n        integer = BigInteger(s);\n        return input;\n    }\n\n    BigInteger pow(long long n) {\n        BigInteger res = 1, a = *this;\n        while (n) {\n            if (n & 1) res = res * a;\n            a = a * a;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    std::string value() {\n        return this->data;\n    }\n\nprivate:\n    std::string data;\n    int sign = 0;\n    const std::string limit = \"9223372036854775807\";\n\n    static std::string reversed(std::string &s) {//反转字符串并返回\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    static bool greaterEqual(const std::string& a, const std::string& b) {//判断a大于等于b\n        return greater(a, b) || a == b;\n    }\n\n    static bool less(const std::string& a, const std::string& b) {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n\n    static bool greater(const std::string& a, const std::string& b) {\n        if (a.size() != b.size()) return a.size() > b.size();\n        return a > b;\n    }\n\n    static bool lessEqual(const std::string& a, const std::string& b) {\n        return less(a, b) || a == b;\n    }\n\n    static std::string add(std::string a, std::string b) {//高精度加高精度\n        std::string ans;\n        int i = (int)a.size() - 1, j = (int)b.size() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry) {\n            if (i >= 0) carry += a[i--] - '0';\n            if (j >= 0) carry += b[j--] - '0';\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static std::string subtract(std::string a, std::string b) {//高精度减高精度\n        if (!greaterEqual(a, b)) return \"-\" + subtract(b, a);\n        std::string ans;\n        int n = a.size(), m = b.size(), carry = 0;\n        for (int i = n - 1, j = m - 1; i >= 0; i--, j--) {\n            carry += a[i] - '0';\n            if (j >= 0) carry -= b[j] - '0';\n            if (carry < 0) ans.push_back(carry + 10 + '0'), carry = -1;\n            else ans.push_back(carry + '0'), carry = 0;\n        }\n        while (ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return reversed(ans);\n    }\n\n    static std::string multiply(std::string s, long long b) {//高精度乘以低精度\n        if (b == 0) return \"0\";\n        reversed(s);\n        std::string ans;\n        for (size_t i = 0, carry = 0; i < s.size() || carry; i++) {\n            if (i < s.size()) carry += (s[i] - '0') * b;\n            ans.push_back(carry % 10 + '0');\n            carry /= 10;\n        }\n        return reversed(ans);\n    }\n\n    static std::string multiply(std::string a, std::string b) {//高精度乘以高精度\n        reversed(a), reversed(b);\n        int n = a.size() + b.size(), ans[n];\n        for (int i = 0; i < n; i ++) ans[i] = 0;\n        for (int i = 0; i < a.size(); i ++)\n            for (int j = 0; j < b.size(); j ++)\n                ans[i + j] += (a[i] - '0')  *(b[j] - '0');\n        int carry = 0; std::string res;\n        for (int i = 0; i < n; i ++) {\n            ans[i] += carry, carry = ans[i] / 10, ans[i] %= 10;\n            res.push_back(ans[i] + '0');\n        }\n        while(res.back() == '0' && res.size() > 1) res.pop_back();\n        return reversed(res);\n    }\n\n    static std::pair<std::string, long long> divide(const std::string& a, long long b) {//高精度除以低精度\n        if (b == 0) return {\"ERROR\", 0};\n        long long r = 0;\n        std::string ans;\n        for (char i : a) {\n            r = r * 10 + i - '0';\n            ans.push_back(r / b + '0'), r %= b;\n        }\n        reversed(ans);\n        while(ans.size() > 1 && ans.back() == '0') ans.pop_back();\n        return {reversed(ans), r};\n    }\n\n    static std::pair<std::string, std::string> divide(std::string a, std::string b) {//高精度除以高精度， 复杂度较高\n        if (b == \"0\") return {\"ERROR\", \"ERROR\"};\n        if (less(a, b)) return {\"0\", a};\n        int t = a.size() - b.size();\n        std::string ans;\n        for (int i = 0; i < t; i ++) b.push_back('0');\n        while (t >= 0) {\n            int cnt = 0;\n            while(greaterEqual(a, b)) a = subtract(a, b), cnt++;\n            ans.push_back(cnt + '0');\n            b.pop_back();\n            t--;\n        }\n        reversed(ans);\n        if (ans.back() == '0') ans.pop_back();\n        return {reversed(ans), a};\n    }\n};\n```\n\n\n\n用此模板， 上面那题的代码可改成\n\n```c++\nusing namespace std;\nusing Int = BigInteger;\n\nstring integer_square_root(string args) {\n  Int n = Int(args);\n  Int l = 0, r = n;\n  while (l < r) {\n    Int mid = (l + r + 1) / 2;\n    if (mid * mid <= n) l = mid;\n    else r = mid - 1;\n  }\n  return l.value();\n}\n```\n\n","tags":["模板","高精度","codewars"]},{"title":"最短路算法","url":"/posts/789/","content":"\n> 最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。\n\n![最短路算法概览](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png)\n\n# 单源最短路\n即对确定的源点（起点）， 求它到其它所有可达的点的最短路径。\n对于单源最短路算法， 又可以分为处理正权边图和带负权边图的两种。\n\n<!--more-->\n\n## 正权图——Dijkstra算法\n\n个人认为对Dijkstra算法的一个很形象的描述是： 将边看作一条条水渠， 边的权为水渠的长度(m)。在源点处倒入水， 假设水的速度恒定为1m/s， 那么**当水首次流到顶点X时， 所经过的时间就是源点到X的最短路径长度。**\n\n以下图举例：\n\n![例图](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n假设从A倒入水， 水四散向每个可能的方向流出。那么水流首先会到达B顶点， 这也是水流第一次经过B顶点， 所以A-B的最短路径长度即为1。 类似的， 我们可以得出水流依次经过的顶点顺序为`A -> B -> C -> D -> D`， 其中D取第一次经过时的时间， 也就是9。\n\nDijkstra算法的思想基本如此， 但抽象为计算机语言却有些不同， 接下来讲讲Dijkstra算法的实现过程。\n\n- 将顶点编号为1~n\n- 维护一个数组dist， dist[i]表示目前顶点i和源点的最短路径长度， 开始时dist初始化为正无穷， 而源点的dist设为0, 表示当前只知道源点到源点的路径长度为0.\n\n整个Dijkstra算法就是基于bfs以及贪心对dist数组更新的一个过程。\n\n在算法中重复执行此过程： 取出目前未遍历过且dist最小的一个顶点， 更新其所有指向的顶点的dist\n\n例如以此图举例\n\n![例图](https://raw.githubusercontent.com/trudbot/trudbot_images/main/md_img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n第一次： dist[A] = 0， 其它都为正无穷， 因此遍历A结点， 并更新A指向的所有结点的dist\n\n更新完毕后dist[B] = 1, dist[C] = 5, dist[D] = 10.\n\n第二次： 取出B顶点遍历， dist[D] = min (dist[D], dist[B] + weight(B -> D)) （这一步也叫做松弛操作)， 所以dist[D]被更新为9\n\n以此类推。\n\n以不严谨的角度， 可以稍微解释下Dijkstra算法的正确性： 每次都只选择dist最小的顶点， 是因为dist更大的顶点可能被dist小的顶点再加一段路径而更新掉， 而最小的dist在没有负权边的情况下必然是最短路径。\n\n在代码实现上， 由选择dist最小顶点的手段的不同可以分为朴素Dijkstra和堆优化Dijkstra\n\n### 朴素Dijkstra\n\n朴素版本的Dijkstra在选择顶点时， 采用的方式是直接遍历dist数组， 而选出未被遍历过且dist最小的顶点。\n\n每次选择至少都会确定一个顶点的最短路径， 所以至多要选择n次； 而每次选择的过程中都要遍历一次dist数组， 因此时间复杂度为$O(n^2)$\n\n```cpp\nint n, m, g[N][N];\nint vis[N], dist[N];\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= n; i ++) {\n        int t = -1;\n        for (int j = 1; j <= n;  j++) {\n            if (!vis[j] && (t == -1 || dist[j] < dist[t])) {\n                t = j;\n            }\n        }\n        vis[t] = 1;\n        for (int j = 1; j <= n; j ++) {\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        }\n    }\n}\n```\n\n### 堆优化Dijkstra\n\n前面提到过Dijkstra本质上可以看成一个bfs的过程， 但bfs下次要遍历的顶点并不像普通的bfs那样随意， 而是要选择dist最小的顶点。 我们可以用优先队列(小根堆)来实现这一过程， 每次选择时， 直接取出堆顶元素， 然后更新dist并把被更新过的顶点及其dist加入优先队列。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint vis[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid dijkstra (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    priority_queue<pii, vector<pii>, greater<>> heap;\n    heap.push({0, src});\n    while (heap.size()) {//以堆被清空为结束标志\n        auto [v, x] = heap.top(); heap.pop();\n        if (vis[x]) {//已被遍历过， 直接跳过\n            continue;\n        }\n        vis[x] = true;\n        for (int i = h[x], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (v + w[i] < dist[j]) {//被更新\n                dist[j] = v + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n}\n```\n\n优先队列让取出dist最小的顶点能以O(1)的代价实现， 但每次取出后的调整为O($logn$)， 遍历所有边为O($mlogn$)， 因此时间复杂度为$O((n + m) logn)$\n\n### 两种实现方式的适用场景\n\n虽然堆优化Dijkstra的时间复杂度看上去比朴素算法更优秀， 但堆优化的时间会受到边数的影响， 当边数与顶点数的平方为一个量级时， 堆优化的时间和空间开销都不乐观。\n\n所以一般的， 当图为稠密图时（m 与 n^2^同一个量级), 使用邻接矩阵存储， 朴素Dijkstra；当图为稀疏图时(m远小于n^2^)， 使用邻接表存储， 堆优化Dijkstra.\n\n## 负权图最短路\n\n前面提到， dijkstra是不能处理带负权边的图的， 因为这会导致dijkstra算法最根本的贪心思想不再正确——当dist[i]最小时， dist[i]不一定是源点到i的最短路径， 因为dist[i]可能大于dist[j] + 某个负数。\n\n### Bellman-Ford算法\n\nBellman-Ford算法(以下简称BF算法)基于动态规划的思想， 与Dijkstra类似的是， BF算法同样维护最短路径长度数组dist。 不同的是， Dijkstra使用贪心思想， 选取目前dist最小的顶点， 并遍历其所有出边来更新dist数组；而BF算法则是直接在每次循环过程中遍历整个边集， 来达到更新dist数组的目的。\n\n即对于每一条边[src, dest, weight]， 都取出来并执行松弛操作：` dist[dest] = min(dist[dest], weight + dist[src])`\n\n假设顶点A到顶点B的最短路径中有k条边， 则k小于等于n-1； 显然可以发现的是， 每次遍历边集都至少更新A到B路径中的一条边为最短路径， 所以至多需要遍历n-1次。\n\n设边的数量为m， 则BF算法的时间复杂度为$O(nm)$。\n\n因为BF算法只需要遍历边集， 所以存储图的时候可以只建立一个边集数组。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\nint dist[N], n, m;\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i < n; i ++) {\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], dist[a] + w);\n        }\n    }\n}\n```\n\n### SPFA(队列优化Bellman-Ford)\n\nBF算法的时间复杂度为$O(nm)$， 在一般的图中m都是远大于n, 如此看来BF虽然能处理负权边， 但效率却远低于dijkstra。\n\nBF的效率低在了哪里？显然是每次都遍历整个边集数组， 但其实其中真正的更新了dist的边却不多。\n\nSPFA正是对BF算法这个痛点进行了优化。 \"SPFA\"， 即**Shortest Path Faster Algorithm**， 从名字上也能看出大家对其效率上的认可。\n\nSPFA基于这样一个事实： 对于边[src, dest, weight]， 只有当dist[src]发生改变后， 该边才可能用于更新dist[dest]， 这就是说**只有dist发生改变的顶点的出边才有被遍历的价值。**这一点与Dijkstra算法不谋而合， 所以SPFA与Dijkstra算法在形式上是类似的。\n\n对于SPFA是实现细节， 特别要提的一点是st数组， 在这里st[i]用于标记顶点i是否在队列中， 以免顶点重复入队， 这显然是没用意义的。\n\nSPFA的复杂度并不稳定， 对于一般数据， 它要比朴素BF快得多， 甚至能以同样的时间处理正权图；但对于针对型数据， 复杂度最坏能退化到和BF一样的$O(nm)$。\n\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid spfa (int src) {\n    queue<int> q;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0, q.push(1);\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i];\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n}\n```\n\n### BF和SPFA的其它应用\n#### BF求解有边数限制的最短路径\n\n在BF算法那里我们提到， 假设1~n的最短路径中有k条边， 那么每次遍历边集都至少可以更新它的一条边。为什么是“至少”呢？这是因为在遍历边集的途中边的更新可能发生串联， 如`A->B->C`， 如果先遍历了`A->B`再遍历`B->C`， 则一次遍历就更新了两条边， 反之只能更新`A->B`这一条边。\n\n我们可以使用一些手段， 使得每次遍历边集都只能更新一条边， 那么若只循环k次， 则边数大于k的最短路径将不能被发现。\n\n这个手段就是， 在每次遍历边集前， 将dist数组拷贝一份为backup， 使用上一次的dist数组来更新当前的dist数组， 这就可以避免串联。\n\n```cpp\nstruct edge {\n    int a, b, w;\n} edges[N];\n\nint dist[N], n, m, k, backup[N];\n\nvoid bllman_ford (int src) {\n    memset(dist, 0x3f, sizeof dist);\n    dist[src] = 0;\n    for (int i = 1; i <= k; i ++) {\n        memcpy(backup, dist, sizeof dist);\n        for (int j = 1; j <= m; j ++) {\n            auto [a, b, w] = edges[j];\n            dist[b] = min(dist[b], backup[a] + w);\n        }\n    }\n}\n```\n\n#### SPFA判断负环\n普通的SPFA是不能处理带负环的图的， 否则会陷入死循环； 但是我们可以通过记录额外信息来判断图中是否出现负环。\n\n记录cnt[i]为当前i顶点到源点最短路径中的边数， 若cnt[i] >= n， 则显然存在负环。\n\n要注意的点是， 由于图可能并不连通， 因此初始时要把所有顶点入队； 在这里并不是为了求最短路， 所以dist可以不初始化， 只需要保证初始全部相同即可。\n```cpp\nint h[N], e[M], ne[M], w[M], idx;\nint st[N], dist[N], cnt[N], n, m;\n\nvoid add(int a, int b, int c)  // 添加一条边a->b，边权为c\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nbool spfa () {\n    queue<int> q;\n    for (int i = 1; i <= n; i ++) {\n        q.push(i), st[i] = true;\n    }\n    \n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        st[u] = false;\n        for (int i = h[u], j = e[i]; i != -1; i = ne[i], j = e[i]) {\n            if (dist[j] > dist[u] + w[i]) {\n                dist[j] = dist[u] + w[i], cnt[j] = 1 + cnt[u];\n                if (cnt[j] == n) {\n                    return true;\n                }\n                if (!st[j]) {\n                    q.push(j), st[j] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n```\n\n# 多源最短路\n\n多源最短路， 也叫做全局最短路， 即求出图中任意两个点的最短路径。\n\n## Floyd-Warshell算法\n\n> **Floyd-Warshall算法**（英语：Floyd-Warshall algorithm），中文亦称**弗洛伊德算法**或**佛洛依德算法**[[1\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-1)，是解决任意两点间的[最短路径](https://zh.wikipedia.org/wiki/最短路径)的一种[算法](https://zh.wikipedia.org/wiki/算法)[[2\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-2)，可以正确处理[有向图](https://zh.wikipedia.org/wiki/有向图)或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包[[3\\]](https://zh.wikipedia.org/wiki/Floyd-Warshall算法#cite_note-3)。\n\nF-W算法基于动态规划， 它依赖于这样一个事实： 若i到j的最短路径为dist\\[i][j]， 则对于任意顶点k， dist\\[i][k] + dist\\[k][j] >= dist\\[i][j]。 反之dist\\[i][j]就不为最短路径， 应更新为dist\\[i][k] + dist\\[k][j]。\n\n动态规划的思想如下：\n\n* 使用三维数组f\\[k]\\[i][j]表示**路径中(除源点和汇点)只出现过前k个顶点时**， i顶点到j顶点的最短路径\n\n* 当考虑f\\[k]\\[i][j]时， 可分为两种情况： i->j最短路径不经过k顶点， 即f\\[k-1]\\[i][j]; 经过k顶点， 即f\\[k - 1]\\[i][k] + f\\[k - 1]\\[k][j]。所以状态转移方程为：\n  $$\n  f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k] + f[k - 1][k][j])\n  $$\n\n可以发现， f[k]只与f[k-1]相关， 所以只需要用二维数组存储每次迭代完的状态, 然后在上一次迭代的基础上进行状态转移。\n\n对应到图的存储， 只需要用邻接矩阵存储图， 然后在矩阵中进行递推即可。\n\n```cpp\nint g[N][N], n;\n\nvoid floyd () {\n    for (int k = 1; k <= n; k++)\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j ++)\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n}\n```\n\n","tags":["最短路"],"categories":["图论"]},{"title":"排序算法","url":"/posts/61237/","content":"\n没什么写， 突发奇想总结一下以前写过的排序算法， 权当复习。\n\n> 以下皆以升序举例， a为默认数组名， n默认为数组长度\n\n\n## 冒泡排序\n大多数人学的第一个排序算法就算冒泡排序， 思想是每次比较相邻的两个数， 如果与升序不符合就进行交换； 从前到后一轮交换下来， 不难发现最大值会被交换到最后位， 因此下次只需要对前n-1个元素进行遍历即可。\n\n每轮交换至少确定一个数的位置， 所以最多需要进行n - 1轮, 时间复杂度为$O(n ^ 2)$\n\n<!--more-->\n\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j < n - i - 1; j ++) {\n            if (a[j] > a[j + 1]) {\n                swap(a[j], a[j + 1]);\n            }\n        }\n    }\n}\n```\n\n## 选择排序\n\n思想是每次都从剩余序列中选出一个最小值放到前面， 经过n-1次选择后数组即有序。\n\n可以发现选择排序的过程其实和冒泡排序差不多， 但选择排序第`i`次选择只需要交换一次， 比较`n - i + 1`次， 而冒泡排序在比较次数相同的情况下， 还会有更多次交换。 因此选择排序的常数要比冒泡排序小。\n\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 0; i < n - 1; i ++) {\n        int m = i;\n        for (int j = i + 1; j < n; j ++) {\n            if (a[j] < a[m]) {\n                m = j;\n            }\n        }\n        swap(a[i], a[m]);\n    }\n}\n```\n\n## 插入排序\n\n插入排序是$O(n^2)$排序中表现最好的排序， 思想正如其名， 先将前`i`个元素排序， 在把第`i + 1`个元素插入前面已经有序的序列中。\n\n插入排序的优势在于， 比较次数并不是死板的， 而是取决于元素应插入的位置。 特别的， 如果对有序序列进行插入排序， 那么每次插入只需要比较一次， 时间复杂度为$O(n)$。而对基本有序的序列， 插入排序效率也会更高。\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = 1; i < n; i ++) {\n        int x = a[i], j = i - 1;\n        for (; j >= 0; j --) {\n            if (a[j] > x) {\n                a[j + 1] = a[j];\n            } else {\n                break;\n            }\n        }\n        a[j + 1] = x;\n    }\n}\n```\n\n\n\n## 希尔排序\n\n希尔排序基于对插入排序的优化， 是第一个出现的时间复杂度低于$O(n^2)$的排序。\n\n前面提到， 当序列有序程度增大时， 插入排序的效率也会随之升高。希尔排序会先对数组的子数组进行插入排序， 直到数组有序程度较高， 再对整个数组进行插入排序。\n\n在子数组的选择策略上， 我们选择从第一个元素开始的、下标间隔相同的所有元素， 如`[3, 8, 3, 2, 4]`， 若间隔为2， 子数组应该是`[3, 3, 4]`。\n\n在实现上， 我们选择多组不同的间隔， 这里也叫做增量， 按增量从大到小的顺序依次对相应的子数组进行插入排序。 这里引入一个新的名词：***增量序列***， 增量序列是一个递增、初始项为1的正整数序列， 即为我们选择的间隔序列， 如`[1, 2, 4, 8]`， 如果我们要对长度为7的子数组使用该增量序列进行希尔排序， 则我们应该依次对增量为4, 2, 1的子数组进行插入排序， 显然增量为1的子数组即为原数组， 所以按增量序列依次进行插入排序最后肯定是能达到排序的效果的。\n\n显然希尔排序的效率会受到增量序列的影响， 希尔排序的时间复杂度证明非常复杂， 受限于水平不在此说明。\n\n比较常见的增量序列有发明者希尔推荐的**希尔序列**：`[1, ..., len / 4, len / 2]`, 以及效率更高的**Sedgewick序列**\n\n```cpp\nint Sedgewick[]={28,\n    1,5,19,41,109,209,505,929,\n    2161,3905,8929,16001,36289,64769,146305,260609,\n    587521,1045505,2354689,4188161,9427969,16764929,37730305,67084289,\n    150958081,268386305,603906049,1073643521};\n```\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int n) {\n    for (int i = n >> 1; i;  i >>= 1) {//使用Shell序列\n        for (int j = i; j < n; j ++) {\n            int x = a[j];\n            for (int k = j - i; k >= 0 && a[k] > x; k -= i) {\n                a[k + i] = a[k];\n            }\n            a[k + i] = x;\n        }\n    } \n}\n```\n\n## 归并排序\n\n归并排序是非常经典的分治算法， 思想是非常简单的：\n\n* 将数组分为左右两半\n* 对左半边数组和右半边数组进行归并排序\n* 将两段有序数组合并成一个有序数组\n\n显然很适合用递归来实现， 而用递归最重要的就算确定递归的边界， 这里的边界就是数组的长度小于1， 此时数组已然是有序的。\n\n在合并数组时， 若要达到线性的合并时间， 就要用到一个辅助数组， 将两边数组按大小依次填入辅助数组， 最后将辅助数组的数据写回原数组;显然辅助数组的长度最大要为n, 因此空间复杂度为$O(n)$。\n\n在时间复杂度上， 考虑递归的层数。 因为每次递归会将数组分成两半， 所以层数最大为$O(log n)$， 由于合并的时间复杂度为线性， 所以时间复杂度应为$O(nlog n)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r, int t[]) {\n    if (l >= r) {\n        return;\n    }\n    int m = (l + r) >> 1;\n    Sort(a, l, m, t), Sort(a, m + 1, r, t);\n    //合并\n    int i = l, j = m + 1, k = l;\n    while (i <= m && j <= r ) {\n        if (a[i] < a[j]) {\n            t[k ++] = a[i ++];\n        } else {\n            t[k ++] = a[j ++];\n        }\n    }\n    while (i <= m) {\n        t[k ++] = a[i ++];\n    }\n    while (j <= r) {\n        t[k ++] = a[j ++];\n    }\n    for (i = l; i <= r; i ++) {\n        a[i] = t[i];\n    }\n}\n```\n\n## 快速排序\n\n快速排序也是一个分治算法， 思想如下：\n\n* 从当前数组选出任意一个数作为枢纽p\n* 把数组中所有比p小的数放到p左边， 大的数放到右边(相等随意)， 这个过程叫做划分。\n* 对p左边的元素和右边的元素进行快速排序。\n\n第一次看到时肯定是很迷茫的， 经过上面的递归过程数组怎么就有序了呢？\n\n可以用类似数学归纳法的方法证明：\n\n* 首先来看递归边界： 当数组的长度小于等于1时， 数组本身是有序的。\n\n* 设数组经过划分后， 分出左右两个子数组为L/R， **假设L, R经过快速排序， 可以变成有序**\n* 此时有`L < p < R`， 显然当前数组也为有序\n\n以上就是快速排序的思想， 但要想让快速排序‘快速’， 我们就要考虑划分操作的实现。\n\n最容易想到的是， 使用两个辅助数组， 来记录两边的信息；这当然是可以的， 但空间复杂度将于归并排序相同为$O(n)$\n\n但先人发明了一个非常巧妙的双指针算法， 能以$O(n)$时间复杂度、$O(1)$空间复杂度完成划分操作。\n\n基本思想是： 使用两个指针i, j， 从数组两边想中间遍历， i会停止在大于p的元素上， j会停止在小于p的元素上；当i， j都停止时， 将i、j指向元素进行一次交换。 遍历结束于i，j相遇。\n\n关于时间复杂度， 我们同样关注递归的深度。 但快排于归并排序不同的是， 每次划分后两边的元素数量不一定相等， 因此快排的时间复杂度会取决于数据， 具有随机性。\n\n对于快排的最好情况：每次划分都能划分为两个元素数量差不多的两边， 此时时间复杂度为$O(nlog n)$； 对于快排的最坏情况， 每次划分都把全部元素划分到一边， 而另一边为空， 此时递归深度为n, 时间复杂度为$O(n^2)$\n\n### 代码实现\n\n```cpp\nvoid Sort(int a[], int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int p = a[(l + r) >> 1], i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while(a[i] < p);\n        do j--; while(a[j] > p);\n        if (i < j) swap(a[i], a[j]);\n    }\n    Sort(a, l, j), Sort(a, j + 1, r);\n}\n```\n\n## 堆排序\n\n堆这个数据结构的原理就不多赘述了， 主要如何以数组自建堆、以$O(1)$的空间复杂度实现堆排序。\n\n首先我们将待排序的数组看作一个完全二叉树， 然后**自底向上**的将二叉树调整为堆。\n\n过程如下：\n\n* 首先将i的两个子树调整为堆\n* 此时将i下滤， i所在的二叉树即变成了堆。\n* 递归的终止条件为， 当结点i没有子树时， 即可以返回。\n\n而由于完全二叉树数组存储的特殊性， 我们只需要从后往前的遍历数组， 即可保证每个结点被遍历前其子树已被遍历。\n\n经过n次遍历， 数组已经变成了一个堆。 接下来是堆排序的第二个关键点：从堆中取n次堆顶元素得到排序序列。\n\n我们可以发现每次弹出堆顶元素， 堆的大小减一， 即所需的数组大小减一。\n\n参考堆实现中的删除顶点元素操作：将堆顶与最后一个元素交换， 此时堆顶的两个子树都是堆， 只需要将堆顶再次下滤， 即可完成对堆的调整；而原来的堆顶元素显然就可以保存在原堆的最后一个元素那里。\n\n**时间复杂度**\n\n每次下滤操作的时间复杂度为$O(\\log n)$， 在调整原原数组及从堆中删除堆顶元素过程中， 总共需要差不多`2n`次下滤， 因此时间复杂度为$O(n\\log n)$\n\n**空间复杂度**\n\n由于我们始终是在对数组进行操作， 并没有使用到其它的额外空间。 因此空间复杂度为$O(1)$.\n\n### 代码实现\n\n```c++\n#define Left(i) 2 * i + 1\nvoid down(int a[], int i, int n) {\n    int t = a[i];\n    for (int son = Left(i); son <= n; son = Left(i)) {\n        if (son != n && a[son + 1] > a[son]) son ++;\n        if (t > a[son]) break;\n        else a[i] = a[son], i = son;\n    }\n    a[i] = t;\n}\n\nvoid Sort(int a[], int n) {\n    for (int i = n - 1; i >= 0; i --) down(a, i, n-1);\n    for (int i = n-1; i > 0; i --) swap(a[0], a[i]), down(a, 0, i-1);\n}\n```\n\n\n\n","tags":["排序"],"categories":["算法"]},{"title":"线段树","url":"/posts/48555/","content":"\n## 线段树简介\n线段树常用来解决多次区间修改以及区间性质查询的问题， 且区间的性质一般可以由子区间推出， 如最大值、区间和。\n\n## 线段树的结构\n线段树顾名思义显然是一棵树， 且一般实现为二叉树。\n线段树满足：\n\n- 树上每一个结点都代表着一段区间\n\n- 每个结点的两个子结点分别代表该区间的左右子区间。\n\n<!--more-->\n\n如区间[1, 5]用线段树表示为\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n显然， 线段树具有搜索树的性质。\n\n## 基本建树\n\n### 线段树的存储\n\n线段树常用存储完全二叉树的方式、数组形式存储， 即根结点下标为1， 对于结点i， 它的左儿子下标为`2 * i`， 右儿子下标为`2 * i + 1`。\n\n下面以图的形式展示各结点下标关系\n\n```mermaid\ngraph TD;\n\tA((\"1<br>[1, 5]\")) --> B((\"2<br>[1, 3]\"))\n\tA --> C((\"3<br>[4, 5]\"))\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n至于数组的大小， 一般开到区间长度的四倍， 因为结点个数最多不会操过区间长度的四倍， 可自行证明。\n\n\n### 代码实现\n\n假设区间性质为区间和\n\n```c++\nconst int N = xxx;\nint a[N];//原数组\nint f[N << 2];//存储线段树结点的某性质\n\nvoid bulid (int k, int l, int r) {\n    if (l == r) {\n        f[k] = a[i];\n        return;\n    }\n\t int m = l + r >> 1;\n\t build(2 * k, l, m), bulid(2 * k + 1, m + 1, r);\n    f[k] = f[2 * k] + f[2 * k + 1];//由子区间推出当前区间\n}\n```\n\n## 线段树的单点修改及查询\n\n### 例题 - [洛谷P3374](https://www.luogu.com.cn/problem/P3374)\n\n>#### 题目描述\n>\n>如题，已知一个数列，你需要进行下面两种操作：\n>\n>- 将某一个数加上 x*\n>- 求出某区间每一个数的和\n>\n>#### 输入格式\n>\n>第一行包含两个正整数 n*,*m*，分别表示该数列数字的个数和操作的总个数。\n>\n>第二行包含 *n* 个用空格分隔的整数，其中第 *i* 个数字表示数列第 i*i* 项的初始值。\n>\n>接下来 *m* 行每行包含 33 个整数，表示一个操作，具体如下：\n>\n>- `1 x k` 含义：将第 x*x* 个数加上 *k*\n>- `2 x y` 含义：输出区间 [x,y][*x*,*y*] 内每个数的和\n>\n>#### 输出格式\n>\n>输出包含若干行整数，即为所有操作 2 的结果。\n>\n>#### 输入输出样例\n>\n>**输入 #1**\n>\n>```\n>5 5\n>1 5 4 2 3\n>1 1 3\n>2 2 5\n>1 3 -1\n>1 4 2\n>2 1 4\n>```\n>\n>**输出 #1**\n>\n>```\n>14\n>16\n>```\n>\n>#### 说明/提示\n>\n>【数据范围】\n>\n>$1 \\leq n, m \\leq 10^5$\n\n### 单点修改\n\n在区间和线段树已经构建完成的情况下， 此时若要将某元素的值增大，则会有多个区间的和发生变化。\n\n因此可以对线段树进行一次搜索， 将所有包含被修改元素的区间的区间和增大。\n\n```c++\n//k, l, r表示当前区间的下标及边界， x、y为被修改的元素下标和增大的值\nvoid modify (int k, int l, int r, int s, int v) {\n    f[k] += v;\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    if (s <= m) {//x在左半边\n        modify(2 * k, l, m, s, v);\n    } else {//x在右半边\n        modify(2 * k + 1, m + 1, s, v);\n    }\n}\n```\n\n显然单点修改线段树的时间复杂度与树高有关， 为$O（log n)$\n\n\n### 区间查询\n\n由于区间和是可以由子区间推出的， 所以要求出[b, e]区间的区间和， 就要把[b, e]区间分解为若干个线段树上存在的区间。\n\n如\n\n```mermaid\ngraph TD;\n\tA((\"[1, 5]\")) --> B((\"[1, 3]\"))\n\tA --> C((\"[4, 5]\"))\n\tB --> D((\"[1, 2]\"))\n\tB --> E((\"[3, 3]\"))\n\tC --> F((\"[4, 4]\"))\n\tC --> G((\"[5, 5]\"))\n\tD --> H((\"[1, 1]\"))\n\tD --> I((\"[2, 2]\"))\n```\n\n若要查询[3, 5], 则应该分解为[3, 3] + [4, 5]\n\n```c++\nint query (int k, int l, int r, int b, int e) {\n    if (l == b && r == e) {\n        return f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {//[b, e]完全在左区间\n        return query(2 * k, l, m, b, e);\n    } else if (b > m) {//完全在右区间\n        return query(2 * k + 1, m + 1, b, e);\n    } else {//[b, e]在左右区间均有分布\n        return query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, b, e);\n    }\n}\n```\n\n查询时， 最坏情况下最遍历到最底层, 且支数是有限的， 时间复杂度为$O(log n)$\n\n\n### 完整代码\n\n```cpp\n//\n// Created by trudbot.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5;\nint a[N], f[N << 2];\nint n, m;\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m);\n\tbuild(2  *k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int s, int v) {\n\tf[k] += v;\n\tif(l == r) {\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tif(s <= m) {\n\t\tmodify(2 * k, l, m, s, v);\n\t} else {\n\t\tmodify(2 * k + 1, m + 1, r, s, v);\n\t}\n}\n\nint query(int k, int l, int r, int b, int e) {\n\tif(l == b && r == e) {\n\t\treturn f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(e <= m) {\n\t\treturn query(2 * k, l, m, b, e);\n\t} else if(b > m) {\n\t\treturn query(2 * k + 1, m + 1, r, b, e);\n\t} else {\n\t\treturn query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\t\n\twhile(m --) {\n\t\tint x, a, b; cin >> x >> a >> b;\n\t\tif(x == 1) {\n\t\t\tmodify(1, 1, n, a, b);\n\t\t} else {\n\t\t\tcout << query(1, 1, n, a, b) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n## 线段树的区间修改及查询\n\n### 例题\n\n> #### 【模板】线段树 1\n>\n> #### 题目描述\n>\n> 如题，已知一个数列，你需要进行下面两种操作：\n>\n> 1. 将某区间每一个数加上 $k$。\n> 2. 求出某区间每一个数的和。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n>\n> 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n>\n> 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n>\n> 1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。\n> 2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。\n>\n> #### 输出格式\n>\n> 输出包含若干行整数，即为所有操作 2 的结果。\n>\n> #### 样例 #1\n>\n> ##### 样例输入 #1\n>\n> ```\n> 5 5\n> 1 5 4 2 3\n> 2 2 4\n> 1 2 3 2\n> 2 3 4\n> 1 1 5 1\n> 2 1 4\n> ```\n>\n> ##### 样例输出 #1\n>\n> ```\n> 11\n> 8\n> 20\n> ```\n>\n> #### 提示\n>\n> 对于 $30\\%$ 的数据：$n \\le 8$，$m \\le 10$。  \n> 对于 $70\\%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。  \n> 对于 $100\\%$ 的数据：$1 \\le n, m \\le {10}^5$。\n>\n> 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n>\n> **【样例解释】**\n>\n> ![](https://cdn.luogu.com.cn/upload/pic/2251.png)\n\n\n### 区间修改与永久懒惰标记\n\n这次要求将区间所有元素都加上某个数， 直接遍历加上再重新建树肯定不行， 这样时间复杂度会来到$O(n)$；更加不能对区间每一个元素都进行单点修改， 否则时间复杂度为$O(n log n)$。\n\n这时我们需要用一个懒惰标记的手段， 对于修改的区间[b, e]， 我们把它分解为线段树上若干的区间， 对这些区间增加一个“标记”， 即标记增加了x。而对分解区间的父区间， 则是直接修改f值。\n\n如下图， 假设为在[3, 5]区间加上x， 且用v[N<<2]来记录某结点区间加的值。\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>f[1] += (5-3+1) * x\") --> B(\"2<br>[1, 3]<br>f[2] += (3-3+1)*x\")\n\tA --> C(\"3<br>[4, 5]<br>v[3] += x\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>v[5] += x\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n```c++\nvoid modify (int k, int l, int r, int b, int e, int x) {\n    if (b == l && e == r) {\n        v[k] += x;\n        return;\n    }\n    f[k] += (e - b + 1) * x;\n    int m = l + r >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, x);\n    } else if (b > m) {\n        modify(2 * k + 1, m+1, r, b, e, x);\n    } else {\n        modify(2 * k, l, m, b, m, x);\n        modify(2 * k + 1, m + 1, r, m + 1, e, x);\n    }\n}\n```\n\n\n\n### 区间查询\n\nv[i] += x表示在对i号结点区间[l, r]上的每个元素都加上了x， 所有包含[l, r]的大区间也都已经都记录了变化； 但如果我们要查询的是[l, r]的子区间呢？\n\n这时对懒惰标记的处理就至关重要了， 在向下遍历线段树的途中用一个变量来记录沿途的标记， 最后在加到被查询区间上。\n\n如\n\n```mermaid\ngraph TD;\n\tA(\"1<br>[1, 5]<br>v[1] = x\") --> B((\"2<br>[1, 3]<br>\"))\n\tA --> C(\"3<br>[4, 5]<br>v[3] = y\")\n\tB --> D((\"4<br>[1, 2]\"))\n\tB --> E((\"5<br>[3, 3]<br>\"))\n\tC --> F((\"6<br>[4, 4]\"))\n\tC --> G((\"7<br>[5, 5]\"))\n\tD --> H((\"8<br>[1, 1]\"))\n\tD --> I((\"9<br>[2, 2]\"))\n```\n\n此时v[1]和v[3]上均有标记， 若我们要查询[4, 4]的区间和， 在搜索改区间的过程上会记录路径上的所有标记的和， 所以结果应该为`f[6] + (x + y) * (4 - 4 + 1)`\n\n```c++\n\nll query(int k, int l, int r, int b, int e, int p) {\n    p += v[k];\n    if(l == b && r == e) {\n        return p * (r - l + 1) + f[k];\n    }\n    int m = l + r >> 1;\n    if (e <= m) {\n        return query(2 * k, l, m, b, e, p);\n    } else if (b > m) {\n        return query(2 * k + 1, m + 1, r, b, e, p);\n    } else {\n        return query(2 * k, l, m, b, m, p) + query(2 * k + 1, m + 1, r, m + 1, e, p);\n    }\n}\n```\n\n \n\n### 完整代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N<<2], v[N<<2];\n\nvoid build(int k, int l, int r) {\n\tif(l == r) {\n\t\tf[k] = a[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(2 * k, l, m), build(2 * k + 1, m + 1, r);\n\tf[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid modify(int k, int l, int r, int x, int y, int z) {\n\tif(l == x && r == y) {\n\t\tv[k] += z;\n\t\treturn;\n\t}\n\tf[k] += (y - x + 1) * z;\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\tmodify(k * 2, l, m, x, y, z);\n\t} else if(x > m) {\n\t\tmodify(k * 2 + 1, m + 1, r, x, y, z);\n\t} else {\n\t\tmodify(2 * k, l, m, x, m, z);\n\t\tmodify(2 * k + 1, m + 1, r, m + 1, y, z);\n\t}\n}\n\nll query(int k, int l, int r, int x, int y, ll p) {\n\tp += v[k];\n\tif(l == x && r == y) {\n\t\treturn p * (r - l + 1) + f[k];\n\t}\n\tint m = l + r >> 1;\n\tif(y <= m) {\n\t\treturn query(2 * k, l, m, x, y, p);\n\t} else if(x > m) {\n\t\treturn query(2 * k + 1, m + 1, r, x, y, p);\n\t} else {\n\t\treturn query(2 * k, l, m, x, m, p) \n\t\t\t+ query(2 * k + 1, m + 1, r, m + 1, y, p);\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> a[i];\n\t}\n\tbuild(1, 1, n);\n\twhile (m --) {\n\t\tint t; cin >> t;\n\t\tif(t == 1) {\n\t\t\tint x, y; ll z; cin >> x >> y >> z;\n\t\t\tmodify(1, 1, n, x, y, z);\n\t\t} else {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcout << query(1, 1, n, x, y, 0) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 标记下传与自下而上更新\n\n在上述标记永久化方法中， 对标记的处理方法是：\n\n* modify时的被标记区间的父区间不标记， 而是直接修改。\n* query时， 会累加遍历路径中的标记， 最后作用于查询区间。\n\n但使用标记永久化的很重要的一个条件是标记可以累加， 很多时候可以并不能满足。\n\n而标记下传是适用性更广的一种标记处理方法， 有两个核心方法：\n\n* pushdown， 把当前结点的标记下传\n* pushup， 由子结点更新当前结点。\n\n标记下传的基本规则是：\n\n* 为某结点添加标记时， 会修改结点的值。\n* 在遍历到线段树的某个结点时， 若还要往下遍历， 则把标记下传， 并在遍历完子树后更新当前结点。\n\n标记下传是一种延迟修改的思想， 在修改[l, r]时如果直接把它的每一个子区间都修改， 显然在时间复杂度上是灾难。 但标记下传只在需要查询/修改子区间时把上一次的修改作用于子区间， 修改的过程融合在了查询/其它修改 的过程中。\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nll a[N], f[N << 2], v[N << 2];\n\nvoid pushup(int k) {\n    f[k] = f[2 * k] + f[2 * k + 1];\n}\n\nvoid pushdown(int k, int l, int r) {\n    if (v[k]) {\n        int left = 2 * k, right = left + 1, m = (l + r) >> 1;\n        f[left] += v[k] * (m - l + 1), f[right] += v[k] * (r - m);\n        v[left] += v[k], v[right] += v[k], v[k] = 0;\n    }\n}\n\nvoid build(int k, int l, int r) {\n    if(l == r) {\n        f[k] = a[l];\n        return;\n    }\n    int m = (l + r) >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n    pushup(k);\n}\n\nvoid modify (int k, int l, int r, int b, int e, int s) {\n    if(l == b && e == r) {\n        f[k] += (r - l + 1) * s;\n        v[k] += s;\n        return;\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        modify(2 * k, l, m, b, e, s);\n    } else if (b > m) {\n        modify(2 * k + 1, m + 1, r, b, e, s);\n    } else {\n        modify(2 * k, l, m, b, m, s), modify(2 * k + 1, m + 1, r, m + 1, e, s);\n    }\n    pushup(k);\n}\n\nll query(int k, int l, int r, int b, int e) {\n    if (l == b && e == r) {\n        return f[k];\n    }\n    pushdown(k, l, r);\n    int m = (l + r) >> 1;\n    ll res;\n    if (e <= m) {\n        res = query(2 * k, l, m, b, e);\n    } else if (b > m ) {\n        res = query(2 * k + 1, m + 1, r, b, e);\n    } else {\n        res = query(2 * k, l, m, b, m) + query(2 * k + 1, m + 1, r, m + 1, e);\n    }\n    pushup(k);\n    return res;\n}\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int b, e, x; cin >> b >> e >> x;\n            modify(1, 1, n, b, e, x);\n        } else {\n            int b, e; cin >> b >> e;\n            cout << query(1, 1, n, b, e) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 线段树实战\n\n### 旅馆\n\n[261. 旅馆 - AcWing题库](https://www.acwing.com/problem/content/description/263/)\n\n> 一家旅馆共有 N 个房间，这 N 个房间是连成一排的，标号为 1∼N。\n>\n> 现在有很多旅客以组为单位前来入住，每组旅客的数量可以用 Di来表示。\n>\n> 旅店的业务分为两种，入住和退房：\n>\n> 1. 旅客入住时，第 i 组旅客需要根据他们的人数 D~i~，给他们安排 D~i~ 个连续的房间，并且房间号要尽可能的小。如果房间不够，则无法安排。\n> 2. 旅客退房时，第 i 组旅客的账单将包含两个参数 X~i~ 和 D~i~，你需要将房间号 X~i~到 X~i~+D~i~−1之间的房间全部清空。\n>\n> 现在你需要帮助该旅馆处理 M 单业务。\n>\n> 旅馆最初是空的。\n>\n> #### 输入数据\n>\n> 第一行输入两个用空格隔开的整数 N 和 M。\n>\n> 接下来 M 行将描述 M 单业务：\n>\n> “1 D~i~”表示这单业务为入住业务。\n>\n> “2 X~i~ D~i~”表示这单业务为退房业务。\n>\n> #### 输出数据\n>\n> 每个入住业务输出一个整数，表示要安排的房间序列中的第一个房间的号码。\n>\n> 如果没办法安排，则输出 0。\n>\n> 每个输出占一行。\n>\n> #### 数据范围\n>\n> 1≤D~i~≤N≤50000\n> 1≤M<50000\n>\n> #### 输入样例：\n>\n> ```\n> 10 6\n> 1 3\n> 1 3\n> 1 3\n> 1 3\n> 2 5 5\n> 1 6\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 1\n> 4\n> 7\n> 0\n> 5\n> ```\n\n#### 题意解析\n对于长度为N的01串（下标从1开始）， 需实现以下两种操作：\n* 查询串中最靠左的长度为d的全0串， 并返回左端点（若不存在返回0）； 随后把这个全0串变成全1串。\n* 把区间[x, x + d - 1]变成全0\n\n#### 思路\n设计线段树的结点保存区间的三种信息：\n- 区间中的最长0串长度\n- 区间中以左端点开始的最长0串长度\n- 区间中以右端点结束的最长0串长度\n\n这样设计的巧妙之处在于：\n- 由两个子区间的信息可以推出当前区间的信息\n- 通过三个信息可以递归查找出最左的长度为d的0串\n\n#### 代码\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50010;\n\nstruct node{\n    int l, r;\n    int m, lm, rm;\n    int s;\n} f[N << 2];\n\ninline void allSet (int k, int v) {\n    f[k].m = f[k].lm = f[k].rm = v;\n}\n\ninline void build (int k, int l, int r) {\n    f[k].l = l, f[k].r = r, f[k].s = 0;\n    allSet(k, r - l + 1);\n    if (l == r) {\n        return;\n    }\n    int m = l + r >> 1;\n    build(2 * k, l, m), build(2 * k + 1, m + 1, r);\n}\n\ninline void pushdown (int k) {\n    int left = 2 * k, right = left + 1;\n    if (f[k].s == 1) {\n        allSet(left, 0), allSet(right, 0);\n    } else if (f[k].s == -1) {\n        allSet(left, f[left].r - f[left].l + 1), \n        allSet(right, f[right].r - f[right].l + 1);\n    } else {\n        return;\n    }\n    f[left].s = f[right].s = f[k].s, f[k].s = 0;\n}\n\nvoid pushup (int k) {\n    int left = 2 * k, right  = left + 1;\n    f[k].m = max(f[left].m, max(f[right].m, f[left].rm + f[right].lm));\n    f[k].lm = f[left].lm;\n    if (f[left].lm == f[left].r - f[left].l + 1) {\n       f[k].lm += f[right].lm; \n    }\n    f[k].rm = f[right].rm;\n    if (f[right].rm == f[right].r - f[right].l + 1) {\n        f[k].rm += f[left].rm;\n    }\n}\n\nint query (int k, int len) {\n    if (f[k].m < len) {\n        return 0;\n    }\n    pushdown(k);\n    if (f[k].lm >= len) {\n        return f[k].l;\n    } else if (f[2 * k].m >= len) {\n        return query(2 * k, len);\n    } else if (f[2 * k].rm + f[2 * k + 1].lm >= len) {\n        return f[2 * k].r - f[2 * k].rm + 1;\n    } else {\n        return query(2 * k + 1, len);\n    }\n}\n\nvoid modify (int k, int l, int r, int s) {\n    if (f[k].l == l && f[k].r == r) {\n        if (s == 1) {\n            allSet(k, 0);\n        } else {\n            allSet(k, f[k].r - f[k].l + 1);\n        }\n        f[k].s = s;\n        return;\n    }\n    pushdown(k);\n    int m = f[k].l + f[k].r >> 1;\n    if (r <= m) {\n        modify(2 * k, l, r, s);\n    } else if (l > m) {\n        modify(2 * k + 1, l, r, s);\n    } else {\n        modify(2 * k, l, m, s), modify(2 * k + 1, m + 1, r, s);\n    }\n    pushup(k);\n}\n\n\n\nint main () {\n    int n, m; cin >> n >> m;\n    build(1, 1, n);\n    while (m --) {\n        int t; cin >> t;\n        if (t == 1) {\n            int d; cin >> d;\n            int b = query(1, d);\n            cout << b << endl; \n            if (b != 0) {\n                modify(1, b, b + d - 1, 1);\n            }\n        } else {\n            int x, d; cin >> x >> d;\n            modify(1, x, x + d -1, -1);\n        }\n    }\n    return 0;\n}\n```\n\n### 最长递增子序列\n\n> 给你一个整数数组 nums 和一个整数 k 。\n>\n> 找到 nums 中满足以下要求的最长子序列：\n>\n> 子序列 严格递增\n> 子序列中相邻元素的差值 不超过 k 。\n> 请你返回满足上述要求的 最长子序列 的长度。\n>\n> 子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。\n>\n> 示例 1：\n>\n> 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3\n> 输出：5\n> 解释：\n> 满足要求的最长子序列是 [1,3,4,5,8] 。\n> 子序列长度为 5 ，所以我们返回 5 。\n> 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。\n> 示例 2：\n>\n> 输入：nums = [7,4,5,1,8,12,4,7], k = 5\n> 输出：4\n> 解释：\n> 满足要求的最长子序列是 [4,5,8,12] 。\n> 子序列长度为 4 ，所以我们返回 4 。\n> 示例 3：\n>\n> 输入：nums = [1,5], k = 1\n> 输出：1\n> 解释：\n> 满足要求的最长子序列是 [1] 。\n> 子序列长度为 1 ，所以我们返回 1 。\n>\n>\n> 提示：\n>\n> 1 <= nums.length <= 10^5^\n> 1 <= nums[i], k <= 10^5^\n>\n> 来源：力扣（LeetCode）\n> 链接：https://leetcode.cn/problems/longest-increasing-subsequence-ii\n> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n#### 思路分析\n可以注意到数组的元素值是有范围的， 位于[1, 1e5]。\n\n定义a[j]为在数组nums中[0, i]以j结尾的满足题意的最长递增序列长度； 则当考虑nums[i + 1]是， 只需要把nums[i + 1]加到某个序列的末尾， 此序列的最后一个元素x应该满足：x < nums[i + 1] , x >= nums[i + 1] - k.\n\n可以得到x的范围为[nums[i + 1] - k, nums[i + 1] - 1]， 在此区间查找最长的子序列长度， 在更新a[nums[i + 1]]即可。\n\n查询某区间的最大值， 显然可以使用线段树。\n\n#### 代码参考\n时间复杂度：$O(n\\log_2x)$\n```c++\nconst int N = 1e5 + 10;\nint f[N << 2];\n\nvoid modify (int u, int l, int r, int x, int v) {\n    if (l == r) {\n        f[u] = max(f[u], v);\n        return;\n    }\n    int m = (l + r) >> 1;\n    if (x <= m) {\n        modify(2 * u, l, m, x, v);\n    } else {\n        modify(2 * u + 1, m + 1, r, x, v);\n    }\n    f[u] = max(f[2 * u], f[2 * u + 1]);\n}\n\nint query (int u, int l, int r , int b, int e) {\n    if (l == b && r == e) {\n        return f[u];\n    }\n    int m = (l + r) >> 1;\n    if (e <= m) {\n        return query(2 * u, l, m, b, e);\n    } else if (b > m) {\n        return query(2 * u + 1, m + 1, r, b, e);\n    } else {\n        return max(query(2 * u, l, m, b, m),\n            query(2 * u + 1, m + 1, r, m + 1, e));\n    }\n}\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums, int k) {\n        memset(f, 0, sizeof f);\n        int mx = 0;\n        for (auto i : nums) {\n            mx = max(i, mx);\n        }\n        for (auto i : nums) {\n            int t;\n            if (i == 1) {//特判1, 因为比1小的数不在线段树区间范围内\n                t = 0;\n            } else {\n                t = query(1, 1, mx, max(1, i - k), i - 1);\n            }\n            modify(1, 1, mx, i, t + 1);\n        }\n        return f[1];\n    }\n};\n```\n\n","tags":["线段树","递归"],"categories":["高级数据结构"]},{"title":"二分查找","url":"/posts/42877/","content":"前言： 二分查找虽然并不是什么很难的东西， 但因为我始终背不下来， 每次要用的时候都得现场小心翼翼地推导细节， 十分苦恼。因此希望通过写一篇笔记总结， 把它刻入我的记忆。\n\n## 基本概念\n不再赘述， 引用维基百科：\n> 在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm）[2]，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n<!--more-->\n\n## 二分查找的框架\n\n二分查找的步骤大概是：\n* 定义二分查找的左右边界\n* 循环体， 循环条件一般为左边界不大于右边界\n* 取中值（**准确说是左右边界的平均值， 即中间元素**）\n* 用中值与查找的目标元素比较， 从而移动左右边界\n\n## 二分查找的三种应用形式\n通过对取中值以及对左右边界移动的细节处理， 可以得到不同功能的二分查找。\n\n### 最朴素的二分查找\n最朴素的二分查找的用法是： 查找某值是否在数组中出现过， 是则返回下标， 否则返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] == target) {\n            return mid;\n        } else if(nums[mid] > target) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n### 查找左边界 / 第一个大于等于target的元素\n在朴素二分中， 若数组中有多个值为target的元素， 返回的下标对于使用者而言是合理情况中的随机一个；若数组中中没有值为target的元素， 返回值将是无意义的-1.\n\n接下来两种二分便是为了解决这一类问题。\n\n在左边界二分中， 要查找的元素`e`满足：e左边的元素都小于target, e右边的元素及e都不小于（大于等于）target.\n\n```cpp\nint binarySearch_lower(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n```\n### 查找右边界 / 第一个小于等于target的元素\n类似的， 在左边界二分中， 要查找的元素`e`满足：e右边的元素都大于target, e右边的元素及e都不大于（小于等于）target.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n```\n### 细节1——取中值时的左偏和右偏\n当`[l, r]`中有奇数个元素时如`[1, 2, 3]`， 中值显然为中间那个元素。\n但当`[l, r]`中有偶数个元素时如`[1, 2, 3, 4]`， 中值到底是2还是3呢？\n\n这就取决于mid的取法了\n```cpp\nmid = (l + r) >> 1;\nmid = (l + r + 1) >> 1; \n```\nc++的中整数除法是与右移一位的效果完全相同的， 即整除， 当[l, r]中有偶数个元素时, 显然`l + r`为奇数， 所以`(l + r) >> 1`结果会偏向l这一边\n而相反的`(l + r + 1) >> 1`会偏向r这一边。\n\n取中的偏向是相当重要的问题， 若使用错误， 二分可能将陷入死循环。\n\n在结论上， 可以简单的记忆为左边界左偏， 右边界右偏\n\n### 细节2——左右边界的更新方式\n边界二分与朴素二分很大的一个区别是： 朴素二分靠mid查找目标值， 若nums[mid] == target就立即返回； 而边界二分是靠不断缩小查找的区间， 最终区间长度为1时(`l == r`)， 区间中唯一的元素即为目标值。\n以左边界二分举例\n```cpp\nwhile(l < r) {\n        int mid = (l + r) >> 1;\n        if(nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n```\n要找的是左边界， 当nums[mid] > target时， 是不能将`r`置为`mid - 1`的， 因为也许`mid`就是左边界； 类似的， 当nums[mid] == target时， 你不能确定mid左边是否是左边界， 但mid + 1往后的元素你可以确定一定不是左边界， 因此将r赋为`mid`， 缩小范围， 继续查找。\n而只有当nums[mid] < target时， 才移动l， 此时mid显然不是左边界， 所以将l赋为`mid + 1`\n\n### 补充1——取中值时的溢出\n在区间较大情况下， 使用(l + r)直接取中值时可能会溢出整型范围。\n所以可以用如下方式等价取代\n```cpp\nmid = l + ((r - l) >> 1);\nmid = l + ((r - l + 1) >> 1);\n```\n\n### 补充2——查找失败\n若要找第一个不小于target的元素， 但数组中所有元素都小于target?\n此时`l`会不断向右移动， 直到移到到`r`的位置。\n所以查找结束后， 可以在对结果进行一次判断， 如果不满足就返回-1.\n```cpp\nint binarySearch(vector<int> &nums, int l, int r, int target) {\n    while(l < r) {\n        int mid = (l + r + 1) >> 1;\n        if(nums[mid]  <= target) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return nums[l] <= target ? l : -1;\n}\n```\n## 二分查找的应用\n\n二分查找最常见的应用就是在数组中查找某个值的左边界或右边界， 但还有一种的用法是浮点数二分， 必如求一个浮点数的n次方根。\n\n> 给定一个浮点数 nn，求它的三次方根。\n>\n> #### 输入格式\n>\n> 共一行，包含一个浮点数 nn。\n>\n> #### 输出格式\n>\n> 共一行，包含一个浮点数，表示问题的解。\n>\n> 注意，结果保留 66 位小数。\n>\n> #### 数据范围\n>\n> −10000≤n≤10000−10000≤n≤10000\n>\n> #### 输入样例：\n>\n> ```\n> 1000.00\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 10.000000\n> ```\n\n**思路**\n用二分的思想不断更新左右边界， 使左右边界逐渐逼近答案， 当左右边界足够接近答案时（达到精度要求）， 即认为左/右边界就是答案。\n**参考代码**\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    double n; cin >> n;\n    double l = -100, r = 100;\n    while((r - l) > 1e-8) {\n        double mid = (l + r) / 2;\n        if(mid * mid * mid > n) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n    printf(\"%.6lf\\n\", l);\n    return 0;\n}\n```\n\n## 参考\n\n[二分 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/binary/)\n\n[二分查找算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/二分搜尋演算法)\n\n[二分查找、二分边界查找算法的模板代码总结 - SegmentFault 思否](https://segmentfault.com/a/1190000016825704)\n\n","tags":["二分查找"],"categories":["算法"]},{"title":"字符串哈希","url":"/posts/52567/","content":"\n# 理论基础\n\n字符串哈希， 即把一个字符串映射为一个整数， 这个整数称之为`hash code`。在理想状态下， 只有两个字符串完全相等， hash code才会相等。 因此可以用两个字符串的`hash code`来判断字符串是否相等。\n\n将字符串转化为整数的函数也叫做哈希函数。\n\n# 字符串前缀哈希\n\n字符串前缀哈希是前缀思想在哈希中的应用， 一般用来解决**多次查询子串哈希**的问题。\n\n> 单次计算一个字符串的哈希值复杂度是 `O(n)`，其中n为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。\n\n<!--more-->\n\n因此可以使用特别的哈希函数， 使用字符串前缀的哈希值而推出任一连续子串的哈希值。\n\n## 哈希函数及公式\n\n设字符串S， S中元素下标从1开始， S下标为i的元素为S[i].\n\n哈希函数：\n$$\nhashCode = \\sum_{i = 1}^nS[i] * p^{n - i}\n$$\n如字符串`\"abc\"`， 表达式为\n$$\na * p ^ 2  + b * p + c\n$$\n利用此公式， 我们可以求出S的所有前缀的哈希值\n\n但显然不可能对所有前缀都应用上述公式。事实上pref[i] 可以由pref[i-1]递推得到\n\n仍然以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n可以发现\n\n```F#\npref[i] = pref[i-1] * p + S[i]\n```\n\n## 区间哈希\n\n我们得到了一个字符串所有长度前缀的哈希值， 那么如何利用它来得到某个区间[l, r]的哈希值呢？\n\n以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n假设我们要求[2, 3]区间， 即`\"bc\"`的哈希， 按上述哈希函数应该是`b*p + c`\n\n类比前缀和`sum[l, r] = pref[r] - pref[l-1]`, 可以发现\n$$\nb * p + c = pref[3] - pref[1] * p ^ 2\n$$\n事实上， 存在以下通式\n$$\nhashCode[l, r] = pref[r] - pref[l - 1] * p^{r - l + 1}\n$$\n证明并不难， 若有兴趣自行研究， 就不在此赘述了。\n\n其中`r - l + 1`很明显的， 可以记忆为区间的长度。\n\n因此通过预处理字符串所有前缀的哈希， 我们可以以O(1)的时间代价求出任一子串的哈希值。\n\n## 代码实现(C++)\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N]; // hh[i] 表示长度为i的前缀子串的哈希\null p[N];// p[i]表示P的i次幂, 避免使用幂函数多次求幂\n\n// 初始化前缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n```\n\n**小科普： unsigned long long**\n\n\n\null(unsigned long long)表示64位无符号正整数， 之所以使用ull是因为ull溢出后， 不会像有符号整数如int那样变成负数， 而是会从0重新开始， 即等同于对$2 ^ {64}$自动取余。\n\n在上述哈希函数中， P选取为131(此质数在先人的实验中表现最好， 不容易发生冲突)， 而hashCode更是以幂级增长的， 因此很容易就溢出， 需要对其进行取模。\n\n# 算法应用\n\n## 判断子串是否相等\n\n要判断两个子串是否相等， 只需比较哈希值是否相等即可。预处理前缀哈希， 即可以O(1)的时间代价得到子串的哈希。\n\n### 例题\n\n**AcWing 841**\n\n> 给定一个长度为 *n* 的字符串，再给定 *m* 个询问，每个询问包含四个整数 `l1, r1, l2, r2`，请你判断 \\[l1,r1] 和 \\[l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n>\n> 字符串中只包含大小写英文字母和数字。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n 和 m，表示字符串长度和询问次数。\n>\n> 第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。\n>\n> 接下来 m 行，每行包含四个整数 `l1, r1, l2, r2`，表示一次询问所涉及的两个区间。\n>\n> 注意，字符串的位置从 1 开始编号。\n>\n> #### 输出格式\n>\n> 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。\n>\n> 每个结果占一行。\n>\n> #### 数据范围\n>\n> 1≤n,m≤$10^5$\n>\n> #### 输入样例：\n>\n> ```\n> 8 3\n> aabbaabb\n> 1 3 5 7\n> 1 3 6 8\n> 1 2 1 2\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> Yes\n> No\n> Yes\n> ```\n\n套上上面的板子即可\n\n**时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\n\nconst int N = 1e5 + 10;\nconst ull P = 131;\null hh[N], p[N];\nstring s;\nint n;\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> s;\n    s.insert(0, \"0\");\n    InitHash();\n    while(m --) {\n        int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;\n        cout << (get(l1, r1) == get(l2, r2) ? \"Yes\" : \"No\") << endl;\n    }\n}\n```\n\n\n\n## 判断子串是否是回文\n\n回文即源串与反转后的字符串是相同的。\n\n用字符串哈希的角度来解决就是判断一个字符串及其逆转后的字符串哈希值是否相等。\n\n因此我们可以预处理主串的正向哈希以及逆向哈希， 再判断某子串的正向哈希和逆向哈希是否相等来判断是否是回文。\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N], r_hh[N];//前缀、后缀哈希\null p[N];\n\n// 初始化前缀/后缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n```\n\n### 例题 **google kickstart Round E P3**\n\n> 给定一个长度为 N 的回文字符串 P，它仅由小写英文字母构成。\n>\n> 请你找到最短的**非空回文**字符串 Q，使得 P 与 Q 拼接而成的字符串 Q 也是一个回文串。\n>\n> #### 输入格式\n>\n> \n>\n> 第一行包含整数 T，表示共有 T 组测试数据。\n>\n> 每组数据第一行包含一个整数 N。\n>\n> 第二行包含一个长度为 N 的回文字符串 PP。\n>\n> #### 输出格式\n>\n> \n>\n> 每组数据输出一个结果，每个结果占一行。\n>\n> 结果表示为 `Case #x: y`，其中 xx 为组别编号（从 11 开始），y 为满足条件的最短**非空回文**字符串 Q。\n>\n> #### 数据范围\n>\n> \n>\n> 1≤T≤100\n> 1≤N≤10^5^，\n> 保证 P 是一个由小写字母构成的回文字符串。\n>\n> \n>\n> #### 输入样例：\n>\n> ```F#\n> 3\n> 4\n> abba\n> 4\n> cccc\n> 6\n> cdccdc\n> ```\n>\n> #### 输出样例：\n>\n> ```F#\n> Case #1: abba\n> Case #2: c\n> Case #3: cdc\n> ```\n>\n> #### 样例解释\n>\n> \n>\n> 在 Case 1 中，满足条件的最短回文串 Q 为 `abba`，此时串联字符串 Q 为 `abbaabba`，这是一个回文串。\n>\n> 在 Case 2 中，满足条件的最短回文串 Q 为 `c`，此时串联字符串 PQ为 `ccccc`，这是一个回文串。\n>\n> 在 Case 3 中，满足条件的最短回文串 Q 为 `cdc`，此时串联字符串 PQ 为 `cdccdccdc`，这是一个回文串。\n\n**题意分析**\n\n给定回文字符串P, 求一回文字符串Q， 使在P末尾拼接Q后， PQ仍为回文字符串。\n\n不难分析得到， 由于PQ是回文字符串， 则P中长度等于Q的前缀应该与Q成倒序关系， 设这个前缀为P1, P中除去P1的后半部分为P2。又因为Q为回文字符串， 所以P1会等于Q， P1为回文字符串。而P2显然也要是回文字符串， 这样才能满足PQ为回文字符串。\n\n**因此， 将问题剥析出来就是：求最小的整数mid（1~n）, 使得P[1, mid]和P[mid+1, n]均为回文字符串。**\n\n**参考代码， 时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long \nstring s;\nint n; \nconst ull P = 131;\nconst int N = 1e5 + 10;\null hh[N], r_hh[N];\null p[N];\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n//获取正哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\n//获取反哈希\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\n//判断回文\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n\nint main() {\n    int T; cin >> T;\n    for(int t=1; t<=T; t++) {\n        cout << \"Case #\" << t << \": \"; \n        cin >> n >> s;\n        s.insert(0, \"0\");//调整下标\n        InitHash();\n        for(int i=1; i<=n; i++) {//枚举mid\n            if(is_palindrome(1, i) && is_palindrome(i+1, n)) {\n                cout << s.substr(1, i) << endl;\n                break;\n            }\n        }\n    }\n}\n```\n\n# 模板类\n\n将相关代码封装为类， 需要时cv即可。\n\n使用时注意：\n\n* 直接传入原字符串\n* 获取子串哈希时， 下标从0开始。\n\n```c++\nclass HashString {\nprivate:\n    typedef unsigned long long ull;\n    const int P = 131;\n    vector<ull> p;\n    vector<ull> prefix;\n    int n;\npublic:\n    HashString(string s) {\n        n = s.size();\n        s.insert(0, \"0\");\n        p.resize(n + 1), p[0] = 1;\n        prefix.resize(n + 1, 0);\n        for(int i=1; i<=n; i++) {\n            p[i] = p[i-1] * P;\n            prefix[i] = prefix[i - 1] * P + s[i];\n        }\n    }\n\n    ull get(int l, int r) {\n        l++, r++;\n        return prefix[r] - prefix[l - 1] * p[r - l + 1];\n    }\n};\n```\n\n\n\n# 参考\n\n[字符串哈希 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/hash/)\n\n[【算法学习笔记】7：字符串前缀哈希法_LauZyHou的博客-CSDN博客](https://blog.csdn.net/SHU15121856/article/details/109553503)\n\n[AcWing 841. 字符串哈希 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/2691/)","tags":["递推","哈希","模板"],"categories":["算法"]},{"title":"一文搞定c++自定义排序","url":"/posts/45215/","content":"\n# 前言\n\nc++拥有强大的STL， 在对复杂的数据结构排序时只需要自定义去比较函数， 然后放到容器内调用api即可。\n\n本该是很简单的东西， 但我之前一直无法记住升序以及降序两种方向该分别怎么写，总是会搞混，  每次都得现场Google。终于下定决心要在今天把它彻底搞定。\n\n# 自定义排序的三种比较器形式\n\n\n\n## 比较函数\n\nSTL中的`sort`函数已经为我们提供了排序算法的框架，我们唯一要做的决定就是对于两个元素`a`和`b`， 谁在前、谁在后？\n\n<!--more-->\n\n\n\n> sort函数的一个原型\n\n```c++\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last);//无比较器， 升序排序， 会调用<进行元素比较, 小的会放前面\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);//传入比较器， 前后顺序由比较强返回值决定\n```\n\n在`sort`函数中这即为第三个参数：比较器\n\n**比较函数的基本形式**:\n\n```\nbool comp(const type& a, const type& b);\n```\n\n一般而言形参的形式为`const`、引用类型（当然不写也可以， 只是这样更安全、效率更高）。\n\n而返回值于a、b的前后关系是**返回true时， a在前面; 返回false时, b在前面.**\n\n如\n\n```c++\nbool comp(const int &a, const int &b) {\n    return a < b;\n}\n```\n\n返回值为`true`时， a在前面， 且`a<b`， 所以会是升序排序。\n\n所以更透彻的讲， 比较函数的内容其实是**a要想排在b前面所要满足的条件**\n\n**简单小例子**\n\n若用pair<string, int> 存储着若干个学生的`name`和`score`信息， 要对这些学生进行排序， \n\n要求：\n\n* 按分数从高到低\n* 分数相等时按名字字典序排列\n\n很容易的可以得到比较函数为\n\n```c++\nbool cmp(const pair<string, int> &a, const pair<string, int> &b) {\n\tif(a.second != b.second) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n```\n\n**lambda表达式**\n\n比较函数在大多场景下可能仅需使用一次， 因此我们可以用lambda表示式来简写\n\n如\n\n```c++\nsort(data.begin(), data.end(), [](const type& a, const type& b) -> bool {\n        //judge something\n    });\n```\n\n\n\n## 重载<运算符\n\n有时候我们会用结构体或类来定义较为复杂的数据结构， 要对它进行自定义排序除了使用比较函数外， 还可以用重载运算符的方式。\n\n以上面的学生例子举例\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu& b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n```\n\n上述代码重载了stu类的`<`运算符，和比较函数不同的时只有一个参数， 但其实只不过是a参数变成了当前的结构体 。\n\n由于`sort`函数默认为升序, 会把用`<`比较的两个函数中小的放前面， 所以函数体编写思想和比较函数完全一致：写入要把a放到前面满足的条件。\n\n\n\n## 函数对象比较器——重载()\n\n其实就是定义一个结构体或类作为比较器， 重载`()`, 这样类名+`()`就成为了比较函数。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n};\n\nstruct cmp {\n    bool operator() (const stu& a, const stu& b) {\n        if(a.score != b.score) {\n            return a.score > b.score;\n        }\n        return a.name < b.name;\n    }\n};\n\nint main() {\n    vector<stu> a{{\"abc\", 100}, {\"acb\", 100}};\n    sort(a.begin(), a.end(), cmp());\n    for(const auto& i : a) {\n        cout << i.name << \" \" << i.score << endl;\n    }\n}\n```\n\n# 容器应用\n\nSTL用两种比较对象来指代排序的两种方向， 分别是`less`和`greater`分别使用`<`和`>`， 对应升序和降序。在众容器中都默认使用less， 所以结构体要使用默认排序需要重载小于运算符。\n\n也可以显示指出方向， 如以下代码对数组进行了降序排序。\n\n```c++\nint main() {\n    vector<int> a{3, 8, 3, 2, 4};\n    sort(a.begin(), a.end(), greater<>());//重载了< / >运算符， 即可使用less<> / greater<>\n}\n```\n\n要注意的是在set， priority_queue这样的容器不能用比较函数的方式， 只能够使用重载的方式实现。\n\n---\n\n以及比较反人类的是当`priority_queue`使用`less`时其实是大根堆， 使用`greater<>`才是小根堆。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu & b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n\nint main() {\n    priority_queue<stu, vector<stu>> heap;\n    heap.push({\"a\", 100});\n    heap.push({\"b\", 100});\n    heap.push({\"c\", 110});\n    while(!heap.empty()) {\n        cout << heap.top().name << \" \" << heap.top().score << endl;\n        heap.pop();\n    }\n}\n\n//输出结果\n/*\nb 100\na 100\nc 110\n\n*/\n```\n","tags":["c++","stl"],"categories":["一文搞定系列"]},{"title":"有点学问在的缩进风格","url":"/posts/57442/","content":"\n### 什么是缩进风格\n\n缩进风格是代码风格的一部分， 是自发形成的一种约定， 用控制代码块缩进的方式传达程序的结构。\n\n缩进风格可以分为两个方面：`缩进大小`和`大括号位置`。\n\n### 缩进大小\n\n缩进在大部分语言中并不是强制要求， 但合理的缩进有利于人类理解程序的结构， 即提高了代码的清晰性。\n\n> 1983年在PASCAL代码上进行的一项实验发现，缩进大小显着影响了可理解性。2 到 4 个字符之间的缩进大小被证明是最佳的。\n\n在大部分的程序语言中， 默认使用四个空格或一个tab键（制表符可以与空格互相转换， 一个'\\t'等于4个空格）\n\n<!--more-->\n\n在部分的脚本语言或HTML中， 可能会使用2个空格， 以避免过长的缩进。\n\n下文中介绍的风格默认使用4字符缩进。\n\n### 大括号位置\n\n大括号用于声明程序的控制语句的作用域， 跟在`(····)`后面。\n\n下面将介绍几种主流的大括号风格。\n\n#### Allman风格\n\n由一位大牛的名字命名， 又叫做`BSD`风格。\n\n该风格的特点是大括号放到控制语句的下一行， 且与控制语句的缩进相同。\n\n```c\nint main()\n{\n\twhile(cond)\n\t{\n\t\tif(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse if(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//do something\n\t\t}\n\t}\n}\n```\n\n可以发现代码块中的代码与控制语句形成明显的区分， 左右大括号位于同一列， 一般而言对人来说更容易匹配到对应的带括号。\n\nallman风格由于其清晰的代码结构， 常被用于教育。但它的缺点是，当代码块较短时（特别是只有一句），  过多的空行会导致程序很长， 容易让人产生阅读压力以及抓不住焦点。\n\n#### K&R风格\n\n不知道你是否听说过被誉为 `“C语言圣经“`的《C程序设计语言》(*`The C programming language`*)， 这本书由两位大牛Kernighan & Ritchie （K&R）编写， 其中Ritchie正是C语言的创造者。\n\nK&R风格便是在这本书中使用的缩进风格， 同时K&R风格及其变体也是目前使用最广泛的风格。\n\nK&R风格的特点：\n\n* 函数的大括号位于单独一行\n* 控制语句的左大括号不换行， else或else if不换行\n* 只有一条语句的代码块不使用大括号, 而是换行后缩进\n\n```c\nint main()\n{\n\twhile (cond) {\n\t\tif (cond) \n\t\t\tputs(\"K&R \");\n\t\telse (cond)\n\t\t\tputs(\"is best style!\")\n\t\t\n\t\tif (cond) {// )与{中间有空格， 这属于其他部分的代码风格\n\t\t\t//do something\n\t\t} else if (cond) {\n\t\t\t//do something\n\t\t} else {\n\t\t\t//do something\n\t\t}\n\t}\n\t\n}\n```\n\n差不多也能体会到， K&R风格总结起来就是：尽可能的压缩代码。 有人分析这是因为这些代码是要打印到书籍上的， 为了降低成本而尽可能的减少代码行数， 因此也有人称之为印刷风格。\n\nK&R的缺点十分明显：左大括号不好找， 尤其在代码块较长时， 很容易找错左大括号。 就可读性而言确实是比不上Allman的， 但在现代IDE智能的高亮和匹配功能下， 也还行？\n\n#### K&R变体 - 1TBS\n\n”一个真正的大括号风格“（One True Brace Style）， 是K&R的变体之一， 主要区别是：1TBS强制使用大括号， 也就是说即使只有一行也需要用大括号而不能省略。\n\n1TBS存在的真实性存有疑问， 有些人认为它是如上所述的K&R变体， 有些人指出它不过是K&R的”行话“。\n\n#### Whitesmiths风格\n\n特点是大括号需要换行， 且需要缩进\n\n```c\nif (cond)\n\t{\n\tputs(\"This is the whitesmiths style\");\n\t}\nelse if (cond)\n\t{\n\tputs(\"like it?\");\n\t}\n```\n\n#### 圣战\n\nAllman风格(左括号换行， 位于左边)和K&R风格(左括号不换行， 位于右边)是两种最广泛使用的大括号风格， 无数程序员争论到底哪种才是最好的。\n\n在舆论上Allman总是占优， K&R被称为\"过时\"/\"伤害眼睛”。但K&R在早期大牛的影响下（如java API源码, linux源码， golang语法风格等等)的影响下， 在除C外的领域仍然是最主流的风格。\n\n### 总结\n\n永远不存在所谓正确的缩进风格， 最重要的事情是在整个程序中都保持一致的代码风格。\n\n---\n\n### 参考\n\n[缩进样式 - 维基百科)](https://en.wikipedia.org/wiki/Indentation_style#cite_note-catb.org-7)\n\n[缩进样式 (catb.org)](http://catb.org/jargon/html/I/indent-style.html)\n\n[indentation style - Slant](https://www.slant.co/topics/2478/~best-indentation-style-in-c)\n","tags":["缩进风格"],"categories":["杂谈"]},{"title":"认识一下吧","url":"/posts/36271/","content":"\n**Hi, 你好,  欢迎来到trudbot的私人网站。这里暂时内容很少， 但它会慢慢丰富**\n\n### 这是什么网站？\n\n这是我的个人博客网站， 使用开源框架`Hexo`， 托管于`github`上;  推荐桌面浏览器打开。\n\n### 这里会有什么内容？\n\n* 技术学习之路中记录笔记或经验分享\n* 有意思的算法题题目及题解分享\n\n### Notes\n\n* 流畅加载资源需要有正常访问github的能力(\n\n* 若引用了文字或其它内容，将以直链标注或在【参考】中注明。","tags":["博客","导读"]}]