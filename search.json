[{"title":"一文搞定c++自定义排序","url":"/posts/45215/","content":"\n# 前言\n\nc++拥有强大的STL， 在对复杂的数据结构排序时只需要自定义去比较函数， 然后放到容器内调用api即可。\n\n本该是很简单的东西， 但我之前一直无法记住升序以及降序两种方向该分别怎么写，总是会搞混，  每次都得现场Google。终于下定决心要在今天把它彻底搞定。\n\n# 自定义排序的三种比较器形式\n\n\n\n## 比较函数\n\nSTL中的`sort`函数已经为我们提供了排序算法的框架，我们唯一要做的决定就是对于两个元素`a`和`b`， 谁在前、谁在后？\n\n<!--more-->\n\n> sort函数的一个原型\n\n```c++\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last);//无比较器， 升序排序， 会调用<进行元素比较, 小的会放前面\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);//传入比较器， 前后顺序由比较强返回值决定\n```\n\n在`sort`函数中这即为第三个参数：比较器\n\n**比较函数的基本形式**:\n\n```\nbool comp(const type& a, const type& b);\n```\n\n一般而言形参的形式为`const`、引用类型（当然不写也可以， 只是这样更安全、效率更高）。\n\n而返回值于a、b的前后关系是**返回true时， a在前面; 返回false时, b在前面.**\n\n如\n\n```c++\nbool comp(const int &a, const int &b) {\n    return a < b;\n}\n```\n\n返回值为`true`时， a在前面， 且`a<b`， 所以会是升序排序。\n\n所以更透彻的讲， 比较函数的内容其实是**a要想排在b前面所要满足的条件**\n\n**简单小例子**\n\n若用pair<string, int> 存储着若干个学生的`name`和`score`信息， 要对这些学生进行排序， \n\n要求：\n\n* 按分数从高到低\n* 分数相等时按名字字典序排列\n\n很容易的可以得到比较函数为\n\n```c++\nbool cmp(const pair<string, int> &a, const pair<string, int> &b) {\n\tif(a.second != b.second) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n```\n\n**lambda表达式**\n\n比较函数在大多场景下可能仅需使用一次， 因此我们可以用lambda表示式来简写\n\n如\n\n```c++\nsort(data.begin(), data.end(), [](const type& a, const type& b) -> bool {\n        //judge something\n    });\n```\n\n\n\n## 重载<运算符\n\n有时候我们会用结构体或类来定义较为复杂的数据结构， 要对它进行自定义排序除了使用比较函数外， 还可以用重载运算符的方式。\n\n以上面的学生例子举例\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu& b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n```\n\n上述代码重载了stu类的`<`运算符，和比较函数不同的时只有一个参数， 但其实只不过是a参数变成了当前的结构体 。\n\n由于`sort`函数默认为升序, 会把用`<`比较的两个函数中小的放前面， 所以函数体编写思想和比较函数完全一致：写入要把a放到前面满足的条件。\n\n\n\n## 函数对象比较器——重载()\n\n其实就是定义一个结构体或类作为比较器， 重载`()`, 这样类名+`()`就成为了比较函数。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n};\n\nstruct cmp {\n    bool operator() (const stu& a, const stu& b) {\n        if(a.score != b.score) {\n            return a.score > b.score;\n        }\n        return a.name < b.name;\n    }\n};\n\nint main() {\n    vector<stu> a{{\"abc\", 100}, {\"acb\", 100}};\n    sort(a.begin(), a.end(), cmp());\n    for(const auto& i : a) {\n        cout << i.name << \" \" << i.score << endl;\n    }\n}\n```\n\n# 容器应用\n\nSTL用两种比较对象来指代排序的两种方向， 分别是`less`和`greater`分别使用`<`和`>`， 对应升序和降序。在众容器中都默认使用less， 所以结构体要使用默认排序需要重载小于运算符。\n\n也可以显示指出方向， 如以下代码对数组进行了降序排序。\n\n```c++\nint main() {\n    vector<int> a{3, 8, 3, 2, 4};\n    sort(a.begin(), a.end(), greater<>());//重载了< / >运算符， 即可使用less<> / greater<>\n}\n```\n\n要注意的是在set， priority_queue这样的容器不能用比较函数的方式， 只能够使用重载的方式实现。\n\n---\n\n以及比较反人类的是当`priority_queue`使用`less`时其实是大根堆， 使用`greater<>`才是小根堆。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu & b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n\nint main() {\n    priority_queue<stu, vector<stu>> heap;\n    heap.push({\"a\", 100});\n    heap.push({\"b\", 100});\n    heap.push({\"c\", 110});\n    while(!heap.empty()) {\n        cout << heap.top().name << \" \" << heap.top().score << endl;\n        heap.pop();\n    }\n}\n\n//输出结果\n/*\nb 100\na 100\nc 110\n\n*/\n```\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"有点学问在的缩进风格","url":"/posts/57442/","content":"\n### 什么是缩进风格\n\n缩进风格是代码风格的一部分， 是自发形成的一种约定， 用控制代码块缩进的方式传达程序的结构。\n\n缩进风格可以分为两个方面：`缩进大小`和`大括号位置`。\n\n### 缩进大小\n\n缩进在大部分语言中并不是强制要求， 但合理的缩进有利于人类理解程序的结构， 即提高了代码的清晰性。\n\n> 1983年在PASCAL代码上进行的一项实验发现，缩进大小显着影响了可理解性。2 到 4 个字符之间的缩进大小被证明是最佳的。\n\n在大部分的程序语言中， 默认使用四个空格或一个tab键（制表符可以与空格互相转换， 一个'\\t'等于4个空格）\n\n<!--more-->\n\n在部分的脚本语言或HTML中， 可能会使用2个空格， 以避免过长的缩进。\n\n下文中介绍的风格默认使用4字符缩进。\n\n### 大括号位置\n\n大括号用于声明程序的控制语句的作用域， 跟在`(····)`后面。\n\n下面将介绍几种主流的大括号风格。\n\n#### Allman风格\n\n由一位大牛的名字命名， 又叫做`BSD`风格。\n\n该风格的特点是大括号放到控制语句的下一行， 且与控制语句的缩进相同。\n\n```c\nint main()\n{\n\twhile(cond)\n\t{\n\t\tif(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse if(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//do something\n\t\t}\n\t}\n}\n```\n\n可以发现代码块中的代码与控制语句形成明显的区分， 左右大括号位于同一列， 一般而言对人来说更容易匹配到对应的带括号。\n\nallman风格由于其清晰的代码结构， 常被用于教育。但它的缺点是，当代码块较短时（特别是只有一句），  过多的空行会导致程序很长， 容易让人产生阅读压力以及抓不住焦点。\n\n#### K&R风格\n\n不知道你是否听说过被誉为 `“C语言圣经“`的《C程序设计语言》(*`The C programming language`*)， 这本书由两位大牛Kernighan & Ritchie （K&R）编写， 其中Ritchie正是C语言的创造者。\n\nK&R风格便是在这本书中使用的缩进风格， 同时K&R风格及其变体也是目前使用最广泛的风格。\n\nK&R风格的特点：\n\n* 函数的大括号位于单独一行\n* 控制语句的左大括号不换行， else或else if不换行\n* 只有一条语句的代码块不使用大括号, 而是换行后缩进\n\n```c\nint main()\n{\n\twhile (cond) {\n\t\tif (cond) \n\t\t\tputs(\"K&R \");\n\t\telse (cond)\n\t\t\tputs(\"is best style!\")\n\t\t\n\t\tif (cond) {// )与{中间有空格， 这属于其他部分的代码风格\n\t\t\t//do something\n\t\t} else if (cond) {\n\t\t\t//do something\n\t\t} else {\n\t\t\t//do something\n\t\t}\n\t}\n\t\n}\n```\n\n差不多也能体会到， K&R风格总结起来就是：尽可能的压缩代码。 有人分析这是因为这些代码是要打印到书籍上的， 为了降低成本而尽可能的减少代码行数， 因此也有人称之为印刷风格。\n\nK&R的缺点十分明显：左大括号不好找， 尤其在代码块较长时， 很容易找错左大括号。 就可读性而言确实是比不上Allman的， 但在现代IDE智能的高亮和匹配功能下， 也还行？\n\n#### K&R变体 - 1TBS\n\n”一个真正的大括号风格“（One True Brace Style）， 是K&R的变体之一， 主要区别是：1TBS强制使用大括号， 也就是说即使只有一行也需要用大括号而不能省略。\n\n1TBS存在的真实性存有疑问， 有些人认为它是如上所述的K&R变体， 有些人指出它不过是K&R的”行话“。\n\n#### Whitesmiths风格\n\n特点是大括号需要换行， 且需要缩进\n\n```c\nif (cond)\n\t{\n\tputs(\"This is the whitesmiths style\");\n\t}\nelse if (cond)\n\t{\n\tputs(\"like it?\");\n\t}\n```\n\n#### 圣战\n\nAllman风格(左括号换行， 位于左边)和K&R风格(左括号不换行， 位于右边)是两种最广泛使用的大括号风格， 无数程序员争论到底哪种才是最好的。\n\n在舆论上Allman总是占优， K&R被称为\"过时\"/\"伤害眼睛”。但K&R在早期大牛的影响下（如java API源码, linux源码， golang语法风格等等)的影响下， 在除C外的领域仍然是最主流的风格。\n\n### 总结\n\n永远不存在所谓正确的缩进风格， 最重要的事情是在整个程序中都保持一致的代码风格。\n\n---\n\n### 参考\n\n[缩进样式 - 维基百科)](https://en.wikipedia.org/wiki/Indentation_style#cite_note-catb.org-7)\n\n[缩进样式 (catb.org)](http://catb.org/jargon/html/I/indent-style.html)\n\n[indentation style - Slant](https://www.slant.co/topics/2478/~best-indentation-style-in-c)\n","tags":["博客"],"categories":["杂谈"]},{"title":"认识一下吧","url":"/posts/36271/","content":"\n**Hi, 你好,  欢迎来到trudbot的私人网站。这里暂时什么都没有， 但它会慢慢丰富**\n\n### 这是什么网站？\n\n这是我的个人博客网站， 使用开源框架`Hexo`， 托管于`github`上.(意思是我没有写一行代码)\n\n### 这里会有什么内容？\n\n* 技术学习之路中记录笔记或经验分享\n* 有意思的算法题题目及题解分享\n\n","tags":["博客","导读"]}]