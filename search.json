[{"title":"字符串哈希","url":"/posts/52567/","content":"\n# 理论基础\n\n字符串哈希， 即把一个字符串映射为一个整数， 这个整数称之为`hash code`。在理想状态下， 只有两个字符串完全相等， hash code才会相等。 因此可以用两个字符串的`hash code`来判断字符串是否相等。\n\n将字符串转化为整数的函数也叫做哈希函数。\n\n# 字符串前缀哈希\n\n字符串前缀哈希是前缀思想在哈希中的应用， 一般用来解决**多次查询子串哈希**的问题。\n\n> 单次计算一个字符串的哈希值复杂度是 `O(n)`，其中n为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。\n\n<!--more-->\n\n因此可以使用特别的哈希函数， 使用字符串前缀的哈希值而推出任一连续子串的哈希值。\n\n## 哈希函数及公式\n\n设字符串S， S中元素下标从1开始， S下标为i的元素为S[i].\n\n哈希函数：\n$$\nhashCode = \\sum_{i = 1}^nS[i] * p^{n - i}\n$$\n如字符串`\"abc\"`， 表达式为\n$$\na * p ^ 2  + b * p + c\n$$\n利用此公司， 我们可以求出S的所有前缀的哈希值\n\n但显然不可能对所有前缀都应用上述公式。事实上pref[i] 可以由pref[i-1]递推得到\n\n仍然以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n可以发现\n\n```F#\npref[i] = pref[i-1] * p + S[i]\n```\n\n## 区间哈希\n\n我们得到了一个字符串所有长度前缀的哈希值， 那么如何利用它来得到某个区间[l, r]的哈希值呢？\n\n以`\"abc\"`举例\n$$\n{\npref[1] = a\\\\\npref[2] = a * p + b\\\\\npref[3] = a * p ^ 2 + b * p + c\n}\n$$\n假设我们要求[2, 3]区间， 即`\"bc\"`的哈希， 按上述哈希函数应该是`b*p + c`\n\n类比前缀和`sum[l, r] = pref[r] - pref[l-1]`, 可以发现\n$$\nb * p + c = pref[3] - pref[1] * p ^ 2\n$$\n事实上， 存在以下通式\n$$\nhashCode[l, r] = pref[r] - pref[l - 1] * (r - l + 1)\n$$\n证明并不难， 若有兴趣自行研究， 就不在此赘述了。\n\n其中`r - l + 1`很明显的， 可以记忆为区间的长度。\n\n因此通过预处理字符串所有前缀的哈希， 我们可以以O(1)的时间代价求出任一子串的哈希值。\n\n## 代码实现(C++)\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N]; // hh[i] 表示长度为i的前缀子串的哈希\null p[N];// p[i]表示P的i次幂, 避免使用幂函数多次求幂\n\n// 初始化前缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n```\n\n**小科普： unsigned long long**\n\n\n\null(unsigned long long)表示64位无符号正整数， 之所以使用ull是因为ull溢出后， 不会像有符号整数如int那样变成负数， 而是会从0重新开始， 即等同于对$2 ^ {64}$自动取余。\n\n在上述哈希函数中， P选取为131(此质数在先人的实验中表现最好， 不容易发生冲突)， 而hashCode更是以幂级增长的， 因此很容易就溢出， 需要对其进行取模。\n\n# 算法应用\n\n## 判断子串是否相等\n\n要判断两个子串是否相等， 只需比较哈希值是否相等即可。预处理前缀哈希， 即可以O(1)的时间代价得到子串的哈希。\n\n### 例题\n\n**AcWing 841**\n\n> 给定一个长度为 *n* 的字符串，再给定 *m* 个询问，每个询问包含四个整数 `l1, r1, l2, r2`，请你判断 \\[l1,r1] 和 \\[l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n>\n> 字符串中只包含大小写英文字母和数字。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n 和 m，表示字符串长度和询问次数。\n>\n> 第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。\n>\n> 接下来 m 行，每行包含四个整数 `l1, r1, l2, r2`，表示一次询问所涉及的两个区间。\n>\n> 注意，字符串的位置从 1 开始编号。\n>\n> #### 输出格式\n>\n> 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。\n>\n> 每个结果占一行。\n>\n> #### 数据范围\n>\n> 1≤n,m≤$10^5$\n>\n> #### 输入样例：\n>\n> ```\n> 8 3\n> aabbaabb\n> 1 3 5 7\n> 1 3 6 8\n> 1 2 1 2\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> Yes\n> No\n> Yes\n> ```\n\n套上上面的板子即可\n\n**时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\n\nconst int N = 1e5 + 10;\nconst ull P = 131;\null hh[N], p[N];\nstring s;\nint n;\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        p[i] = p[i-1] * P;\n    }\n}\n\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> s;\n    s.insert(0, \"0\");\n    InitHash();\n    while(m --) {\n        int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;\n        cout << (get(l1, r1) == get(l2, r2) ? \"Yes\" : \"No\") << endl;\n    }\n}\n```\n\n\n\n## 判断子串是否是回文\n\n回文即源串与反转后的字符串是相同的。\n\n用字符串哈希的角度来解决就是判断一个字符串及其逆转后的字符串哈希值是否相等。\n\n因此我们可以预处理主串的正向哈希以及逆向哈希， 再判断某子串的正向哈希和逆向哈希是否相等来判断是否是回文。\n\n```c++\n#define ull unsigned long long \nstring s;//源字符串， 下标从1开始\nint n; //字符串长度\nconst ull P = 131;\null hh[N], r_hh[N];//前缀、后缀哈希\null p[N];\n\n// 初始化前缀/后缀哈希\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n\n// 获取区间哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n```\n\n### 例题 **google kickstart Round E P3**\n\n> 给定一个长度为 N 的回文字符串 P，它仅由小写英文字母构成。\n>\n> 请你找到最短的**非空回文**字符串 Q，使得 P 与 Q 拼接而成的字符串 Q 也是一个回文串。\n>\n> #### 输入格式\n>\n> \n>\n> 第一行包含整数 T，表示共有 T 组测试数据。\n>\n> 每组数据第一行包含一个整数 N。\n>\n> 第二行包含一个长度为 N 的回文字符串 PP。\n>\n> #### 输出格式\n>\n> \n>\n> 每组数据输出一个结果，每个结果占一行。\n>\n> 结果表示为 `Case #x: y`，其中 xx 为组别编号（从 11 开始），y 为满足条件的最短**非空回文**字符串 Q。\n>\n> #### 数据范围\n>\n> \n>\n> 1≤T≤100\n> 1≤N≤10^5^，\n> 保证 P 是一个由小写字母构成的回文字符串。\n>\n> \n>\n> #### 输入样例：\n>\n> ```F#\n> 3\n> 4\n> abba\n> 4\n> cccc\n> 6\n> cdccdc\n> ```\n>\n> #### 输出样例：\n>\n> ```F#\n> Case #1: abba\n> Case #2: c\n> Case #3: cdc\n> ```\n>\n> #### 样例解释\n>\n> \n>\n> 在 Case 1 中，满足条件的最短回文串 Q 为 `abba`，此时串联字符串 Q 为 `abbaabba`，这是一个回文串。\n>\n> 在 Case 2 中，满足条件的最短回文串 Q 为 `c`，此时串联字符串 PQ为 `ccccc`，这是一个回文串。\n>\n> 在 Case 3 中，满足条件的最短回文串 Q 为 `cdc`，此时串联字符串 PQ 为 `cdccdccdc`，这是一个回文串。\n\n**题意分析**\n\n给定回文字符串P, 求一回文字符串Q， 使在P末尾拼接Q后， PQ仍为回文字符串。\n\n不难分析得到， 由于PQ是回文字符串， 则P中长度等于Q的前缀应该与Q成倒序关系， 设这个前缀为P1, P中除去P1的后半部分为P2。又因为Q为回文字符串， 所以P1会等于Q， P1为回文字符串。而P2显然也要是回文字符串， 这样才能满足PQ为回文字符串。\n\n**因此， 将问题剥析出来就是：求最小的整数mid（1~n）, 使得P[1, mid]和P[mid+1, n]均为回文字符串。**\n\n**参考代码， 时间复杂度：O(n)**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long \nstring s;\nint n; \nconst ull P = 131;\nconst int N = 1e5 + 10;\null hh[N], r_hh[N];\null p[N];\n\nvoid InitHash() {\n    p[0] = 1;\n    for(int i=1; i<=n; i++) {\n        hh[i] = hh[i-1] * P + s[i];\n        r_hh[i] = r_hh[i-1] * P + s[n - i + 1];\n        p[i] = p[i-1] * P;\n    }\n}\n//获取正哈希\null get(int l, int r) {\n    return hh[r] - hh[l - 1] * p[r - l + 1];\n}\n\n//获取反哈希\null get_r(int l, int r) {\n    return r_hh[n - l + 1] - r_hh[n - r] * p[r - l + 1];\n}\n\n//判断回文\nbool is_palindrome(int l, int r) {\n    return get(l ,r) == get_r(l, r);\n}\n\nint main() {\n    int T; cin >> T;\n    for(int t=1; t<=T; t++) {\n        cout << \"Case #\" << t << \": \"; \n        cin >> n >> s;\n        s.insert(0, \"0\");//调整下标\n        InitHash();\n        for(int i=1; i<=n; i++) {//枚举mid\n            if(is_palindrome(1, i) && is_palindrome(i+1, n)) {\n                cout << s.substr(1, i) << endl;\n                break;\n            }\n        }\n    }\n}\n```\n\n# 参考\n\n[字符串哈希 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/hash/)\n\n[【算法学习笔记】7：字符串前缀哈希法_LauZyHou的博客-CSDN博客](https://blog.csdn.net/SHU15121856/article/details/109553503)\n\n[AcWing 841. 字符串哈希 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/2691/)","tags":["博客"],"categories":["一文搞定系列"]},{"title":"一文搞定c++自定义排序","url":"/posts/45215/","content":"\n# 前言\n\nc++拥有强大的STL， 在对复杂的数据结构排序时只需要自定义去比较函数， 然后放到容器内调用api即可。\n\n本该是很简单的东西， 但我之前一直无法记住升序以及降序两种方向该分别怎么写，总是会搞混，  每次都得现场Google。终于下定决心要在今天把它彻底搞定。\n\n# 自定义排序的三种比较器形式\n\n\n\n## 比较函数\n\nSTL中的`sort`函数已经为我们提供了排序算法的框架，我们唯一要做的决定就是对于两个元素`a`和`b`， 谁在前、谁在后？\n\n<!--more-->\n\n\n\n> sort函数的一个原型\n\n```c++\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last);//无比较器， 升序排序， 会调用<进行元素比较, 小的会放前面\nvoid sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);//传入比较器， 前后顺序由比较强返回值决定\n```\n\n在`sort`函数中这即为第三个参数：比较器\n\n**比较函数的基本形式**:\n\n```\nbool comp(const type& a, const type& b);\n```\n\n一般而言形参的形式为`const`、引用类型（当然不写也可以， 只是这样更安全、效率更高）。\n\n而返回值于a、b的前后关系是**返回true时， a在前面; 返回false时, b在前面.**\n\n如\n\n```c++\nbool comp(const int &a, const int &b) {\n    return a < b;\n}\n```\n\n返回值为`true`时， a在前面， 且`a<b`， 所以会是升序排序。\n\n所以更透彻的讲， 比较函数的内容其实是**a要想排在b前面所要满足的条件**\n\n**简单小例子**\n\n若用pair<string, int> 存储着若干个学生的`name`和`score`信息， 要对这些学生进行排序， \n\n要求：\n\n* 按分数从高到低\n* 分数相等时按名字字典序排列\n\n很容易的可以得到比较函数为\n\n```c++\nbool cmp(const pair<string, int> &a, const pair<string, int> &b) {\n\tif(a.second != b.second) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n```\n\n**lambda表达式**\n\n比较函数在大多场景下可能仅需使用一次， 因此我们可以用lambda表示式来简写\n\n如\n\n```c++\nsort(data.begin(), data.end(), [](const type& a, const type& b) -> bool {\n        //judge something\n    });\n```\n\n\n\n## 重载<运算符\n\n有时候我们会用结构体或类来定义较为复杂的数据结构， 要对它进行自定义排序除了使用比较函数外， 还可以用重载运算符的方式。\n\n以上面的学生例子举例\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu& b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n```\n\n上述代码重载了stu类的`<`运算符，和比较函数不同的时只有一个参数， 但其实只不过是a参数变成了当前的结构体 。\n\n由于`sort`函数默认为升序, 会把用`<`比较的两个函数中小的放前面， 所以函数体编写思想和比较函数完全一致：写入要把a放到前面满足的条件。\n\n\n\n## 函数对象比较器——重载()\n\n其实就是定义一个结构体或类作为比较器， 重载`()`, 这样类名+`()`就成为了比较函数。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n};\n\nstruct cmp {\n    bool operator() (const stu& a, const stu& b) {\n        if(a.score != b.score) {\n            return a.score > b.score;\n        }\n        return a.name < b.name;\n    }\n};\n\nint main() {\n    vector<stu> a{{\"abc\", 100}, {\"acb\", 100}};\n    sort(a.begin(), a.end(), cmp());\n    for(const auto& i : a) {\n        cout << i.name << \" \" << i.score << endl;\n    }\n}\n```\n\n# 容器应用\n\nSTL用两种比较对象来指代排序的两种方向， 分别是`less`和`greater`分别使用`<`和`>`， 对应升序和降序。在众容器中都默认使用less， 所以结构体要使用默认排序需要重载小于运算符。\n\n也可以显示指出方向， 如以下代码对数组进行了降序排序。\n\n```c++\nint main() {\n    vector<int> a{3, 8, 3, 2, 4};\n    sort(a.begin(), a.end(), greater<>());//重载了< / >运算符， 即可使用less<> / greater<>\n}\n```\n\n要注意的是在set， priority_queue这样的容器不能用比较函数的方式， 只能够使用重载的方式实现。\n\n---\n\n以及比较反人类的是当`priority_queue`使用`less`时其实是大根堆， 使用`greater<>`才是小根堆。\n\n```c++\nstruct stu {\n    string name;\n    int score;\n\n    bool operator < (const stu & b) const {\n        if(score != b.score) {\n            return score > b.score;\n        }\n        return name < b.name;\n    }\n};\n\nint main() {\n    priority_queue<stu, vector<stu>> heap;\n    heap.push({\"a\", 100});\n    heap.push({\"b\", 100});\n    heap.push({\"c\", 110});\n    while(!heap.empty()) {\n        cout << heap.top().name << \" \" << heap.top().score << endl;\n        heap.pop();\n    }\n}\n\n//输出结果\n/*\nb 100\na 100\nc 110\n\n*/\n```\n","tags":["博客"],"categories":["一文搞定系列"]},{"title":"有点学问在的缩进风格","url":"/posts/57442/","content":"\n### 什么是缩进风格\n\n缩进风格是代码风格的一部分， 是自发形成的一种约定， 用控制代码块缩进的方式传达程序的结构。\n\n缩进风格可以分为两个方面：`缩进大小`和`大括号位置`。\n\n### 缩进大小\n\n缩进在大部分语言中并不是强制要求， 但合理的缩进有利于人类理解程序的结构， 即提高了代码的清晰性。\n\n> 1983年在PASCAL代码上进行的一项实验发现，缩进大小显着影响了可理解性。2 到 4 个字符之间的缩进大小被证明是最佳的。\n\n在大部分的程序语言中， 默认使用四个空格或一个tab键（制表符可以与空格互相转换， 一个'\\t'等于4个空格）\n\n<!--more-->\n\n在部分的脚本语言或HTML中， 可能会使用2个空格， 以避免过长的缩进。\n\n下文中介绍的风格默认使用4字符缩进。\n\n### 大括号位置\n\n大括号用于声明程序的控制语句的作用域， 跟在`(····)`后面。\n\n下面将介绍几种主流的大括号风格。\n\n#### Allman风格\n\n由一位大牛的名字命名， 又叫做`BSD`风格。\n\n该风格的特点是大括号放到控制语句的下一行， 且与控制语句的缩进相同。\n\n```c\nint main()\n{\n\twhile(cond)\n\t{\n\t\tif(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse if(cond)\n\t\t{\n\t\t\t//do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//do something\n\t\t}\n\t}\n}\n```\n\n可以发现代码块中的代码与控制语句形成明显的区分， 左右大括号位于同一列， 一般而言对人来说更容易匹配到对应的带括号。\n\nallman风格由于其清晰的代码结构， 常被用于教育。但它的缺点是，当代码块较短时（特别是只有一句），  过多的空行会导致程序很长， 容易让人产生阅读压力以及抓不住焦点。\n\n#### K&R风格\n\n不知道你是否听说过被誉为 `“C语言圣经“`的《C程序设计语言》(*`The C programming language`*)， 这本书由两位大牛Kernighan & Ritchie （K&R）编写， 其中Ritchie正是C语言的创造者。\n\nK&R风格便是在这本书中使用的缩进风格， 同时K&R风格及其变体也是目前使用最广泛的风格。\n\nK&R风格的特点：\n\n* 函数的大括号位于单独一行\n* 控制语句的左大括号不换行， else或else if不换行\n* 只有一条语句的代码块不使用大括号, 而是换行后缩进\n\n```c\nint main()\n{\n\twhile (cond) {\n\t\tif (cond) \n\t\t\tputs(\"K&R \");\n\t\telse (cond)\n\t\t\tputs(\"is best style!\")\n\t\t\n\t\tif (cond) {// )与{中间有空格， 这属于其他部分的代码风格\n\t\t\t//do something\n\t\t} else if (cond) {\n\t\t\t//do something\n\t\t} else {\n\t\t\t//do something\n\t\t}\n\t}\n\t\n}\n```\n\n差不多也能体会到， K&R风格总结起来就是：尽可能的压缩代码。 有人分析这是因为这些代码是要打印到书籍上的， 为了降低成本而尽可能的减少代码行数， 因此也有人称之为印刷风格。\n\nK&R的缺点十分明显：左大括号不好找， 尤其在代码块较长时， 很容易找错左大括号。 就可读性而言确实是比不上Allman的， 但在现代IDE智能的高亮和匹配功能下， 也还行？\n\n#### K&R变体 - 1TBS\n\n”一个真正的大括号风格“（One True Brace Style）， 是K&R的变体之一， 主要区别是：1TBS强制使用大括号， 也就是说即使只有一行也需要用大括号而不能省略。\n\n1TBS存在的真实性存有疑问， 有些人认为它是如上所述的K&R变体， 有些人指出它不过是K&R的”行话“。\n\n#### Whitesmiths风格\n\n特点是大括号需要换行， 且需要缩进\n\n```c\nif (cond)\n\t{\n\tputs(\"This is the whitesmiths style\");\n\t}\nelse if (cond)\n\t{\n\tputs(\"like it?\");\n\t}\n```\n\n#### 圣战\n\nAllman风格(左括号换行， 位于左边)和K&R风格(左括号不换行， 位于右边)是两种最广泛使用的大括号风格， 无数程序员争论到底哪种才是最好的。\n\n在舆论上Allman总是占优， K&R被称为\"过时\"/\"伤害眼睛”。但K&R在早期大牛的影响下（如java API源码, linux源码， golang语法风格等等)的影响下， 在除C外的领域仍然是最主流的风格。\n\n### 总结\n\n永远不存在所谓正确的缩进风格， 最重要的事情是在整个程序中都保持一致的代码风格。\n\n---\n\n### 参考\n\n[缩进样式 - 维基百科)](https://en.wikipedia.org/wiki/Indentation_style#cite_note-catb.org-7)\n\n[缩进样式 (catb.org)](http://catb.org/jargon/html/I/indent-style.html)\n\n[indentation style - Slant](https://www.slant.co/topics/2478/~best-indentation-style-in-c)\n","tags":["博客"],"categories":["杂谈"]},{"title":"认识一下吧","url":"/posts/36271/","content":"\n**Hi, 你好,  欢迎来到trudbot的私人网站。这里暂时内容很少， 但它会慢慢丰富**\n\n你可以点击[trudbot的空中小岛](http://trudbot.gitee.io/)进入镜像站， 获得更流畅的阅读体验。\n\n### 这是什么网站？\n\n这是我的个人博客网站， 使用开源框架`Hexo`， 托管于`github`上;  推荐桌面浏览器打开。\n\n### 这里会有什么内容？\n\n* 技术学习之路中记录笔记或经验分享\n* 有意思的算法题题目及题解分享\n\n","tags":["博客","导读"]}]